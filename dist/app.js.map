{
  "version": 3,
  "sources": ["../src/utils/CatmullRom.js", "../src/utils/Easing.js", "../src/config/constants.js", "../src/services/StorageService.js", "../src/services/CoordinateTransform.js", "../src/services/PathCalculator.js", "../src/services/PathCalculatorWithWorker.js", "../src/models/AnimationState.js", "../src/services/AnimationEngine.js", "../src/services/RenderingService.js", "../src/core/EventBus.js", "../src/models/Waypoint.js", "../src/controllers/UIController.js", "../src/handlers/InteractionHandler.js", "../src/main.js"],
  "sourcesContent": ["/**\n * Catmull-Rom Spline Implementation\n * Provides smooth curve interpolation through a set of waypoints\n */\nexport class CatmullRom {\n  /**\n   * Interpolates a point on a Catmull-Rom spline between p1 and p2\n   * @param {Object} p0 - Previous control point {x, y}\n   * @param {Object} p1 - Start point of segment {x, y}\n   * @param {Object} p2 - End point of segment {x, y}\n   * @param {Object} p3 - Next control point {x, y}\n   * @param {number} t - Interpolation parameter (0 to 1)\n   * @param {number} tension - Tension value (lower = tighter curves, higher = looser curves)\n   * @returns {Object} Interpolated point {x, y}\n   */\n  static interpolate(p0, p1, p2, p3, t, tension) {\n    \n    const t2 = t * t;\n    const t3 = t2 * t;\n    \n    // Pre-calculate tangent vectors\n    const v0x = (p2.x - p0.x) * tension;\n    const v0y = (p2.y - p0.y) * tension;\n    const v1x = (p3.x - p1.x) * tension;\n    const v1y = (p3.y - p1.y) * tension;\n    \n    // Calculate position using Hermite basis functions\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    \n    return {\n      x: p1.x + v0x * t + (3 * dx - 2 * v0x - v1x) * t2 + (2 * -dx + v0x + v1x) * t3,\n      y: p1.y + v0y * t + (3 * dy - 2 * v0y - v1y) * t2 + (2 * -dy + v0y + v1y) * t3\n    };\n  }\n  \n  /**\n   * Creates a smooth path through waypoints using Catmull-Rom splines\n   * @param {Array} waypoints - Array of waypoint objects with x and y properties\n   * @param {number} pointsPerSegment - Number of points to generate per segment (default: 30)\n   * @param {number} tension - Tension value (lower = tighter curves, higher = looser curves)\n   * @returns {Array} Array of interpolated points forming the path\n   */\n  static createPath(waypoints, pointsPerSegment = 30, tension = 0.5) {\n    if (waypoints.length < 2) return [];\n    \n    const path = [];\n    const lastIndex = waypoints.length - 1;\n    const step = 1 / pointsPerSegment;\n    \n    // Generate path segments\n    for (let i = 0; i < lastIndex; i++) {\n      const p0 = waypoints[i === 0 ? 0 : i - 1];\n      const p1 = waypoints[i];\n      const p2 = waypoints[i + 1];\n      const p3 = waypoints[i === lastIndex - 1 ? lastIndex : i + 2];\n      \n      // Generate points for this segment\n      for (let j = 0; j < pointsPerSegment; j++) {\n        path.push(CatmullRom.interpolate(p0, p1, p2, p3, j * step, tension));\n      }\n    }\n    \n    // Add the final waypoint\n    path.push(waypoints[lastIndex]);\n    \n    return path;\n  }\n}\n", "/**\n * Essential easing functions for Route Plotter\n * Optimized for performance and clarity\n * \n * All functions: t \u2208 [0,1] \u2192 result \u2208 [0,1]\n */\nexport class Easing {\n  /**\n   * Quadratic ease-in - slow start, accelerating\n   * \n   * Usage: Corner slowing calculations in path generation\n   * Called ~1000+ times per path during reparameterization\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static quadIn(t) {\n    return t * t;\n  }\n  \n  /**\n   * Cubic ease-out - fast start, decelerating\n   * \n   * Usage: Ripple fade effects in beacon animations\n   * Called every frame (60 FPS) for each active ripple\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static cubicOut(t) {\n    const t1 = t - 1;\n    return t1 * t1 * t1 + 1;\n  }\n  \n  /**\n   * Cubic ease-in-out - smooth S-curve\n   * \n   * Usage: Global animation timing for smooth start/stop\n   * Called every frame (60 FPS) in main animation loop\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static cubicInOut(t) {\n    return t < 0.5 \n      ? 4 * t * t * t \n      : 1 + 4 * (t - 1) * (t - 1) * (t - 1);\n  }\n}\n", "/**\n * Application-wide constants for Route Plotter v3\n */\n\n// Animation timing and performance\nexport const ANIMATION = {\n  DEFAULT_DURATION: 10000,       // 10 seconds (default duration)\n  DEFAULT_SPEED: 400,            // pixels per second (default animation speed - reasonable starting speed)\n  TARGET_FPS: 60,\n  FRAME_INTERVAL: 1000 / 60,     // ~16.67ms per frame\n  MAX_DELTA_TIME: 100,           // Maximum time jump to prevent huge leaps\n  DEFAULT_PLAYBACK_SPEED: 1,\n  DEFAULT_WAIT_TIME: 0,          // Default waypoint pause time\n  TIMELINE_RESOLUTION: 1000      // Slider steps (0-1000)\n};\n\n// Rendering and visual styles\nexport const RENDERING = {\n  DEFAULT_PATH_COLOR: '#FF6B6B',\n  DEFAULT_PATH_THICKNESS: 3,\n  DEFAULT_DOT_SIZE: 8,\n  MINOR_DOT_SIZE: 4,\n  PATH_HEAD_SIZE: 8,\n  BEACON_PULSE_DURATION: 2000,   // Beacon animation cycle\n  BEACON_MAX_RADIUS: 30,\n  BEACON_PULSE_SIZE: 10,         // Base size for pulse effect\n  BEACON_PULSE_OPACITY: 0.4,     // Opacity for pulse glow\n  BEACON_RIPPLE_DURATION: 1500,  // Ripple lifetime in ms\n  BEACON_RIPPLE_INTERVAL: 500,   // Time between ripples in ms\n  BEACON_RIPPLE_SPEED: 30,       // Ripple expansion speed (pixels per ms)\n  LABEL_OFFSET_X: 10,\n  LABEL_OFFSET_Y: 5,\n  LABEL_FONT_SIZE: 14,\n  LABEL_FADE_TIME: 2000,         // Label fade duration in ms\n  SQUIGGLE_AMPLITUDE: 0.15,      // Wave amplitude for squiggle paths\n  RANDOMISED_JITTER: 3,          // Jitter amount for randomised paths\n  CONTROLS_HEIGHT: 80            // Height of bottom controls panel in pixels\n};\n\n// Path calculation parameters\nexport const PATH = {\n  POINTS_PER_SEGMENT: 100,        // Catmull-Rom interpolation density\n  DEFAULT_TENSION: 0.2,           // Catmull-Rom tension - lower = tighter curves; higher = looser curves\n  TARGET_SPACING: 2,              // Pixels between points after reparameterization\n  MAX_CURVATURE: 0.1,             // Threshold for maximum corner slowing\n  MIN_CORNER_SPEED: 0.2,          // Minimum 20% speed at tight corners (was 40% - now slows more)\n  CORNER_THRESHOLD: 30,           // Degrees for corner detection\n  CORNER_SLOW_RADIUS: 15,\n  CORNER_SLOW_FACTOR: 0.7\n};\n\n// UI interaction thresholds\nexport const INTERACTION = {\n  WAYPOINT_HIT_RADIUS: 15,        // Click detection radius for waypoints (pixels)\n  DRAG_THRESHOLD: 3,              // Minimum pixels to consider a drag\n  DOUBLE_CLICK_TIME: 300,         // Maximum ms between clicks for double-click\n  LONG_PRESS_TIME: 500,           // Time for long press detection\n  ZOOM_SENSITIVITY: 0.001,\n  PAN_SENSITIVITY: 1\n};\n\n// Storage keys for persistence\nexport const STORAGE = {\n  AUTOSAVE_KEY: 'routePlotter_autosave',\n  PREFERENCES_KEY: 'routePlotter_preferences',\n  SPLASH_SHOWN_KEY: 'routePlotter_splashShown',\n  AUTOSAVE_INTERVAL: 1000         // Debounce time for autosave\n};\n\n// Accessibility\nexport const A11Y = {\n  ANNOUNCEMENT_DELAY: 100,        // Delay for screen reader announcements\n  FOCUS_VISIBLE_OUTLINE: '2px solid #0066CC',\n  HIGH_CONTRAST_RATIO: 4.5        // WCAG AA standard\n};\n\n// Z-index layers for rendering order\nexport const LAYERS = {\n  BACKGROUND: 0,\n  OVERLAY: 1,\n  PATH: 2,\n  WAYPOINTS: 3,\n  LABELS: 4,\n  UI_HANDLES: 5,\n  PATH_HEAD: 6,\n  BEACONS: 7\n};\n", "import { STORAGE } from '../config/constants.js';\n\n/**\n * Service for handling localStorage operations\n * Provides methods for saving and loading application state with error handling\n */\nexport class StorageService {\n  constructor() {\n    this.debounceTimer = null;\n    this._lastSerialized = null; // Track last saved state for change detection\n  }\n  \n  /**\n   * Save data to localStorage\n   * @param {string} key - Storage key\n   * @param {any} data - Data to save (will be JSON stringified)\n   * @returns {boolean} True if successful\n   */\n  save(key, data) {\n    try {\n      const serialized = JSON.stringify(data);\n      localStorage.setItem(key, serialized);\n      return true;\n    } catch (error) {\n      console.error(`Failed to save to localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Load data from localStorage\n   * @param {string} key - Storage key\n   * @param {any} defaultValue - Default value if key doesn't exist or parse fails\n   * @returns {any} Parsed data or default value\n   */\n  load(key, defaultValue = null) {\n    try {\n      const item = localStorage.getItem(key);\n      if (item === null) return defaultValue;\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Failed to load from localStorage (${key}):`, error);\n      return defaultValue;\n    }\n  }\n  \n  /**\n   * Remove item from localStorage\n   * @param {string} key - Storage key\n   * @returns {boolean} True if successful\n   */\n  remove(key) {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove from localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Check if a key exists in localStorage\n   * @param {string} key - Storage key\n   * @returns {boolean} True if key exists\n   */\n  exists(key) {\n    try {\n      return localStorage.getItem(key) !== null;\n    } catch (error) {\n      console.error(`Failed to check localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Save application state (debounced with change detection)\n   * @param {Object} state - Application state to save\n   */\n  autoSave(state) {\n    // Skip if nothing changed - pure optimization with no downside\n    const newSerialized = JSON.stringify(state);\n    if (newSerialized === this._lastSerialized) {\n      return; // No changes detected, skip save\n    }\n    \n    // Clear existing timer\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n    \n    // Set new timer\n    this.debounceTimer = setTimeout(() => {\n      this.save(STORAGE.AUTOSAVE_KEY, state);\n      this._lastSerialized = newSerialized; // Remember for next comparison\n      console.log('Auto-saved state');\n    }, STORAGE.AUTOSAVE_INTERVAL);\n  }\n  \n  /**\n   * Load auto-saved application state\n   * @returns {Object|null} Saved state or null\n   */\n  loadAutoSave() {\n    return this.load(STORAGE.AUTOSAVE_KEY, null);\n  }\n  \n  /**\n   * Clear auto-saved state\n   * @returns {boolean} True if successful\n   */\n  clearAutoSave() {\n    return this.remove(STORAGE.AUTOSAVE_KEY);\n  }\n  \n  /**\n   * Save user preferences\n   * @param {Object} preferences - User preferences\n   * @returns {boolean} True if successful\n   */\n  savePreferences(preferences) {\n    return this.save(STORAGE.PREFERENCES_KEY, preferences);\n  }\n  \n  /**\n   * Load user preferences\n   * @returns {Object} User preferences with defaults\n   */\n  loadPreferences() {\n    return this.load(STORAGE.PREFERENCES_KEY, {\n      showSplash: true,\n      theme: 'light',\n      animationSpeed: 1,\n      autoSave: true,\n      keyboardShortcuts: true,\n      highContrast: false\n    });\n  }\n  \n  /**\n   * Check if splash screen should be shown\n   * @returns {boolean} True if splash should be shown\n   */\n  shouldShowSplash() {\n    return !this.exists(STORAGE.SPLASH_SHOWN_KEY);\n  }\n  \n  /**\n   * Mark splash screen as shown\n   */\n  markSplashShown() {\n    this.save(STORAGE.SPLASH_SHOWN_KEY, true);\n  }\n  \n  /**\n   * Export all data as JSON string\n   * @returns {string} JSON string of all localStorage data\n   */\n  exportData() {\n    const data = {\n      autosave: this.loadAutoSave(),\n      preferences: this.loadPreferences(),\n      timestamp: new Date().toISOString()\n    };\n    return JSON.stringify(data, null, 2);\n  }\n  \n  /**\n   * Import data from JSON string\n   * @param {string} jsonString - JSON string to import\n   * @returns {boolean} True if successful\n   */\n  importData(jsonString) {\n    try {\n      const data = JSON.parse(jsonString);\n      \n      if (data.autosave) {\n        this.save(STORAGE.AUTOSAVE_KEY, data.autosave);\n      }\n      \n      if (data.preferences) {\n        this.save(STORAGE.PREFERENCES_KEY, data.preferences);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to import data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Clear all stored data\n   * @returns {boolean} True if successful\n   */\n  clearAll() {\n    try {\n      const keys = [\n        STORAGE.AUTOSAVE_KEY,\n        STORAGE.PREFERENCES_KEY,\n        STORAGE.SPLASH_SHOWN_KEY\n      ];\n      \n      keys.forEach(key => this.remove(key));\n      return true;\n    } catch (error) {\n      console.error('Failed to clear all data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Get storage size estimate\n   * @returns {Promise<Object>} Storage quota and usage\n   */\n  async getStorageInfo() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      try {\n        const estimate = await navigator.storage.estimate();\n        return {\n          usage: estimate.usage,\n          quota: estimate.quota,\n          percentage: (estimate.usage / estimate.quota) * 100\n        };\n      } catch (error) {\n        console.error('Failed to estimate storage:', error);\n      }\n    }\n    return null;\n  }\n}\n", "/**\n * Service for handling coordinate transformations between different coordinate systems\n * Simplified version using 1:1 mapping when canvas matches image dimensions\n * Falls back to complex transformation for fit/fill modes\n */\nexport class CoordinateTransform {\n  constructor() {\n    this.canvasWidth = 0;\n    this.canvasHeight = 0;\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n    this.imageBounds = null;\n    this.fitMode = 'fit'; // 'fit' or 'fill'\n    this.transform = null; // Cached transformation matrix for performance\n  }\n  \n  /**\n   * Update canvas dimensions\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   */\n  setCanvasDimensions(width, height) {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n  \n  /**\n   * Update image dimensions and calculate display bounds\n   * @param {number} width - Image width\n   * @param {number} height - Image height\n   * @param {string} fitMode - How to fit image ('fit' or 'fill')\n   */\n  setImageDimensions(width, height, fitMode = 'fit') {\n    this.imageWidth = width;\n    this.imageHeight = height;\n    this.fitMode = fitMode;\n    this.calculateImageBounds();\n  }\n  \n  /**\n   * Calculate image display bounds and pre-compute transformation matrix\n   * @private\n   */\n  calculateImageBounds() {\n    if (!this.imageWidth || !this.imageHeight || !this.canvasWidth || !this.canvasHeight) {\n      this.imageBounds = null;\n      this.transform = null;\n      return;\n    }\n    \n    const canvasAspect = this.canvasWidth / this.canvasHeight;\n    const imageAspect = this.imageWidth / this.imageHeight;\n    \n    let scale, x, y, w, h;\n    \n    if (this.fitMode === 'fit') {\n      // Scale image to fit within canvas\n      if (imageAspect > canvasAspect) {\n        // Image is wider - fit to width\n        scale = this.canvasWidth / this.imageWidth;\n      } else {\n        // Image is taller - fit to height\n        scale = this.canvasHeight / this.imageHeight;\n      }\n      \n      w = this.imageWidth * scale;\n      h = this.imageHeight * scale;\n      x = (this.canvasWidth - w) / 2;\n      y = (this.canvasHeight - h) / 2;\n    } else {\n      // Fill mode - scale image to cover canvas\n      if (imageAspect > canvasAspect) {\n        // Image is wider - fit to height\n        scale = this.canvasHeight / this.imageHeight;\n      } else {\n        // Image is taller - fit to width\n        scale = this.canvasWidth / this.imageWidth;\n      }\n      \n      w = this.imageWidth * scale;\n      h = this.imageHeight * scale;\n      x = (this.canvasWidth - w) / 2;\n      y = (this.canvasHeight - h) / 2;\n    }\n    \n    this.imageBounds = { x, y, w, h, scale };\n    \n    // Pre-calculate transformation matrix for fast coordinate conversion\n    // This eliminates repeated calculations on every transform call\n    if (this.fitMode === 'fit') {\n      // Fit mode: simple linear transform\n      this.transform = {\n        // canvasToImage coefficients\n        c2i_scaleX: 1 / w,              // Cache reciprocal (multiply faster than divide)\n        c2i_scaleY: 1 / h,\n        c2i_offsetX: -x / w,            // Pre-calculate offset\n        c2i_offsetY: -y / h,\n        \n        // imageToCanvas coefficients\n        i2c_scaleX: w,\n        i2c_scaleY: h,\n        i2c_offsetX: x,\n        i2c_offsetY: y\n      };\n    } else {\n      // Fill mode: account for cropping\n      const sw = this.canvasWidth / scale;\n      const sh = this.canvasHeight / scale;\n      const sx = (this.imageWidth - sw) / 2;\n      const sy = (this.imageHeight - sh) / 2;\n      \n      // Pre-calculate all the division-heavy operations\n      this.transform = {\n        // canvasToImage coefficients\n        c2i_scaleX: sw / this.canvasWidth / this.imageWidth,\n        c2i_scaleY: sh / this.canvasHeight / this.imageHeight,\n        c2i_offsetX: sx / this.imageWidth,\n        c2i_offsetY: sy / this.imageHeight,\n        \n        // imageToCanvas coefficients\n        i2c_scaleX: this.canvasWidth / sw * this.imageWidth,\n        i2c_scaleY: this.canvasHeight / sh * this.imageHeight,\n        i2c_offsetX: -sx / sw * this.canvasWidth,\n        i2c_offsetY: -sy / sh * this.canvasHeight\n      };\n    }\n  }\n  \n  /**\n   * Convert canvas coordinates to normalized image coordinates (0-1)\n   * Simplified for 1:1 mapping when canvas matches image\n   * @param {number} canvasX - X coordinate on canvas\n   * @param {number} canvasY - Y coordinate on canvas\n   * @returns {{x: number, y: number}} Normalized image coordinates (0-1)\n   */\n  canvasToImage(canvasX, canvasY) {\n    // Check for 1:1 mapping scenario (canvas matches image)\n    if (this.canvasWidth === this.imageWidth && this.canvasHeight === this.imageHeight) {\n      // Direct 1:1 mapping - no transformation needed\n      return {\n        x: canvasX / this.canvasWidth,\n        y: canvasY / this.canvasHeight\n      };\n    }\n    if (!this.transform) {\n      // No image loaded, return normalized canvas coordinates\n      return {\n        x: this.canvasWidth > 0 ? canvasX / this.canvasWidth : 0,\n        y: this.canvasHeight > 0 ? canvasY / this.canvasHeight : 0\n      };\n    }\n    \n    // Use pre-calculated transformation matrix (2.5-4x faster)\n    const t = this.transform;\n    let x = canvasX * t.c2i_scaleX + t.c2i_offsetX;\n    let y = canvasY * t.c2i_scaleY + t.c2i_offsetY;\n    \n    // Fast clamp to 0-1 range (ternary faster than Math.max/min)\n    x = x < 0 ? 0 : (x > 1 ? 1 : x);\n    y = y < 0 ? 0 : (y > 1 ? 1 : y);\n    \n    return { x, y };\n  }\n  \n  /**\n   * Convert normalized image coordinates (0-1) to canvas coordinates\n   * Simplified for 1:1 mapping when canvas matches image\n   * @param {number} imageX - Normalized X coordinate (0-1)\n   * @param {number} imageY - Normalized Y coordinate (0-1)\n   * @returns {{x: number, y: number}} Canvas coordinates\n   */\n  imageToCanvas(imageX, imageY) {\n    // Check for 1:1 mapping scenario (canvas matches image)\n    if (this.canvasWidth === this.imageWidth && this.canvasHeight === this.imageHeight) {\n      // Direct 1:1 mapping - no transformation needed\n      return {\n        x: imageX * this.canvasWidth,\n        y: imageY * this.canvasHeight\n      };\n    }\n    if (!this.transform) {\n      // No image loaded, convert from normalized to canvas coordinates\n      return {\n        x: imageX * this.canvasWidth,\n        y: imageY * this.canvasHeight\n      };\n    }\n    \n    // Use pre-calculated transformation matrix (2.5-4.5x faster)\n    const t = this.transform;\n    return {\n      x: imageX * t.i2c_scaleX + t.i2c_offsetX,\n      y: imageY * t.i2c_scaleY + t.i2c_offsetY\n    };\n  }\n  \n  /**\n   * Check if a point is within the image bounds\n   * @param {number} canvasX - X coordinate on canvas\n   * @param {number} canvasY - Y coordinate on canvas\n   * @returns {boolean} True if point is within image bounds\n   */\n  isWithinImageBounds(canvasX, canvasY) {\n    if (!this.imageBounds) return false;\n    \n    const bounds = this.imageBounds;\n    return canvasX >= bounds.x && \n           canvasX <= bounds.x + bounds.w &&\n           canvasY >= bounds.y && \n           canvasY <= bounds.y + bounds.h;\n  }\n  \n  /**\n   * Get the current image bounds\n   * @returns {Object|null} Image bounds {x, y, w, h, scale} or null\n   */\n  getImageBounds() {\n    return this.imageBounds;\n  }\n  \n  /**\n   * Get display dimensions for the image\n   * @returns {Object} Display dimensions {width, height}\n   */\n  getDisplayDimensions() {\n    if (!this.imageBounds) {\n      return { width: this.canvasWidth, height: this.canvasHeight };\n    }\n    return { width: this.imageBounds.w, height: this.imageBounds.h };\n  }\n  \n  /**\n   * Reset all transformations\n   */\n  reset() {\n    this.canvasWidth = 0;\n    this.canvasHeight = 0;\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n    this.imageBounds = null;\n    this.transform = null;\n    this.fitMode = 'fit';\n  }\n}\n", "import { CatmullRom } from '../utils/CatmullRom.js';\nimport { Easing } from '../utils/Easing.js';\nimport { PATH, RENDERING } from '../config/constants.js';\n\n/**\n * Service for calculating paths through waypoints\n * Handles spline interpolation, reparameterization, and path shape generation\n * Optimized with curvature caching, binary search, and fast approximations\n */\nexport class PathCalculator {\n  constructor() {\n    this._majorWaypointsCache = new Map();\n    this._curvatureCache = new Map();\n    this._useFastCurvature = true; // Use fast approximation by default\n  }\n  \n  /**\n   * Calculate a smooth path through waypoints\n   * @param {Array} waypoints - Array of waypoint objects\n   * @param {Object} options - Path calculation options\n   * @returns {Array} Array of path points\n   */\n  calculatePath(waypoints, options = {}) {\n    if (waypoints.length < 2) {\n      return [];\n    }\n    \n    // Convert waypoints to coordinates for spline calculation\n    const coords = waypoints.map(wp => ({ \n      x: wp.x || wp.imgX, \n      y: wp.y || wp.imgY,\n      isMajor: wp.isMajor\n    }));\n    \n    // Generate initial path using Catmull-Rom splines\n    const roughPath = CatmullRom.createPath(\n      coords, \n      options.pointsPerSegment || PATH.POINTS_PER_SEGMENT,\n      options.tension || PATH.DEFAULT_TENSION\n    );\n    \n    // Apply corner-based velocity modulation for smoother animation\n    const evenPath = this.reparameterizeWithCornerSlowing(\n      roughPath, \n      options.targetSpacing || PATH.TARGET_SPACING\n    );\n    \n    // Apply path shapes and generate stable points\n    return this.applyPathShapes(evenPath, waypoints);\n  }\n  \n  /**\n   * Reparameterize path with corner slowing for smoother animation\n   * Uses curvature-based velocity modulation with binary search optimization\n   * @param {Array} rawPath - Original path points\n   * @param {number} targetSpacing - Target spacing between points\n   * @returns {Array} Reparameterized path\n   */\n  reparameterizeWithCornerSlowing(rawPath, targetSpacing = PATH.TARGET_SPACING) {\n    if (rawPath.length < 2) return rawPath;\n    \n    // Calculate curvature at each point (with caching)\n    const curvatures = this._getCachedCurvature(rawPath);\n    \n    // Build distance array with velocity modulation based on curvature\n    const distances = [0];\n    let totalDistance = 0;\n    \n    for (let i = 1; i < rawPath.length; i++) {\n      const dx = rawPath[i].x - rawPath[i-1].x;\n      const dy = rawPath[i].y - rawPath[i-1].y;\n      const physicalDist = Math.sqrt(dx * dx + dy * dy);\n      \n      // Calculate velocity factor based on curvature\n      const curvature = curvatures[i];\n      const velocityFactor = this._calculateVelocityFactor(curvature);\n      \n      // Adjust distance based on velocity (slower = more time = more \"distance\" in time-space)\n      const adjustedDist = physicalDist / velocityFactor;\n      totalDistance += adjustedDist;\n      distances.push(totalDistance);\n    }\n    \n    // Create evenly-spaced points in adjusted distance space using binary search\n    const evenPath = [];\n    const numPoints = Math.floor(totalDistance / targetSpacing);\n    \n    for (let i = 0; i <= numPoints; i++) {\n      const targetDist = (i / numPoints) * totalDistance;\n      \n      // Binary search for segment (optimized from linear search)\n      const segmentIdx = this._binarySearchSegment(distances, targetDist);\n      \n      // Interpolate within the segment\n      const segStart = distances[segmentIdx];\n      const segEnd = distances[segmentIdx + 1] || segStart;\n      const segLength = segEnd - segStart;\n      const t = segLength > 0 ? (targetDist - segStart) / segLength : 0;\n      \n      const p1 = rawPath[segmentIdx];\n      const p2 = rawPath[segmentIdx + 1] || p1;\n      \n      evenPath.push({\n        x: p1.x + (p2.x - p1.x) * t,\n        y: p1.y + (p2.y - p1.y) * t\n      });\n    }\n    \n    return evenPath;\n  }\n  \n  /**\n   * Calculate velocity factor based on curvature\n   * High curvature = slower, low curvature = faster\n   * @private\n   */\n  _calculateVelocityFactor(curvature) {\n    const maxCurvature = PATH.MAX_CURVATURE;\n    const minSpeed = PATH.MIN_CORNER_SPEED;\n    \n    // Apply quadratic easing for smoother corner slowing\n    const normalizedCurvature = Math.min(curvature / maxCurvature, 1);\n    const easedCurvature = Easing.quadIn(normalizedCurvature);\n    const velocityFactor = Math.max(minSpeed, 1 - easedCurvature * (1 - minSpeed));\n    \n    return velocityFactor;\n  }\n  \n  /**\n   * Binary search to find segment containing target distance\n   * Optimized from O(n) linear search to O(log n)\n   * @private\n   */\n  _binarySearchSegment(distances, targetDist) {\n    let left = 0;\n    let right = distances.length - 1;\n    \n    // Handle edge cases\n    if (targetDist <= distances[0]) return 0;\n    if (targetDist >= distances[right]) return right - 1;\n    \n    while (left < right - 1) {\n      const mid = Math.floor((left + right) / 2);\n      if (distances[mid] < targetDist) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    \n    return left;\n  }\n  \n  /**\n   * Apply path shapes (squiggle, randomised) to the path points\n   * @param {Array} evenPath - Evenly spaced path points\n   * @param {Array} waypoints - Original waypoints with shape information\n   * @returns {Array} Path with shapes applied\n   */\n  applyPathShapes(evenPath, waypoints) {\n    const finalPath = [];\n    \n    // Create stable seed for randomised paths\n    let pathSeed = 0;\n    waypoints.forEach(wp => {\n      pathSeed += (wp.imgX || wp.x || 0) * 1000 + (wp.imgY || wp.y || 0);\n    });\n    \n    // Process each point\n    for (let i = 0; i < evenPath.length; i++) {\n      const point = evenPath[i];\n      \n      // Find which segment this point belongs to\n      const totalSegments = waypoints.length - 1;\n      const segmentProgress = i / evenPath.length;\n      const segmentIndex = Math.min(\n        Math.floor(segmentProgress * totalSegments), \n        totalSegments - 1\n      );\n      \n      // Find the controlling waypoint\n      let controllerIdx = segmentIndex;\n      while (controllerIdx >= 0 && !waypoints[controllerIdx].isMajor) {\n        controllerIdx--;\n      }\n      \n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : null;\n      const pathShape = controller?.pathShape || 'line';\n      \n      // Apply shape transformations\n      if (pathShape === 'randomised') {\n        // Generate stable random offset\n        const pointSeed = pathSeed + i * 100;\n        const rng1 = Math.sin(pointSeed) * 10000;\n        const rng2 = Math.cos(pointSeed) * 10000;\n        const randX = (rng1 - Math.floor(rng1)) * 2 - 1;\n        const randY = (rng2 - Math.floor(rng2)) * 2 - 1;\n        \n        finalPath.push({\n          x: point.x + randX * RENDERING.RANDOMISED_JITTER,\n          y: point.y + randY * RENDERING.RANDOMISED_JITTER,\n          originalX: point.x,\n          originalY: point.y,\n          pathShape: pathShape\n        });\n      } else {\n        // For squiggle and line shapes, store shape info but don't transform yet\n        finalPath.push({\n          ...point,\n          pathShape: pathShape\n        });\n      }\n    }\n    \n    return finalPath;\n  }\n  \n  /**\n   * Find major waypoint positions along the path\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Array} Array of major waypoint positions\n   */\n  getMajorWaypointPositions(waypoints) {\n    // Use cache for performance\n    const cacheKey = this._getCacheKey(waypoints);\n    if (this._majorWaypointsCache.has(cacheKey)) {\n      return this._majorWaypointsCache.get(cacheKey);\n    }\n    \n    const majorWaypoints = [];\n    const totalWaypoints = waypoints.length;\n    \n    waypoints.forEach((wp, index) => {\n      if (wp.isMajor) {\n        const progress = totalWaypoints > 1 ? index / (totalWaypoints - 1) : 0;\n        majorWaypoints.push({\n          index: index,\n          progress: progress,\n          waypoint: wp\n        });\n      }\n    });\n    \n    this._majorWaypointsCache.set(cacheKey, majorWaypoints);\n    return majorWaypoints;\n  }\n  \n  /**\n   * Find which segment a given progress value falls into\n   * @param {number} progress - Progress value from 0 to 1\n   * @param {number} totalWaypoints - Total number of waypoints\n   * @returns {number} Segment index\n   */\n  findSegmentIndexForProgress(progress, totalWaypoints) {\n    if (totalWaypoints < 2) return -1;\n    \n    const segments = totalWaypoints - 1;\n    const rawIndex = progress * segments;\n    return Math.min(Math.floor(rawIndex), segments - 1);\n  }\n  \n  /**\n   * Calculate total path length\n   * @param {Array} pathPoints - Array of path points\n   * @returns {number} Total path length in pixels\n   */\n  calculatePathLength(pathPoints) {\n    if (!pathPoints || pathPoints.length === 0) {\n      return 0;\n    }\n    \n    let totalLength = 0;\n    \n    for (let i = 1; i < pathPoints.length; i++) {\n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      const dx = p2.x - p1.x;\n      const dy = p2.y - p1.y;\n      totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    return totalLength;\n  }\n  \n  /**\n   * Get interpolated position along path at given progress\n   * @param {Array} pathPoints - Array of path points\n   * @param {number} progress - Progress value from 0 to 1\n   * @returns {Object} Point with x and y coordinates\n   */\n  getPointAtProgress(pathPoints, progress) {\n    if (pathPoints.length === 0) return null;\n    if (progress <= 0) return pathPoints[0];\n    if (progress >= 1) return pathPoints[pathPoints.length - 1];\n    \n    const index = Math.floor(progress * (pathPoints.length - 1));\n    const localProgress = (progress * (pathPoints.length - 1)) - index;\n    \n    if (index >= pathPoints.length - 1) {\n      return pathPoints[pathPoints.length - 1];\n    }\n    \n    const p1 = pathPoints[index];\n    const p2 = pathPoints[index + 1];\n    \n    return {\n      x: p1.x + (p2.x - p1.x) * localProgress,\n      y: p1.y + (p2.y - p1.y) * localProgress\n    };\n  }\n  \n  /**\n   * Clear the cache\n   */\n  clearCache() {\n    this._majorWaypointsCache.clear();\n    this._curvatureCache.clear();\n  }\n  \n  /**\n   * Get cached curvature or calculate if not in cache\n   * @private\n   */\n  _getCachedCurvature(path) {\n    const pathKey = this._getPathHash(path);\n    \n    if (!this._curvatureCache.has(pathKey)) {\n      const curvatures = this._useFastCurvature\n        ? this._calculateCurvatureFast(path)\n        : this._calculateCurvatureAccurate(path);\n      this._curvatureCache.set(pathKey, curvatures);\n    }\n    \n    return this._curvatureCache.get(pathKey);\n  }\n  \n  /**\n   * Fast curvature approximation using triangle area method\n   * ~2.5x faster than accurate method with 95% similar results\n   * @private\n   */\n  _calculateCurvatureFast(path) {\n    const curvatures = [];\n    \n    for (let i = 0; i < path.length; i++) {\n      if (i === 0 || i === path.length - 1) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      const p0 = path[i - 1];\n      const p1 = path[i];\n      const p2 = path[i + 1];\n      \n      // Triangle area method (cross product)\n      const area = Math.abs(\n        (p1.x - p0.x) * (p2.y - p0.y) - \n        (p2.x - p0.x) * (p1.y - p0.y)\n      );\n      \n      // Calculate distances\n      const d1 = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n      const d2 = Math.hypot(p2.x - p1.x, p2.y - p1.y);\n      const avgDist = (d1 + d2) / 2;\n      \n      // Approximate curvature\n      curvatures.push(avgDist > 0 ? area / (avgDist * avgDist) : 0);\n    }\n    \n    return curvatures;\n  }\n  \n  /**\n   * Accurate curvature calculation using geometric method\n   * More precise but slower than fast approximation\n   * @private\n   */\n  _calculateCurvatureAccurate(path) {\n    const curvatures = [];\n    \n    for (let i = 0; i < path.length; i++) {\n      if (i === 0 || i === path.length - 1) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      const p0 = path[i - 1];\n      const p1 = path[i];\n      const p2 = path[i + 1];\n      \n      // Calculate vectors\n      const v1x = p1.x - p0.x;\n      const v1y = p1.y - p0.y;\n      const v2x = p2.x - p1.x;\n      const v2y = p2.y - p1.y;\n      \n      // Calculate lengths\n      const len1 = Math.sqrt(v1x * v1x + v1y * v1y);\n      const len2 = Math.sqrt(v2x * v2x + v2y * v2y);\n      \n      if (len1 === 0 || len2 === 0) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      // Normalize vectors\n      const n1x = v1x / len1;\n      const n1y = v1y / len1;\n      const n2x = v2x / len2;\n      const n2y = v2y / len2;\n      \n      // Calculate angle change\n      const crossProduct = n1x * n2y - n1y * n2x;\n      const dotProduct = n1x * n2x + n1y * n2y;\n      const angle = Math.atan2(crossProduct, dotProduct);\n      \n      // Curvature is angle change divided by average segment length\n      const avgLen = (len1 + len2) / 2;\n      const curvature = avgLen > 0 ? Math.abs(angle) / avgLen : 0;\n      \n      curvatures.push(curvature);\n    }\n    \n    return curvatures;\n  }\n  \n  /**\n   * Generate cache key for path\n   * @private\n   */\n  _getPathHash(path) {\n    // Use first, middle, and last points for hash (fast approximation)\n    const len = path.length;\n    if (len < 3) return `${path[0].x},${path[0].y}`;\n    \n    const first = path[0];\n    const mid = path[Math.floor(len / 2)];\n    const last = path[len - 1];\n    \n    return `${first.x},${first.y}|${mid.x},${mid.y}|${last.x},${last.y}|${len}`;\n  }\n  \n  /**\n   * Generate cache key for waypoints\n   * @private\n   */\n  _getCacheKey(waypoints) {\n    return waypoints.map(wp => `${wp.imgX},${wp.imgY},${wp.isMajor}`).join('|');\n  }\n}\n", "/**\n * PathCalculatorWithWorker - Enhanced path calculator using Web Workers\n * Falls back to main thread if workers are not available\n */\n\nimport { PathCalculator } from './PathCalculator.js';\n\nexport class PathCalculatorWithWorker extends PathCalculator {\n  constructor() {\n    super();\n    this.worker = null;\n    this.workerAvailable = false;\n    this.pendingRequests = new Map();\n    this.requestId = 0;\n    \n    this.initWorker();\n  }\n  \n  /**\n   * Initialize Web Worker if available\n   */\n  initWorker() {\n    if (typeof Worker !== 'undefined') {\n      try {\n        // Create worker with module type\n        this.worker = new Worker(\n          new URL('../workers/pathWorker.js', import.meta.url),\n          { type: 'module' }\n        );\n        \n        this.worker.onmessage = this.handleWorkerMessage.bind(this);\n        this.worker.onerror = this.handleWorkerError.bind(this);\n        \n        this.workerAvailable = true;\n        console.log('PathCalculator: Web Worker initialized');\n      } catch (error) {\n        console.warn('PathCalculator: Failed to initialize Web Worker, falling back to main thread', error);\n        this.workerAvailable = false;\n      }\n    } else {\n      console.log('PathCalculator: Web Workers not supported, using main thread');\n      this.workerAvailable = false;\n    }\n  }\n  \n  /**\n   * Handle messages from worker\n   */\n  handleWorkerMessage(event) {\n    const { type, data, id, error } = event.data;\n    \n    const request = this.pendingRequests.get(id);\n    if (!request) {\n      console.warn('PathCalculator: Received message for unknown request', id);\n      return;\n    }\n    \n    this.pendingRequests.delete(id);\n    \n    if (error) {\n      request.reject(new Error(error));\n    } else {\n      request.resolve(data.pathPoints);\n    }\n  }\n  \n  /**\n   * Handle worker errors\n   */\n  handleWorkerError(error) {\n    console.error('PathCalculator: Worker error', error);\n    \n    // Reject all pending requests\n    for (const request of this.pendingRequests.values()) {\n      request.reject(error);\n    }\n    this.pendingRequests.clear();\n    \n    // Disable worker and fall back to main thread\n    this.workerAvailable = false;\n    this.worker = null;\n  }\n  \n  /**\n   * Calculate path using worker if available\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Promise<Array>} Promise resolving to path points\n   */\n  async calculatePathAsync(waypoints) {\n    if (!this.workerAvailable) {\n      // Fall back to synchronous calculation on main thread\n      return Promise.resolve(this.calculatePath(waypoints));\n    }\n    \n    return new Promise((resolve, reject) => {\n      const id = this.requestId++;\n      \n      this.pendingRequests.set(id, { resolve, reject });\n      \n      // Send calculation request to worker\n      this.worker.postMessage({\n        type: 'calculate-path',\n        data: {\n          waypoints: waypoints.map(wp => ({\n            x: wp.x || wp.imgX,\n            y: wp.y || wp.imgY,\n            isMajor: wp.isMajor\n          }))\n        },\n        id: id\n      });\n      \n      // Timeout after 5 seconds\n      setTimeout(() => {\n        if (this.pendingRequests.has(id)) {\n          this.pendingRequests.delete(id);\n          reject(new Error('Path calculation timed out'));\n        }\n      }, 5000);\n    });\n  }\n  \n  /**\n   * Override the synchronous method to try async first\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Array} Path points\n   */\n  calculatePath(waypoints) {\n    // If worker is available and we're not in a rush, use it\n    if (this.workerAvailable && !this.isSynchronousContext()) {\n      console.warn('PathCalculator: Synchronous calculatePath called but worker is available. Consider using calculatePathAsync.');\n    }\n    \n    // Fall back to parent implementation\n    return super.calculatePath(waypoints);\n  }\n  \n  /**\n   * Check if we're in a context that requires synchronous execution\n   */\n  isSynchronousContext() {\n    // Check if we're in an animation frame or other time-critical context\n    // This is a heuristic - you might want to make this more sophisticated\n    return typeof requestAnimationFrame !== 'undefined' && \n           performance.now() % 16.67 < 1; // Roughly in an animation frame\n  }\n  \n  /**\n   * Clean up worker when done\n   */\n  destroy() {\n    if (this.worker) {\n      // Reject all pending requests\n      for (const request of this.pendingRequests.values()) {\n        request.reject(new Error('PathCalculator destroyed'));\n      }\n      this.pendingRequests.clear();\n      \n      // Terminate worker\n      this.worker.terminate();\n      this.worker = null;\n      this.workerAvailable = false;\n    }\n  }\n}\n", "import { ANIMATION } from '../config/constants.js';\n\n/**\n * Model for managing animation state\n * Encapsulates all animation-related properties and provides methods for state updates\n */\nexport class AnimationState {\n  constructor() {\n    this.reset();\n  }\n  \n  /**\n   * Reset animation to initial state\n   * Note: Preserves speed setting - only resets playback position\n   */\n  reset() {\n    // Preserve current speed if already set, otherwise use default\n    const preservedSpeed = this.speed || ANIMATION.DEFAULT_SPEED;\n    \n    console.log('\uD83D\uDD04 [AnimationState.reset()] BEFORE - speed:', this.speed, 'preservedSpeed:', preservedSpeed);\n    \n    this.isPlaying = false;\n    this.progress = 0;                    // 0 to 1\n    this.currentTime = 0;                 // in milliseconds\n    this.duration = ANIMATION.DEFAULT_DURATION;\n    this.mode = 'constant-speed';         // or 'constant-time'\n    this.speed = preservedSpeed;          // Preserve user's speed setting\n    this.playbackSpeed = ANIMATION.DEFAULT_PLAYBACK_SPEED;\n    \n    console.log('\u2705 [AnimationState.reset()] AFTER - speed:', this.speed, 'duration:', this.duration);\n    \n    // Pause states\n    this.isPaused = false;                // User-triggered pause\n    this.isWaitingAtWaypoint = false;     // Waypoint wait state\n    this.pauseWaypointIndex = -1;         // Current waypoint index\n    this.pauseStartTime = 0;              // When wait began\n    this.pauseEndTime = 0;                // When wait should end\n    this.waypointProgressSnapshot = 0;    // Progress frozen during wait\n    \n    // Timing\n    this.lastTime = 0;\n  }\n  \n  /**\n   * Start animation playback\n   */\n  play() {\n    this.isPlaying = true;\n    this.isPaused = false;\n    this.lastTime = performance.now();\n  }\n  \n  /**\n   * Pause animation playback\n   */\n  pause() {\n    this.isPaused = true;\n  }\n  \n  /**\n   * Stop animation and reset\n   */\n  stop() {\n    this.isPlaying = false;\n    this.isPaused = false;\n    this.progress = 0;\n    this.currentTime = 0;\n  }\n  \n  /**\n   * Toggle between play and pause\n   */\n  togglePlayPause() {\n    if (this.isPlaying && !this.isPaused) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  \n  /**\n   * Set animation progress directly\n   * @param {number} progress - Progress value from 0 to 1\n   */\n  setProgress(progress) {\n    this.progress = Math.max(0, Math.min(1, progress));\n    this.currentTime = this.progress * this.duration;\n  }\n  \n  /**\n   * Set animation time directly\n   * @param {number} time - Time in milliseconds\n   */\n  setTime(time) {\n    this.currentTime = Math.max(0, Math.min(this.duration, time));\n    this.progress = this.duration > 0 ? this.currentTime / this.duration : 0;\n  }\n  \n  /**\n   * Update animation mode\n   * @param {string} mode - 'constant-speed' or 'constant-time'\n   */\n  setMode(mode) {\n    if (mode === 'constant-speed' || mode === 'constant-time') {\n      this.mode = mode;\n    } else {\n      throw new Error(`Invalid animation mode: ${mode}`);\n    }\n  }\n  \n  /**\n   * Start waiting at a waypoint\n   * @param {number} waypointIndex - Index of the waypoint\n   * @param {number} waitDuration - Duration to wait in milliseconds\n   * @param {number} progressSnapshot - Progress value to freeze at\n   */\n  startWaypointWait(waypointIndex, waitDuration, progressSnapshot) {\n    this.isWaitingAtWaypoint = true;\n    this.pauseWaypointIndex = waypointIndex;\n    this.pauseStartTime = performance.now();\n    this.pauseEndTime = this.pauseStartTime + waitDuration;\n    this.waypointProgressSnapshot = progressSnapshot;\n  }\n  \n  /**\n   * End waypoint wait\n   */\n  endWaypointWait() {\n    this.isWaitingAtWaypoint = false;\n    this.pauseWaypointIndex = -1;\n    this.waypointProgressSnapshot = 0;\n  }\n  \n  /**\n   * Check if currently waiting at a waypoint\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.isWaitingAtWaypoint;\n  }\n  \n  /**\n   * Get effective progress (considering waypoint waits)\n   * @returns {number} Progress value from 0 to 1\n   */\n  getEffectiveProgress() {\n    return this.isWaitingAtWaypoint ? this.waypointProgressSnapshot : this.progress;\n  }\n  \n  /**\n   * Clone current state\n   * @returns {Object} Plain object with current state\n   */\n  toJSON() {\n    return {\n      isPlaying: this.isPlaying,\n      progress: this.progress,\n      currentTime: this.currentTime,\n      duration: this.duration,\n      mode: this.mode,\n      speed: this.speed,\n      playbackSpeed: this.playbackSpeed,\n      isPaused: this.isPaused,\n      isWaitingAtWaypoint: this.isWaitingAtWaypoint,\n      pauseWaypointIndex: this.pauseWaypointIndex\n    };\n  }\n  \n  /**\n   * Restore state from JSON\n   * @param {Object} data - State data to restore\n   */\n  fromJSON(data) {\n    Object.assign(this, data);\n  }\n}\n", "import { ANIMATION } from '../config/constants.js';\nimport { AnimationState } from '../models/AnimationState.js';\n\n/**\n * Service for managing animation playback\n * Handles timing, waypoint waits, and frame rate control\n */\nexport class AnimationEngine {\n  constructor(eventBus = null) {\n    this.eventBus = eventBus;\n    this.state = new AnimationState();\n    this.animationFrameId = null;\n    this.lastFrameTime = 0;\n    this.onUpdate = null; // Callback for animation updates\n  }\n  \n  /**\n   * Start the animation loop\n   * @param {Function} onUpdate - Callback function called on each frame\n   */\n  start(onUpdate) {\n    if (this.animationFrameId) {\n      this.stop();\n    }\n    \n    this.onUpdate = onUpdate;\n    this.state.play();\n    this.lastFrameTime = 0;\n    \n    const loop = (timestamp) => {\n      this.animationFrameId = requestAnimationFrame(loop);\n      \n      // Calculate time since last frame\n      const elapsed = timestamp - this.lastFrameTime;\n      \n      // Only update at target frame rate\n      if (elapsed > ANIMATION.FRAME_INTERVAL) {\n        // Adjust for frame interval to prevent lag accumulation\n        this.lastFrameTime = timestamp - (elapsed % ANIMATION.FRAME_INTERVAL);\n        \n        if (this.state.isPlaying && !this.state.isPaused) {\n          // Cap deltaTime to prevent huge jumps\n          const deltaTime = Math.min(elapsed, ANIMATION.MAX_DELTA_TIME) * this.state.playbackSpeed;\n          \n          // Update animation state\n          this.updateAnimation(deltaTime, timestamp);\n        }\n        \n        // Call update callback\n        if (this.onUpdate) {\n          this.onUpdate(this.state);\n        }\n        \n        // Emit update event\n        this.emit('update', this.state);\n      }\n    };\n    \n    requestAnimationFrame(loop);\n  }\n  \n  /**\n   * Update animation state\n   * @private\n   * @param {number} deltaTime - Time since last update in milliseconds\n   * @param {number} timestamp - Current timestamp\n   */\n  updateAnimation(deltaTime, timestamp) {\n    // Handle waypoint waiting\n    if (this.state.isWaitingAtWaypoint) {\n      if (timestamp >= this.state.pauseEndTime) {\n        this.state.endWaypointWait();\n        this.emit('waypointWaitEnd', this.state.pauseWaypointIndex);\n      } else {\n        // Don't advance time while waiting\n        return;\n      }\n    }\n    \n    // Advance animation time\n    this.state.currentTime += deltaTime;\n    \n    // Check for animation end\n    if (this.state.currentTime >= this.state.duration) {\n      this.state.currentTime = this.state.duration;\n      this.state.progress = 1;\n      this.pause();\n      this.emit('complete');\n    } else {\n      // Update progress\n      this.state.progress = this.state.currentTime / this.state.duration;\n      \n      // Check for waypoint waits\n      if (this.waypointCheckCallback) {\n        this.waypointCheckCallback(this.state.progress);\n      }\n    }\n  }\n  \n  /**\n   * Pause the animation\n   */\n  pause() {\n    this.state.pause();\n    this.emit('pause');\n  }\n  \n  /**\n   * Resume the animation\n   */\n  play() {\n    this.state.play();\n    this.emit('play');\n  }\n  \n  /**\n   * Toggle play/pause\n   */\n  togglePlayPause() {\n    if (this.state.isPlaying && !this.state.isPaused) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  \n  /**\n   * Stop the animation completely\n   */\n  stop() {\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n    this.state.stop();\n    this.emit('stop');\n  }\n  \n  /**\n   * Reset animation to beginning\n   */\n  reset() {\n    this.state.reset();\n    this.emit('reset');\n  }\n  \n  /**\n   * Seek to specific time\n   * @param {number} time - Time in milliseconds\n   */\n  seekToTime(time) {\n    this.state.setTime(time);\n    this.emit('seek', time);\n  }\n  \n  /**\n   * Seek to specific progress\n   * @param {number} progress - Progress from 0 to 1\n   */\n  seekToProgress(progress) {\n    this.state.setProgress(progress);\n    this.emit('seek', progress * this.state.duration);\n  }\n  \n  /**\n   * Set animation duration\n   * @param {number} duration - Duration in milliseconds\n   */\n  setDuration(duration) {\n    const currentProgress = this.state.progress;\n    console.log('\u23F1\uFE0F  [AnimationEngine.setDuration()] duration:', duration, 'ms (', (duration/1000).toFixed(1), 's), progress:', currentProgress);\n    this.state.duration = duration;\n    this.state.setProgress(currentProgress); // Maintain progress\n    this.emit('durationChange', duration);\n  }\n  \n  /**\n   * Set animation speed in pixels per second (for constant-speed mode)\n   * Rounds to nearest step value (5) to match slider constraints\n   * @param {number} speed - Speed in pixels per second\n   */\n  setSpeed(speed) {\n    // Round to nearest step value (5) to match slider\n    const step = 5;\n    const roundedSpeed = Math.round(speed / step) * step;\n    console.log('\uD83C\uDFC3 [AnimationEngine.setSpeed()] speed:', roundedSpeed, 'px/s (was:', this.state.speed, ', raw:', speed, ')');\n    this.state.speed = roundedSpeed;\n    this.emit('speedChange', roundedSpeed);\n  }\n  \n  /**\n   * Set playback speed multiplier\n   * @param {number} speed - Playback speed (1 = normal, 2 = double speed)\n   */\n  setPlaybackSpeed(speed) {\n    this.state.playbackSpeed = Math.max(0.1, Math.min(10, speed));\n    this.emit('playbackSpeedChange', this.state.playbackSpeed);\n  }\n  \n  /**\n   * Set animation mode\n   * @param {string} mode - 'constant-speed' or 'constant-time'\n   */\n  setMode(mode) {\n    this.state.setMode(mode);\n    this.emit('modeChange', mode);\n  }\n  \n  /**\n   * Start waiting at a waypoint\n   * @param {number} waypointIndex - Index of the waypoint\n   * @param {number} waitDuration - Duration to wait in milliseconds\n   */\n  startWaypointWait(waypointIndex, waitDuration) {\n    const progressSnapshot = this.state.progress;\n    this.state.startWaypointWait(waypointIndex, waitDuration, progressSnapshot);\n    this.emit('waypointWaitStart', { index: waypointIndex, duration: waitDuration });\n  }\n  \n  /**\n   * Set callback for checking waypoint waits\n   * @param {Function} callback - Function to check for waypoint waits\n   */\n  setWaypointCheckCallback(callback) {\n    this.waypointCheckCallback = callback;\n  }\n  \n  /**\n   * Check if animation is playing\n   * @returns {boolean}\n   */\n  isPlaying() {\n    return this.state.isPlaying && !this.state.isPaused;\n  }\n  \n  /**\n   * Check if animation is complete\n   * @returns {boolean}\n   */\n  isComplete() {\n    return this.state.progress >= 1;\n  }\n  \n  /**\n   * Get current state\n   * @returns {AnimationState}\n   */\n  getState() {\n    return this.state;\n  }\n  \n  /**\n   * Get current progress\n   * @returns {number} Progress from 0 to 1\n   */\n  getProgress() {\n    return this.state.getEffectiveProgress();\n  }\n  \n  /**\n   * Get current time\n   * @returns {number} Time in milliseconds\n   */\n  getTime() {\n    return this.state.currentTime;\n  }\n  \n  /**\n   * Calculate duration based on path length and speed\n   * @param {number} pathLength - Total path length in pixels\n   * @returns {number} Duration in milliseconds\n   */\n  calculateDurationFromSpeed(pathLength) {\n    if (this.state.mode === 'constant-speed' && this.state.speed > 0) {\n      return (pathLength / this.state.speed) * 1000;\n    }\n    return this.state.duration;\n  }\n  \n  /**\n   * Emit event through event bus\n   * @private\n   */\n  emit(eventName, data) {\n    if (this.eventBus) {\n      this.eventBus.emit(`animation:${eventName}`, data);\n    }\n  }\n  \n  /**\n   * Destroy the animation engine\n   */\n  destroy() {\n    this.stop();\n    this.onUpdate = null;\n    this.waypointCheckCallback = null;\n    this.eventBus = null;\n  }\n}\n", "/**\n * RenderingService - Handles all canvas rendering operations\n * Extracted from main.js for better modularity\n */\n\nimport { RENDERING, INTERACTION } from '../config/constants.js';\nimport { Easing } from '../utils/Easing.js';\n\nexport class RenderingService {\n  constructor() {\n    this.vectorCanvas = null;\n    this.waypointPositions = [];\n  }\n\n  /**\n   * Main render method - orchestrates all rendering layers\n   */\n  render(ctx, displayWidth, displayHeight, state) {\n    const cw = displayWidth || ctx.canvas.width;\n    const ch = displayHeight || ctx.canvas.height;\n    \n    // Safety check - ensure canvas has valid dimensions\n    if (cw <= 0 || ch <= 0) {\n      console.warn('Cannot render to canvas with invalid dimensions:', { width: cw, height: ch });\n      return; // Skip rendering\n    }\n    \n    // Clear\n    ctx.clearRect(0, 0, cw, ch);\n    \n    // 1) Base image\n    this.renderBackground(ctx, state.background, cw, ch);\n    \n    // 2) Contrast overlay\n    this.renderOverlay(ctx, state.background.overlay, cw, ch);\n    \n    // 3-6) Vector + head + UI handles on offscreen canvas\n    const vCanvas = this.getVectorCanvas(displayWidth, displayHeight);\n    \n    // Safety check for vector canvas\n    if (vCanvas.width <= 0 || vCanvas.height <= 0) {\n      console.warn('Vector canvas has invalid dimensions:', { width: vCanvas.width, height: vCanvas.height });\n      return; // Skip drawing vector layer\n    }\n    \n    const vctx = vCanvas.getContext('2d');\n    vctx.clearRect(0, 0, vCanvas.width, vCanvas.height);\n    this.renderVectorLayerTo(vctx, state);\n    \n    // Safety check before drawing vector layer\n    if (vCanvas.width > 0 && vCanvas.height > 0) {\n      // Blit vector layer to main\n      ctx.drawImage(vCanvas, 0, 0);\n    }\n  }\n\n  /**\n   * Get or create offscreen canvas for vector layer\n   */\n  getVectorCanvas(displayWidth, displayHeight) {\n    if (!this.vectorCanvas) {\n      this.vectorCanvas = document.createElement('canvas');\n    }\n    \n    // Get canvas dimensions with safety checks\n    const cw = displayWidth || 100; // Fallback to minimum size\n    const ch = displayHeight || 100;\n    \n    // Ensure we have valid dimensions > 0\n    const safeWidth = Math.max(1, cw);\n    const safeHeight = Math.max(1, ch);\n    \n    // Only update if dimensions changed\n    if (this.vectorCanvas.width !== safeWidth || this.vectorCanvas.height !== safeHeight) {\n      console.log('Resizing vector canvas to:', safeWidth, 'x', safeHeight);\n      this.vectorCanvas.width = safeWidth;\n      this.vectorCanvas.height = safeHeight;\n      \n      // Disable smoothing on vector canvas too\n      const vctx = this.vectorCanvas.getContext('2d');\n      if (vctx) {\n        vctx.imageSmoothingEnabled = false;\n      }\n    }\n    \n    return this.vectorCanvas;\n  }\n  \n  /**\n   * Render background image with fit/fill mode\n   */\n  renderBackground(ctx, background, canvasWidth, canvasHeight) {\n    if (!background.image) return;\n    \n    const img = background.image;\n    const iw = img.naturalWidth || img.width;\n    const ih = img.naturalHeight || img.height;\n    const cw = canvasWidth;\n    const ch = canvasHeight;\n    \n    if (background.fit === 'fit') {\n      // Fit: scale image to fit entirely within canvas (may have letterboxing)\n      const scale = Math.min(cw / iw, ch / ih);\n      const dw = Math.round(iw * scale);\n      const dh = Math.round(ih * scale);\n      const dx = Math.floor((cw - dw) / 2);\n      const dy = Math.floor((ch - dh) / 2);\n      // Draw entire source image scaled to fit\n      ctx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);\n    } else {\n      // Fill: enlarge so smaller dimension fills the canvas, center and crop\n      const scale = Math.max(cw / iw, ch / ih);\n      // Calculate which portion of source to show\n      const sw = cw / scale;  // source width to show\n      const sh = ch / scale;  // source height to show\n      const sx = (iw - sw) / 2;  // center horizontally\n      const sy = (ih - sh) / 2;  // center vertically\n      // Draw cropped portion of source image to fill entire canvas\n      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);\n    }\n  }\n  \n  /**\n   * Render overlay for contrast adjustment\n   */\n  renderOverlay(ctx, overlayValue, canvasWidth, canvasHeight) {\n    if (overlayValue === 0) return;\n    \n    ctx.save();\n    ctx.globalAlpha = Math.min(Math.abs(overlayValue) / 100, 0.6);\n    ctx.fillStyle = overlayValue < 0 ? '#000' : '#fff';\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.restore();\n  }\n\n  /**\n   * Render complete vector layer (paths, waypoints, labels)\n   */\n  renderVectorLayerTo(ctx, state) {\n    const { waypoints, pathPoints, styles, animationEngine, selectedWaypoint, imageToCanvas, displayWidth, displayHeight } = state;\n    \n    // Render path if we have points\n    if (pathPoints.length > 0 && waypoints.length > 1) {\n      this.renderPath(ctx, pathPoints, waypoints, styles, animationEngine);\n      this.renderPathHead(ctx, pathPoints, styles, animationEngine);\n    }\n    \n    // Render beacons\n    this.renderBeacons(ctx, waypoints, animationEngine, state.beaconAnimation, imageToCanvas, styles);\n    \n    // Render waypoint markers\n    this.renderWaypoints(ctx, waypoints, selectedWaypoint, styles, imageToCanvas, displayWidth, displayHeight);\n  }\n  \n  /**\n   * Render the animated path\n   */\n  renderPath(ctx, pathPoints, waypoints, styles, animationEngine) {\n    const totalPoints = pathPoints.length;\n    const progress = animationEngine.getProgress();\n    const exactPosition = totalPoints * progress;\n    const pointsToRender = Math.floor(exactPosition);\n    const fraction = exactPosition - pointsToRender; // Fractional part for partial segment\n    const segments = waypoints.length - 1;\n    const pointsPerSegment = Math.floor(totalPoints / segments);\n    const controllerForSegment = new Array(segments);\n    \n    // Store exact waypoint positions in path points for later use in labels\n    this.waypointPositions = [];\n    waypoints.forEach((wp, index) => {\n      if (index < waypoints.length - 1) {\n        const exactPointIndex = (index / segments) * totalPoints;\n        this.waypointPositions.push({\n          waypointIndex: index,\n          pointIndex: exactPointIndex\n        });\n      }\n    });\n    \n    let lastMajorIdx = -1;\n    for (let s = 0; s < segments; s++) {\n      if (waypoints[s].isMajor) lastMajorIdx = s;\n      controllerForSegment[s] = lastMajorIdx;\n    }\n    \n    for (let i = 1; i < pointsToRender; i++) {\n      const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n      const controllerIdx = controllerForSegment[segmentIndex];\n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : {\n        segmentColor: styles.pathColor,\n        segmentWidth: styles.pathThickness,\n        segmentStyle: 'solid',\n        pathShape: 'line'\n      };\n      \n      ctx.strokeStyle = controller.segmentColor;\n      ctx.lineWidth = controller.segmentWidth;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      this.applyLineStyle(ctx, controller.segmentStyle);\n      ctx.beginPath();\n      \n      const pathShape = controller.pathShape || 'line';\n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      \n      if (pathShape === 'squiggle') {\n        // Create a wavy path using control points\n        const midX = (p1.x + p2.x) / 2;\n        const midY = (p1.y + p2.y) / 2;\n        const perpX = -(p2.y - p1.y) * 0.15; // Perpendicular offset\n        const perpY = (p2.x - p1.x) * 0.15;\n        \n        ctx.moveTo(p1.x, p1.y);\n        const wave = Math.sin(i * 0.5) * 0.5;\n        ctx.quadraticCurveTo(\n          midX + perpX * wave, \n          midY + perpY * wave,\n          p2.x, p2.y\n        );\n      } else if (pathShape === 'randomised') {\n        // Add random jitter to the path\n        const jitterAmount = 3;\n        const jitteredP1 = {\n          x: p1.x + (Math.random() - 0.5) * jitterAmount,\n          y: p1.y + (Math.random() - 0.5) * jitterAmount\n        };\n        const jitteredP2 = {\n          x: p2.x + (Math.random() - 0.5) * jitterAmount,\n          y: p2.y + (Math.random() - 0.5) * jitterAmount\n        };\n        ctx.moveTo(jitteredP1.x, jitteredP1.y);\n        ctx.lineTo(jitteredP2.x, jitteredP2.y);\n      } else {\n        // Default line\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(p2.x, p2.y);\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Draw partial final segment for smooth animation (sub-pixel interpolation)\n    // Use tiny threshold (0.001%) to avoid degenerate cases while maintaining perfect smoothness\n    if (pointsToRender > 0 && pointsToRender < totalPoints && fraction > 0.00001) {\n      if (Math.random() < 0.01) { // Log 1% of the time to avoid spam\n        console.log('[RenderPath] Drawing partial segment - fraction:', fraction.toFixed(5), 'at point:', pointsToRender);\n      }\n      const i = pointsToRender;\n      const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n      const controllerIdx = controllerForSegment[segmentIndex];\n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : {\n        segmentColor: styles.pathColor,\n        segmentWidth: styles.pathThickness,\n        segmentStyle: 'solid',\n        pathShape: 'line'\n      };\n      \n      ctx.strokeStyle = controller.segmentColor;\n      ctx.lineWidth = controller.segmentWidth;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      this.applyLineStyle(ctx, controller.segmentStyle);\n      ctx.beginPath();\n      \n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      \n      // Interpolate end point for smooth partial segment\n      const partialEnd = {\n        x: p1.x + (p2.x - p1.x) * fraction,\n        y: p1.y + (p2.y - p1.y) * fraction\n      };\n      \n      const pathShape = controller.pathShape || 'line';\n      \n      if (pathShape === 'squiggle') {\n        const midX = (p1.x + partialEnd.x) / 2;\n        const midY = (p1.y + partialEnd.y) / 2;\n        const perpX = -(partialEnd.y - p1.y) * 0.15;\n        const perpY = (partialEnd.x - p1.x) * 0.15;\n        \n        ctx.moveTo(p1.x, p1.y);\n        const wave = Math.sin(i * 0.5) * 0.5;\n        ctx.quadraticCurveTo(\n          midX + perpX * wave,\n          midY + perpY * wave,\n          partialEnd.x, partialEnd.y\n        );\n      } else if (pathShape === 'randomised') {\n        // For randomised, use simple line to avoid flickering\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(partialEnd.x, partialEnd.y);\n      } else {\n        // Default line with interpolated end point\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(partialEnd.x, partialEnd.y);\n      }\n      \n      ctx.stroke();\n    }\n    \n    ctx.setLineDash([]);\n  }\n  \n  /**\n   * Render the path head (animated marker)\n   */\n  renderPathHead(ctx, pathPoints, styles, animationEngine) {\n    const progress = animationEngine.getProgress();\n    const totalPoints = pathPoints.length;\n    const exactPosition = totalPoints * progress;\n    const pointsToRender = Math.floor(exactPosition);\n    \n    if (pointsToRender > 1 && pointsToRender < totalPoints) {\n      // Interpolate between current and next point for smooth movement\n      const currentIndex = Math.min(pointsToRender - 1, pathPoints.length - 2);\n      const nextIndex = currentIndex + 1;\n      const fraction = exactPosition - pointsToRender; // Fractional part (0-1)\n      \n      const currentPoint = pathPoints[currentIndex];\n      const nextPoint = pathPoints[nextIndex];\n      \n      // Linear interpolation between points for smooth sub-pixel movement\n      const head = {\n        x: currentPoint.x + (nextPoint.x - currentPoint.x) * fraction,\n        y: currentPoint.y + (nextPoint.y - currentPoint.y) * fraction\n      };\n      \n      // Calculate direction for rotation (use interpolated position)\n      let rotation = 0;\n      if (currentIndex > 0) {\n        const prevPoint = pathPoints[currentIndex - 1];\n        rotation = Math.atan2(nextPoint.y - prevPoint.y, nextPoint.x - prevPoint.x);\n      }\n      \n      // Store calculated rotation\n      styles.pathHead.rotation = rotation;\n      \n      // Draw path head based on style with interpolated position\n      this.drawPathHead(ctx, head.x, head.y, rotation, styles.pathHead);\n    } else if (pointsToRender >= totalPoints && totalPoints > 0) {\n      // At end of animation, use final point\n      const head = pathPoints[totalPoints - 1];\n      const prevPoint = totalPoints > 1 ? pathPoints[totalPoints - 2] : head;\n      const rotation = Math.atan2(head.y - prevPoint.y, head.x - prevPoint.x);\n      styles.pathHead.rotation = rotation;\n      this.drawPathHead(ctx, head.x, head.y, rotation, styles.pathHead);\n    }\n  }\n  \n  /**\n   * Draw the path head based on current style settings\n   */\n  drawPathHead(ctx, x, y, rotation, pathHead) {\n    // Safety check for valid coordinates\n    if (!isFinite(x) || !isFinite(y)) {\n      console.warn('Invalid path head coordinates:', {x, y});\n      return;\n    }\n    \n    const size = pathHead.size;\n    \n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    \n    switch (pathHead.style) {\n      case 'dot':\n        // Simple dot (filled circle)\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        ctx.fill();\n        break;\n        \n      case 'arrow':\n        // Arrow shape\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        \n        // Draw arrow pointing right (rotation will handle direction)\n        ctx.moveTo(size, 0);            // Tip\n        ctx.lineTo(-size/2, size/2);    // Bottom corner\n        ctx.lineTo(-size/4, 0);         // Indentation\n        ctx.lineTo(-size/2, -size/2);   // Top corner\n        ctx.closePath();\n        ctx.fill();\n        break;\n        \n      case 'custom':\n        // Custom image\n        if (pathHead.image) {\n          const imgSize = size * 2; // Make image slightly larger for better visibility\n          // Draw the image centered and rotated\n          ctx.drawImage(\n            pathHead.image, \n            -imgSize/2, -imgSize/2,\n            imgSize, imgSize\n          );\n        } else {\n          // Fallback to dot if no image loaded\n          ctx.beginPath();\n          ctx.fillStyle = pathHead.color;\n          ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n          ctx.fill();\n        }\n        break;\n        \n      default:\n        // Default to dot\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        ctx.fill();\n    }\n    \n    ctx.restore();\n  }\n  \n  /**\n   * Render beacon effects at waypoints\n   */\n  renderBeacons(ctx, waypoints, animationEngine, beaconAnimation, imageToCanvas, styles) {\n    if (!waypoints.length) return;\n    \n    const currentProgress = animationEngine.getProgress();\n    \n    waypoints.forEach((waypoint, wpIndex) => {\n      if (waypoint.isMajor) {\n        // Calculate normalized progress for this waypoint\n        const exactWaypointProgress = wpIndex / (waypoints.length - 1);\n        \n        // Show beacon EXACTLY when we reach a waypoint (not after)\n        // Use a small threshold to ensure reliable triggering\n        const atWaypoint = Math.abs(currentProgress - exactWaypointProgress) < 0.001;\n        \n        // Show beacon exactly when paused at this waypoint\n        const isPausedHere = animationEngine.state.isPaused && \n                            animationEngine.state.pauseWaypointIndex === wpIndex;\n        \n        // Show beacon when either exactly at waypoint or paused at it\n        if (atWaypoint || isPausedHere) {\n          // Convert waypoint to canvas coords for drawing beacon\n          const wpCanvas = imageToCanvas(waypoint.imgX, waypoint.imgY);\n          this.drawBeacon(ctx, { ...waypoint, x: wpCanvas.x, y: wpCanvas.y }, beaconAnimation, styles);\n        }\n      }\n    });\n  }\n  \n  /**\n   * Draw beacon effect\n   */\n  drawBeacon(ctx, point, beaconAnimation, styles) {\n    const bStyle = point.beaconStyle || 'none';\n    const bColor = point.beaconColor || styles.beaconColor;\n    if (bStyle === 'none') return;\n    \n    // Safety check for valid coordinates\n    if (!isFinite(point.x) || !isFinite(point.y)) {\n      console.warn('Invalid beacon coordinates:', point);\n      return;\n    }\n    \n    if (bStyle === 'pulse') {\n      // Update pulse phase\n      beaconAnimation.pulsePhase = performance.now() * 0.003;\n      \n      // Pulsing dot\n      const pulse = 1 + Math.sin(beaconAnimation.pulsePhase) * 0.3;\n      const pulseSize = RENDERING.BEACON_PULSE_SIZE * pulse;\n      \n      // Outer glow\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);\n      ctx.fillStyle = bColor;\n      ctx.globalAlpha = RENDERING.BEACON_PULSE_OPACITY;\n      ctx.fill();\n      \n      // Update pulse animation state\n      beaconAnimation.pulsePhase = (beaconAnimation.pulsePhase + 0.1) % (Math.PI * 2);\n    } \n    else if (bStyle === 'ripple') {\n      // Ripple effect - expanding circles that fade out\n      const now = Date.now();\n      \n      // Add a new ripple every interval\n      if (!point.lastRipple || now - point.lastRipple > RENDERING.BEACON_RIPPLE_INTERVAL) {\n        beaconAnimation.ripples.push({\n          x: point.x, \n          y: point.y, \n          radius: 0,\n          opacity: 0.5,\n          startTime: now,\n          color: bColor\n        });\n        point.lastRipple = now;\n      }\n      \n      // Draw all active ripples\n      beaconAnimation.ripples = beaconAnimation.ripples.filter(ripple => {\n        const age = now - ripple.startTime;\n        if (age > RENDERING.BEACON_RIPPLE_DURATION) return false; // Remove old ripples\n        \n        // Calculate current radius with smooth fade-out\n        const radius = age / RENDERING.BEACON_RIPPLE_SPEED;\n        const fadeProgress = age / RENDERING.BEACON_RIPPLE_DURATION;\n        const opacity = 0.5 * (1 - Easing.cubicOut(fadeProgress));\n        \n        // Draw ripple\n        ctx.beginPath();\n        ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);\n        ctx.strokeStyle = ripple.color;\n        ctx.lineWidth = 2;\n        ctx.globalAlpha = opacity;\n        ctx.stroke();\n        \n        return true;\n      });\n      \n      // Draw center dot\n      ctx.beginPath();\n      ctx.fillStyle = bColor;\n      ctx.globalAlpha = 0.8;\n      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset global alpha to prevent affecting subsequent draws\n    ctx.globalAlpha = 1.0;\n  }\n  \n  /**\n   * Render waypoint markers\n   */\n  renderWaypoints(ctx, waypoints, selectedWaypoint, styles, imageToCanvas, displayWidth, displayHeight) {\n    waypoints.forEach(waypoint => {\n      if (waypoint.isMajor) {\n        // Convert waypoint from image coords to canvas coords\n        const wpCanvas = imageToCanvas(waypoint.imgX, waypoint.imgY);\n        const isSelected = waypoint === selectedWaypoint;\n        const markerSize = waypoint.dotSize || styles.dotSize;\n        const size = isSelected ? markerSize * 1.3 : markerSize;\n        const markerStyle = waypoint.markerStyle || styles.markerStyle;\n        \n        // Skip rendering if marker style is 'none'\n        if (markerStyle === 'none') {\n          this.renderLabel(ctx, waypoint, wpCanvas.x, wpCanvas.y, 0, waypoints, styles.animationEngine, displayWidth, displayHeight);\n          return;\n        }\n        \n        ctx.fillStyle = waypoint.dotColor || waypoint.segmentColor || styles.dotColor;\n        ctx.strokeStyle = isSelected ? '#4a90e2' : 'white';\n        ctx.lineWidth = isSelected ? 3 : 2;\n        \n        // Draw different marker types\n        if (markerStyle === 'square') {\n          // Square marker\n          ctx.beginPath();\n          ctx.rect(wpCanvas.x - size, wpCanvas.y - size, size * 2, size * 2);\n          ctx.fill();\n          ctx.stroke();\n        } else if (markerStyle === 'flag') {\n          // Flag marker\n          ctx.beginPath();\n          // Pole\n          ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          ctx.lineTo(wpCanvas.x, wpCanvas.y + size);\n          // Flag\n          ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          ctx.lineTo(wpCanvas.x + size * 1.5, wpCanvas.y - size * 1.3);\n          ctx.lineTo(wpCanvas.x + size * 1.2, wpCanvas.y - size);\n          ctx.lineTo(wpCanvas.x, wpCanvas.y - size * 0.7);\n          ctx.closePath();\n          ctx.fill();\n          ctx.stroke();\n        } else {\n          // Default to dot\n          ctx.beginPath();\n          ctx.arc(wpCanvas.x, wpCanvas.y, size, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n        }\n        \n        // Draw labels for major waypoints\n        this.renderLabel(ctx, waypoint, wpCanvas.x, wpCanvas.y, size, waypoints, styles.animationEngine, displayWidth, displayHeight);\n      }\n    });\n  }\n  \n  /**\n   * Render waypoint labels\n   */\n  renderLabel(ctx, waypoint, x, y, dotSize, waypoints, animationEngine, displayWidth, displayHeight) {\n    // Skip if no label text or mode is 'none'\n    if (!waypoint.label || waypoint.labelMode === 'none') return;\n    \n    // Find the true waypoint position in path coordinates\n    const wpIndex = waypoints.indexOf(waypoint);\n    const totalPoints = this.waypointPositions.length;\n    \n    // Get exact path position for this waypoint\n    let waypointPointIndex = 0;\n    if (wpIndex < waypoints.length - 1) {\n      waypointPointIndex = (wpIndex / (waypoints.length - 1)) * totalPoints;\n    } else {\n      waypointPointIndex = totalPoints;\n    }\n    \n    // Current animation position in path coordinates\n    const exactCurrentPoint = totalPoints * animationEngine.getProgress();\n    \n    // Calculate animation timing parameters\n    const fadeTimeInPoints = totalPoints * 0.02; // 1% of animation = 0.5 seconds\n    let opacity = 0; // Start with zero opacity\n    \n    // Handle different label modes\n    switch (waypoint.labelMode) {\n      case 'on': \n        opacity = 1.0;\n        break;\n        \n      case 'fade':\n        if (exactCurrentPoint < waypointPointIndex) return;\n        const elapsed = exactCurrentPoint - waypointPointIndex;\n        \n        if (elapsed <= fadeTimeInPoints / 2) {\n          opacity = Math.min(1.0, elapsed / (fadeTimeInPoints / 2));\n          opacity = Math.pow(opacity, 0.5);\n        }\n        else if (elapsed <= fadeTimeInPoints * 3) {\n          opacity = 1.0;\n        }\n        else if (elapsed <= fadeTimeInPoints * 4) {\n          opacity = 1.0 - Math.min(1.0, (elapsed - fadeTimeInPoints * 3) / fadeTimeInPoints);\n        }\n        else {\n          return;\n        }\n        break;\n        \n      case 'persist':\n        const timeBeforeWaypoint = waypointPointIndex - exactCurrentPoint;\n        \n        if (timeBeforeWaypoint > fadeTimeInPoints) return;\n        \n        if (timeBeforeWaypoint > 0) {\n          const fadeProgress = 1.0 - (timeBeforeWaypoint / fadeTimeInPoints);\n          opacity = Math.pow(fadeProgress, 0.5);\n        }\n        else {\n          opacity = 1.0;\n        }\n        break;\n        \n      default:\n        return;\n    }\n    \n    // Save context for restoring later\n    ctx.save();\n    \n    // Apply calculated opacity\n    ctx.globalAlpha = Math.max(0.15, opacity);\n    \n    // Label style\n    ctx.font = 'bold 16px Arial';\n    \n    const blueAmount = opacity < 1.0 ? Math.max(0, 1 - opacity) * 60 : 0;\n    ctx.fillStyle = `rgb(${255-blueAmount}, ${255-blueAmount}, 255)`;\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 3;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    \n    // Add shadow for better visibility\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n    ctx.shadowBlur = 5;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    \n    // Calculate label position based on position setting\n    const padding = RENDERING.LABEL_OFFSET_X;\n    const position = waypoint.labelPosition || 'auto';\n    let labelX = x;\n    let labelY = y;\n    \n    // Adjust position based on setting\n    switch (position) {\n      case 'top':\n        labelY = y - dotSize - padding;\n        break;\n      case 'right':\n        labelX = x + dotSize + padding;\n        ctx.textAlign = 'left';\n        break;\n      case 'bottom':\n        labelY = y + dotSize + padding;\n        break;\n      case 'left':\n        labelX = x - dotSize - padding;\n        ctx.textAlign = 'right';\n        break;\n      case 'auto':\n      default:\n        const cw = displayWidth;\n        const ch = displayHeight;\n        \n        labelY = y - dotSize - padding;\n        \n        if (labelY < 30) {\n          labelY = y + dotSize + padding;\n        }\n        \n        if (x < 100) {\n          labelX = x + dotSize + padding;\n          ctx.textAlign = 'left';\n        } else if (x > cw - 100) {\n          labelX = x - dotSize - padding;\n          ctx.textAlign = 'right';\n        }\n        break;\n    }\n    \n    // Draw text with outline for readability\n    ctx.strokeText(waypoint.label, labelX, labelY);\n    ctx.fillText(waypoint.label, labelX, labelY);\n    \n    // Restore context to clear shadow and alpha\n    ctx.restore();\n  }\n  \n  /**\n   * Apply line style for path rendering\n   */\n  applyLineStyle(ctx, style) {\n    switch (style) {\n      case 'dotted':\n        ctx.setLineDash([2, 6]);\n        break;\n      case 'dashed':\n        ctx.setLineDash([10, 5]);\n        break;\n      case 'squiggle':\n        // Approximated with dashed pattern - true squiggle would need complex path manipulation\n        ctx.setLineDash([5, 3, 2, 3]);\n        break;\n      case 'solid':\n      default:\n        ctx.setLineDash([]);\n        break;\n    }\n  }\n}\n", "/**\n * Simple event bus for decoupled communication between components\n * Implements publish-subscribe pattern\n */\nexport class EventBus {\n  constructor() {\n    this.events = new Map();\n  }\n  \n  /**\n   * Subscribe to an event\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    if (!this.events.has(eventName)) {\n      this.events.set(eventName, []);\n    }\n    \n    const listeners = this.events.get(eventName);\n    listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => this.off(eventName, callback);\n  }\n  \n  /**\n   * Subscribe to an event (alias for on)\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(eventName, callback) {\n    return this.on(eventName, callback);\n  }\n  \n  /**\n   * Unsubscribe from an event\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to remove\n   */\n  off(eventName, callback) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    const index = listeners.indexOf(callback);\n    \n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    \n    // Clean up empty listener arrays\n    if (listeners.length === 0) {\n      this.events.delete(eventName);\n    }\n  }\n  \n  /**\n   * Unsubscribe from an event (alias for off)\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to remove\n   */\n  unsubscribe(eventName, callback) {\n    this.off(eventName, callback);\n  }\n  \n  /**\n   * Subscribe to an event that only fires once\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  once(eventName, callback) {\n    const wrapper = (...args) => {\n      callback(...args);\n      this.off(eventName, wrapper);\n    };\n    \n    return this.on(eventName, wrapper);\n  }\n  \n  /**\n   * Emit an event\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   */\n  emit(eventName, ...args) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    // Create a copy to avoid issues if listeners modify the array\n    const listenersCopy = [...listeners];\n    \n    listenersCopy.forEach(listener => {\n      try {\n        listener(...args);\n      } catch (error) {\n        console.error(`Error in event listener for ${eventName}:`, error);\n      }\n    });\n  }\n  \n  /**\n   * Emit an event (alias for emit)\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   */\n  publish(eventName, ...args) {\n    this.emit(eventName, ...args);\n  }\n  \n  /**\n   * Emit an event asynchronously\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   * @returns {Promise} Promise that resolves when all listeners have been called\n   */\n  async emitAsync(eventName, ...args) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    const listenersCopy = [...listeners];\n    \n    const promises = listenersCopy.map(listener => {\n      return Promise.resolve().then(() => listener(...args));\n    });\n    \n    await Promise.all(promises);\n  }\n  \n  /**\n   * Remove all listeners for an event\n   * @param {string} eventName - Name of the event\n   */\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n  }\n  \n  /**\n   * Get the number of listeners for an event\n   * @param {string} eventName - Name of the event\n   * @returns {number} Number of listeners\n   */\n  listenerCount(eventName) {\n    if (!this.events.has(eventName)) return 0;\n    return this.events.get(eventName).length;\n  }\n  \n  /**\n   * Get all event names\n   * @returns {Array} Array of event names\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  \n  /**\n   * Clear all events and listeners\n   */\n  clear() {\n    this.events.clear();\n  }\n  \n  /**\n   * Destroy the event bus\n   */\n  destroy() {\n    this.clear();\n  }\n}\n", "import { RENDERING, ANIMATION } from '../config/constants.js';\n\n/**\n * Model representing a waypoint on the route\n * Encapsulates waypoint properties and provides methods for manipulation\n */\nexport class Waypoint {\n  constructor(options = {}) {\n    // Position (normalized image coordinates 0-1)\n    this.imgX = options.imgX || 0;\n    this.imgY = options.imgY || 0;\n    \n    // Type\n    this.isMajor = options.isMajor !== undefined ? options.isMajor : true;\n    \n    // Property change tracking for performance optimization\n    this._dirtyProps = new Set();\n    \n    // Visual properties\n    this.segmentColor = options.segmentColor || RENDERING.DEFAULT_PATH_COLOR;\n    this.segmentWidth = options.segmentWidth || RENDERING.DEFAULT_PATH_THICKNESS;\n    this.segmentStyle = options.segmentStyle || 'solid'; // solid, dashed, dotted\n    this.segmentTension = options.segmentTension || 0.5;\n    \n    // Path shape for segments starting from this waypoint\n    this.pathShape = options.pathShape || 'line'; // line, squiggle, randomised\n    \n    // Marker properties\n    this.markerStyle = options.markerStyle || 'dot'; // dot, square, flag, none\n    this.dotColor = options.dotColor || RENDERING.DEFAULT_PATH_COLOR;\n    this.dotSize = options.dotSize || (this.isMajor ? RENDERING.DEFAULT_DOT_SIZE : RENDERING.MINOR_DOT_SIZE);\n    \n    // Beacon effect\n    this.beaconStyle = options.beaconStyle || 'none'; // none, pulse, ripple\n    this.beaconColor = options.beaconColor || RENDERING.DEFAULT_PATH_COLOR;\n    \n    // Label\n    this.label = options.label || '';\n    this.labelMode = options.labelMode || 'none'; // none, on, fade, persist\n    this.labelPosition = options.labelPosition || 'auto'; // auto, top, right, bottom, left\n    \n    // Animation pause\n    this.pauseMode = options.pauseMode || 'none'; // none, timed\n    this.pauseTime = options.pauseTime || ANIMATION.DEFAULT_WAIT_TIME;\n    \n    // Path head style for when animation reaches this waypoint\n    this.pathHeadStyle = options.pathHeadStyle || 'arrow'; // dot, arrow, custom, none\n    this.pathHeadColor = options.pathHeadColor || '#111111';\n    this.pathHeadSize = options.pathHeadSize || RENDERING.PATH_HEAD_SIZE;\n    this.pathHeadImage = options.pathHeadImage || null;\n    \n    // Custom image (for custom marker)\n    this.customImage = options.customImage || null;\n    \n    // Metadata\n    this.id = options.id || this.generateId();\n    this.created = options.created || Date.now();\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Generate unique ID for waypoint\n   * @private\n   * @returns {string} Unique identifier\n   */\n  generateId() {\n    return `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  /**\n   * Update waypoint properties\n   * Tracks which properties changed for smart event emission\n   * @param {Object} updates - Properties to update\n   */\n  update(updates) {\n    Object.keys(updates).forEach(key => {\n      if (key in this && key !== 'id' && key !== 'created') {\n        // Track changes for smart event emissions\n        if (this[key] !== updates[key]) {\n          this[key] = updates[key];\n          this._dirtyProps.add(key);\n        }\n      }\n    });\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Set position\n   * @param {number} x - X coordinate (normalized 0-1)\n   * @param {number} y - Y coordinate (normalized 0-1)\n   */\n  setPosition(x, y) {\n    this.imgX = Math.max(0, Math.min(1, x));\n    this.imgY = Math.max(0, Math.min(1, y));\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Toggle between major and minor waypoint\n   */\n  toggleType() {\n    this.isMajor = !this.isMajor;\n    \n    // Adjust properties based on type\n    if (!this.isMajor) {\n      // Minor waypoints have simpler properties\n      this.labelMode = 'none';\n      this.beaconStyle = 'none';\n      this.pauseMode = 'none';\n      this.dotSize = RENDERING.MINOR_DOT_SIZE;\n    } else {\n      this.dotSize = RENDERING.DEFAULT_DOT_SIZE;\n    }\n    \n    this.modified = Date.now();\n  }\n  \n  /**\n   * Check if waypoint should pause animation\n   * @returns {boolean} True if waypoint has pause time\n   */\n  shouldPause() {\n    return this.isMajor && \n           this.pauseMode === 'timed' && \n           this.pauseTime > 0;\n  }\n  \n  /**\n   * Get pause duration in milliseconds\n   * @returns {number} Pause duration\n   */\n  getPauseDuration() {\n    return this.shouldPause() ? this.pauseTime : 0;\n  }\n  \n  /**\n   * Check if waypoint has a label\n   * @returns {boolean} True if waypoint has a label to display\n   */\n  hasLabel() {\n    return this.label && this.label.trim().length > 0 && this.labelMode !== 'none';\n  }\n  \n  /**\n   * Check if waypoint has beacon effect\n   * @returns {boolean} True if waypoint has beacon effect\n   */\n  hasBeacon() {\n    return this.beaconStyle !== 'none';\n  }\n  \n  /**\n   * Check if waypoint is visible\n   * @returns {boolean} True if waypoint marker is visible\n   */\n  isVisible() {\n    return this.markerStyle !== 'none';\n  }\n  \n  /**\n   * Copy properties from another waypoint (for inheritance)\n   * Useful when creating new waypoints that should inherit style from previous\n   * @param {Waypoint} source - Waypoint to copy properties from\n   * @param {Array<string>} exclude - Properties to exclude from copying\n   * @returns {Waypoint} This waypoint (for chaining)\n   */\n  copyPropertiesFrom(source, exclude = ['id', 'imgX', 'imgY', 'created', 'modified', 'label']) {\n    // Properties to copy (style and path properties)\n    const copyProps = [\n      'segmentColor', 'segmentWidth', 'segmentStyle', 'segmentTension',\n      'pathShape', 'markerStyle', 'dotColor', 'dotSize',\n      'beaconStyle', 'beaconColor', 'labelMode', 'labelPosition',\n      'pauseMode', 'pauseTime', 'pathHeadStyle', 'pathHeadColor',\n      'pathHeadSize', 'pathHeadImage', 'customImage'\n    ];\n    \n    copyProps.forEach(prop => {\n      if (!exclude.includes(prop) && prop in source) {\n        this[prop] = source[prop];\n      }\n    });\n    \n    // Adjust for waypoint type differences\n    if (!this.isMajor && source.isMajor) {\n      // Minor waypoints don't have labels, beacons, or pauses\n      this.labelMode = 'none';\n      this.beaconStyle = 'none';\n      this.pauseMode = 'none';\n    }\n    \n    this.modified = Date.now();\n    return this; // Chainable\n  }\n  \n  /**\n   * Get list of properties that have changed since last clear\n   * @returns {Array<string>} Array of property names that changed\n   */\n  getDirtyProps() {\n    return Array.from(this._dirtyProps);\n  }\n  \n  /**\n   * Clear the dirty properties tracker\n   */\n  clearDirtyProps() {\n    this._dirtyProps.clear();\n  }\n  \n  /**\n   * Check if recent changes are style-only (no path recalculation needed)\n   * @returns {boolean} True if only style properties changed\n   */\n  isStyleChange() {\n    const styleProps = ['dotColor', 'dotSize', 'markerStyle', 'beaconColor', 'beaconStyle', 'label', 'labelMode', 'labelPosition'];\n    return this._dirtyProps.size > 0 &&\n           Array.from(this._dirtyProps).every(p => styleProps.includes(p));\n  }\n  \n  /**\n   * Check if recent changes affect path generation\n   * @returns {boolean} True if path properties changed\n   */\n  isPathChange() {\n    const pathProps = ['segmentColor', 'segmentWidth', 'segmentStyle', 'pathShape', 'segmentTension'];\n    return Array.from(this._dirtyProps).some(p => pathProps.includes(p));\n  }\n  \n  /**\n   * Check if position changed\n   * @returns {boolean} True if position changed\n   */\n  isPositionChange() {\n    return this._dirtyProps.has('imgX') || this._dirtyProps.has('imgY');\n  }\n  \n  /**\n   * Clone the waypoint\n   * @returns {Waypoint} New waypoint with same properties\n   */\n  clone() {\n    return new Waypoint(this.toJSON());\n  }\n  \n  /**\n   * Convert to plain object for serialization\n   * @returns {Object} Plain object representation\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      imgX: this.imgX,\n      imgY: this.imgY,\n      isMajor: this.isMajor,\n      segmentColor: this.segmentColor,\n      segmentWidth: this.segmentWidth,\n      segmentStyle: this.segmentStyle,\n      segmentTension: this.segmentTension,\n      pathShape: this.pathShape,\n      markerStyle: this.markerStyle,\n      dotColor: this.dotColor,\n      dotSize: this.dotSize,\n      beaconStyle: this.beaconStyle,\n      beaconColor: this.beaconColor,\n      label: this.label,\n      labelMode: this.labelMode,\n      labelPosition: this.labelPosition,\n      pauseMode: this.pauseMode,\n      pauseTime: this.pauseTime,\n      pathHeadStyle: this.pathHeadStyle,\n      pathHeadColor: this.pathHeadColor,\n      pathHeadSize: this.pathHeadSize,\n      pathHeadImage: this.pathHeadImage,\n      customImage: this.customImage,\n      created: this.created,\n      modified: this.modified\n    };\n  }\n  \n  /**\n   * Create waypoint from plain object\n   * @param {Object} data - Plain object with waypoint data\n   * @returns {Waypoint} New waypoint instance\n   */\n  static fromJSON(data) {\n    return new Waypoint(data);\n  }\n  \n  /**\n   * Create default major waypoint\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @returns {Waypoint} New major waypoint\n   */\n  static createMajor(x, y) {\n    return new Waypoint({\n      imgX: x,\n      imgY: y,\n      isMajor: true\n    });\n  }\n  \n  /**\n   * Create default minor waypoint\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @returns {Waypoint} New minor waypoint\n   */\n  static createMinor(x, y) {\n    return new Waypoint({\n      imgX: x,\n      imgY: y,\n      isMajor: false,\n      labelMode: 'none',\n      beaconStyle: 'none',\n      pauseMode: 'none',\n      dotSize: RENDERING.MINOR_DOT_SIZE\n    });\n  }\n  \n  /**\n   * Validate waypoint data\n   * @param {Object} data - Data to validate\n   * @returns {boolean} True if data is valid\n   */\n  static validate(data) {\n    if (!data || typeof data !== 'object') return false;\n    \n    // Required properties\n    if (typeof data.imgX !== 'number' || data.imgX < 0 || data.imgX > 1) return false;\n    if (typeof data.imgY !== 'number' || data.imgY < 0 || data.imgY > 1) return false;\n    \n    // Optional properties with valid values\n    if (data.markerStyle && !['dot', 'square', 'flag', 'none'].includes(data.markerStyle)) return false;\n    if (data.segmentStyle && !['solid', 'dashed', 'dotted'].includes(data.segmentStyle)) return false;\n    if (data.pathShape && !['line', 'squiggle', 'randomised'].includes(data.pathShape)) return false;\n    if (data.beaconStyle && !['none', 'pulse', 'ripple'].includes(data.beaconStyle)) return false;\n    if (data.labelMode && !['none', 'on', 'fade', 'persist'].includes(data.labelMode)) return false;\n    if (data.pauseMode && !['none', 'timed'].includes(data.pauseMode)) return false;\n    \n    return true;\n  }\n}\n", "/**\n * UIController - Manages all UI interactions and updates\n * Handles waypoint list, editor controls, tabs, and animation controls\n */\n\nimport { RENDERING, ANIMATION } from '../config/constants.js';\n\nexport class UIController {\n  constructor(elements, eventBus) {\n    this.elements = elements;\n    this.eventBus = eventBus;\n    this.selectedWaypoint = null;\n    \n    // Bind methods\n    this.updateWaypointList = this.updateWaypointList.bind(this);\n    this.updateWaypointEditor = this.updateWaypointEditor.bind(this);\n    this.syncAnimationControls = this.syncAnimationControls.bind(this);\n    \n    this.setupEventListeners();\n  }\n  \n  /**\n   * Set up all UI event listeners\n   */\n  setupEventListeners() {\n    console.log('\uD83D\uDD27 [UIController] Setting up event listeners at:', performance.now().toFixed(2), 'ms');\n    // Tab switching\n    this.elements.tabBtns?.forEach(btn => {\n      btn.addEventListener('click', (e) => this.handleTabSwitch(e));\n    });\n    \n    // Background controls\n    this.elements.bgUploadBtn?.addEventListener('click', () => {\n      this.elements.bgUpload.click();\n    });\n    \n    this.elements.bgUpload?.addEventListener('change', (e) => {\n      const file = e.target.files[0];\n      if (file) {\n        this.eventBus.emit('background:upload', file);\n      }\n    });\n    \n    this.elements.bgOverlay?.addEventListener('input', (e) => {\n      const value = parseInt(e.target.value);\n      this.elements.bgOverlayValue.textContent = value;\n      this.eventBus.emit('background:overlay-change', value);\n    });\n    \n    this.elements.bgFitToggle?.addEventListener('click', () => {\n      const currentMode = this.elements.bgFitToggle.dataset.mode;\n      const newMode = currentMode === 'fit' ? 'fill' : 'fit';\n      this.elements.bgFitToggle.dataset.mode = newMode;\n      this.elements.bgFitToggle.textContent = newMode === 'fit' ? 'Fit' : 'Fill';\n      this.eventBus.emit('background:mode-change', newMode);\n    });\n    \n    // Animation controls\n    this.elements.playBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:play');\n    });\n    \n    this.elements.pauseBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:pause');\n    });\n    \n    this.elements.skipStartBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:skip-start');\n    });\n    \n    this.elements.skipEndBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:skip-end');\n    });\n    \n    this.elements.timelineSlider?.addEventListener('input', (e) => {\n      const progress = e.target.value / ANIMATION.TIMELINE_RESOLUTION;\n      this.eventBus.emit('ui:animation:seek', progress);\n    });\n    \n    /**\n     * Animation speed slider with feedback loop prevention\n     * Uses multiple checks to distinguish between user input and programmatic updates\n     * to avoid circular event chains when slider value is set by code\n     */\n    let isUpdatingSlider = false;\n    \n    this.elements.animationSpeed?.addEventListener('input', (e) => {\n      const currentValue = parseInt(e.target.value);\n      const timestamp = performance.now().toFixed(2);\n      \n      // Comprehensive event logging\n      console.log(`\n\uD83D\uDCE1 [${timestamp}ms] SLIDER INPUT EVENT:`, {\n        value: currentValue,\n        isTrusted: e.isTrusted,\n        isUpdating: isUpdatingSlider,\n        hasFocus: document.activeElement === e.target,\n        eventType: e.type,\n        target: e.target.id\n      });\n      \n      // Check if this is a programmatic change\n      if (isUpdatingSlider) {\n        console.log('\uD83D\uDEE1\uFE0F [UIController] Blocked programmatic input event, value:', currentValue);\n        console.trace('Blocked event stack trace');\n        return;\n      }\n      \n      const speed = currentValue;\n      console.log('\uD83C\uDF9A\uFE0F [UIController] User moved slider to:', speed);\n      console.trace('User input stack trace');\n      this.eventBus.emit('animation:speed-change', speed);\n    });\n    \n    /**\n     * Listen for programmatic slider updates from other parts of the app\n     * Temporarily sets flag to prevent the input event from firing\n     * Rounds speed to nearest step value (5) to prevent snap-back\n     * @param {number} speed - The speed value to set on the slider\n     */\n    this.eventBus.on('ui:slider:update-speed', (speed) => {\n      const timestamp = performance.now().toFixed(2);\n      // Round to nearest step value (5) to prevent slider snap-back\n      const step = 5;\n      const roundedSpeed = Math.round(speed / step) * step;\n      console.log(`\n\uD83D\uDCB5 [${timestamp}ms] PROGRAMMATIC UPDATE:`, {\n        requested: speed,\n        rounded: roundedSpeed,\n        currentSliderValue: this.elements.animationSpeed.value\n      });\n      console.trace('Update origin');\n      \n      // Set protection and update slider\n      isUpdatingSlider = true;\n      this.elements.animationSpeed.value = roundedSpeed;\n      console.log(`\u2705 [${performance.now().toFixed(2)}ms] Protection ENABLED`);\n      \n      // Clear protection after brief delay to ensure queued events are blocked\n      setTimeout(() => { \n        const t = performance.now().toFixed(2);\n        console.log(`\u2705 [${t}ms] Re-enabling slider input detection`);\n        isUpdatingSlider = false;\n      }, 50);\n    });\n    \n    // Clear button\n    this.elements.clearBtn?.addEventListener('click', () => {\n      if (confirm('Clear all waypoints?')) {\n        this.eventBus.emit('waypoints:clear-all');\n      }\n    });\n    \n    // Help button\n    this.elements.helpBtn?.addEventListener('click', () => {\n      this.showHelp();\n    });\n    \n    // Waypoint editor controls\n    this.setupWaypointEditorControls();\n  }\n  \n  /**\n   * Setup waypoint editor controls\n   */\n  setupWaypointEditorControls() {\n    // Marker style\n    this.elements.markerStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'markerStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Dot color\n    this.elements.dotColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'dotColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Dot size\n    this.elements.dotSize?.addEventListener('input', (e) => {\n      const size = parseInt(e.target.value);\n      this.elements.dotSizeValue.textContent = size;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'dotSize',\n          value: size\n        });\n      }\n    });\n    \n    // Segment properties\n    this.elements.segmentColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.segmentWidth?.addEventListener('input', (e) => {\n      const width = parseInt(e.target.value);\n      this.elements.segmentWidthValue.textContent = width;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentWidth',\n          value: width\n        });\n      }\n    });\n    \n    this.elements.segmentStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Path shape\n    this.elements.pathShape?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'pathShape',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Beacon style\n    this.elements.editorBeaconStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'beaconStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.editorBeaconColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'beaconColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Label controls\n    this.elements.waypointLabel?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'label',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.labelMode?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'labelMode',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.labelPosition?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'labelPosition',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Pause time\n    this.elements.waypointPauseTime?.addEventListener('input', (e) => {\n      const time = parseFloat(e.target.value);\n      this.elements.waypointPauseTimeValue.textContent = `${time}s`;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'pauseTime',\n          value: time * 1000 // Convert to ms\n        });\n      }\n    });\n    \n    // Path head controls\n    this.elements.pathHeadStyle?.addEventListener('change', (e) => {\n      this.eventBus.emit('pathhead:style-changed', e.target.value);\n    });\n    \n    this.elements.pathHeadColor?.addEventListener('input', (e) => {\n      this.eventBus.emit('pathhead:color-changed', e.target.value);\n    });\n    \n    this.elements.pathHeadSize?.addEventListener('input', (e) => {\n      const size = parseInt(e.target.value);\n      this.elements.pathHeadSizeValue.textContent = size;\n      this.eventBus.emit('pathhead:size-changed', size);\n    });\n  }\n  \n  /**\n   * Handle tab switching\n   */\n  handleTabSwitch(event) {\n    const tabBtn = event.target;\n    const tabName = tabBtn.dataset.tab;\n    \n    // Update button states\n    this.elements.tabBtns.forEach(btn => btn.classList.remove('active'));\n    tabBtn.classList.add('active');\n    \n    // Show corresponding tab content\n    document.querySelectorAll('.tab-content').forEach(content => {\n      content.classList.remove('active');\n    });\n    \n    const tabContent = document.getElementById(`${tabName}-tab`);\n    if (tabContent) {\n      tabContent.classList.add('active');\n    }\n  }\n  \n  /**\n   * Update waypoint list UI\n   */\n  updateWaypointList(waypoints) {\n    if (!this.elements.waypointList) return;\n    \n    this.elements.waypointList.innerHTML = '';\n    \n    // Only show major waypoints in the list\n    const majorWaypoints = waypoints.filter(wp => wp.isMajor);\n    \n    majorWaypoints.forEach((waypoint, index) => {\n      const item = document.createElement('div');\n      item.className = 'waypoint-item';\n      item.draggable = true; // Enable drag and drop\n      if (waypoint === this.selectedWaypoint) {\n        item.classList.add('selected');\n      }\n      \n      // Drag handle\n      const handle = document.createElement('span');\n      handle.className = 'waypoint-item-handle';\n      handle.textContent = '\u2630';\n      \n      // Label\n      const label = document.createElement('span');\n      label.className = 'waypoint-item-label';\n      label.textContent = waypoint.label || `Waypoint ${index + 1}`;\n      \n      // Delete button (simple \u00D7 character for cleaner look)\n      const delBtn = document.createElement('button');\n      delBtn.className = 'waypoint-item-delete';\n      delBtn.textContent = '\u00D7';\n      delBtn.title = 'Delete waypoint';\n      \n      item.appendChild(handle);\n      item.appendChild(label);\n      item.appendChild(delBtn);\n      \n      // Click anywhere on item to select (original behavior)\n      const selectWaypoint = (e) => {\n        e.stopPropagation();\n        this.eventBus.emit('waypoint:selected', waypoint);\n      };\n      \n      label.addEventListener('click', selectWaypoint);\n      handle.addEventListener('click', selectWaypoint);\n      item.addEventListener('click', selectWaypoint);\n      \n      // Delete button\n      delBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (confirm('Delete this waypoint?')) {\n          this.eventBus.emit('waypoint:deleted', waypoint);\n        }\n      });\n      \n      // Drag and drop handlers\n      item.addEventListener('dragstart', (e) => {\n        e.dataTransfer.effectAllowed = 'move';\n        e.dataTransfer.setData('text/plain', index.toString());\n        item.classList.add('dragging');\n      });\n      \n      item.addEventListener('dragend', (e) => {\n        item.classList.remove('dragging');\n      });\n      \n      item.addEventListener('dragover', (e) => {\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n        \n        const dragging = this.elements.waypointList.querySelector('.dragging');\n        if (dragging && dragging !== item) {\n          const rect = item.getBoundingClientRect();\n          const midpoint = rect.top + rect.height / 2;\n          \n          if (e.clientY < midpoint) {\n            item.parentNode.insertBefore(dragging, item);\n          } else {\n            item.parentNode.insertBefore(dragging, item.nextSibling);\n          }\n        }\n      });\n      \n      item.addEventListener('drop', (e) => {\n        e.preventDefault();\n        // Emit reorder event with new order\n        const items = Array.from(this.elements.waypointList.children);\n        const newOrder = items.map(el => {\n          const idx = Array.from(el.parentElement.children).indexOf(el);\n          return majorWaypoints[parseInt(el.dataset.originalIndex || idx)];\n        });\n        this.eventBus.emit('waypoints:reordered', newOrder);\n      });\n      \n      // Store original index for reordering\n      item.dataset.originalIndex = index;\n      \n      this.elements.waypointList.appendChild(item);\n    });\n  }\n  \n  /**\n   * Update waypoint editor with selected waypoint data\n   */\n  updateWaypointEditor(waypoint) {\n    this.selectedWaypoint = waypoint;\n    \n    if (!waypoint) {\n      // Hide editor, show placeholder\n      if (this.elements.waypointEditor) {\n        this.elements.waypointEditor.style.display = 'none';\n      }\n      if (this.elements.waypointEditorPlaceholder) {\n        this.elements.waypointEditorPlaceholder.style.display = 'flex';\n      }\n      return;\n    }\n    \n    // Show editor, hide placeholder\n    if (this.elements.waypointEditor) {\n      this.elements.waypointEditor.style.display = 'block';\n    }\n    if (this.elements.waypointEditorPlaceholder) {\n      this.elements.waypointEditorPlaceholder.style.display = 'none';\n    }\n    \n    // Update controls with waypoint values\n    if (this.elements.markerStyle) {\n      this.elements.markerStyle.value = waypoint.markerStyle || 'dot';\n    }\n    \n    if (this.elements.dotColor) {\n      this.elements.dotColor.value = waypoint.dotColor || '#FF6B6B';\n    }\n    \n    if (this.elements.dotSize) {\n      this.elements.dotSize.value = waypoint.dotSize || 8;\n      this.elements.dotSizeValue.textContent = waypoint.dotSize || 8;\n    }\n    \n    if (this.elements.segmentColor) {\n      this.elements.segmentColor.value = waypoint.segmentColor || '#FF6B6B';\n    }\n    \n    if (this.elements.segmentWidth) {\n      this.elements.segmentWidth.value = waypoint.segmentWidth || 3;\n      this.elements.segmentWidthValue.textContent = waypoint.segmentWidth || 3;\n    }\n    \n    if (this.elements.segmentStyle) {\n      this.elements.segmentStyle.value = waypoint.segmentStyle || 'solid';\n    }\n    \n    if (this.elements.pathShape) {\n      this.elements.pathShape.value = waypoint.pathShape || 'line';\n    }\n    \n    if (this.elements.editorBeaconStyle) {\n      this.elements.editorBeaconStyle.value = waypoint.beaconStyle || 'pulse';\n    }\n    \n    if (this.elements.editorBeaconColor) {\n      this.elements.editorBeaconColor.value = waypoint.beaconColor || '#FF6B6B';\n    }\n    \n    if (this.elements.waypointLabel) {\n      this.elements.waypointLabel.value = waypoint.label || '';\n    }\n    \n    if (this.elements.labelMode) {\n      this.elements.labelMode.value = waypoint.labelMode || 'none';\n    }\n    \n    if (this.elements.labelPosition) {\n      this.elements.labelPosition.value = waypoint.labelPosition || 'auto';\n    }\n    \n    if (this.elements.waypointPauseTime) {\n      const pauseSeconds = (waypoint.pauseTime || 1500) / 1000;\n      this.elements.waypointPauseTime.value = pauseSeconds;\n      this.elements.waypointPauseTimeValue.textContent = `${pauseSeconds}s`;\n    }\n    \n    // Update pause control visibility\n    const pauseControl = this.elements.pauseTimeControl;\n    if (pauseControl) {\n      pauseControl.style.display = waypoint.isMajor ? 'block' : 'none';\n    }\n  }\n  \n  /**\n   * Sync animation controls with animation state\n   */\n  syncAnimationControls(state) {\n    // Toggle play/pause button visibility\n    if (state.isPlaying) {\n      if (this.elements.playBtn) this.elements.playBtn.style.display = 'none';\n      if (this.elements.pauseBtn) this.elements.pauseBtn.style.display = 'inline-block';\n    } else {\n      if (this.elements.playBtn) this.elements.playBtn.style.display = 'inline-block';\n      if (this.elements.pauseBtn) this.elements.pauseBtn.style.display = 'none';\n    }\n    \n    // Update timeline\n    if (this.elements.timelineSlider && !state.isDraggingTimeline) {\n      this.elements.timelineSlider.value = Math.round(state.progress * ANIMATION.TIMELINE_RESOLUTION);\n    }\n    \n    // Update time display\n    this.updateTimeDisplay(state.currentTime, state.duration);\n  }\n  \n  /**\n   * Update time display\n   */\n  updateTimeDisplay(currentTime, duration) {\n    const formatTime = (ms) => {\n      const totalSeconds = Math.floor(ms / 1000);\n      const minutes = Math.floor(totalSeconds / 60);\n      const seconds = totalSeconds % 60;\n      return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    };\n    \n    if (this.elements.currentTime) {\n      this.elements.currentTime.textContent = formatTime(currentTime);\n    }\n    if (this.elements.totalTime) {\n      this.elements.totalTime.textContent = formatTime(duration);\n    }\n  }\n  \n  /**\n   * Show help/splash screen\n   */\n  showHelp() {\n    if (this.elements.splash) {\n      this.elements.splash.style.display = 'flex';\n    }\n  }\n  \n  /**\n   * Hide help/splash screen\n   */\n  hideHelp() {\n    if (this.elements.splash) {\n      this.elements.splash.style.display = 'none';\n    }\n  }\n  \n  /**\n   * Make an announcement for screen readers\n   */\n  announce(message) {\n    if (this.elements.announcer) {\n      this.elements.announcer.textContent = message;\n    }\n  }\n}\n", "/**\n * InteractionHandler - Manages mouse, keyboard, and touch interactions\n * Handles canvas clicks, dragging, keyboard shortcuts, and drag & drop\n */\n\nimport { INTERACTION } from '../config/constants.js';\n\nexport class InteractionHandler {\n  constructor(canvas, eventBus) {\n    this.canvas = canvas;\n    this.eventBus = eventBus;\n    \n    // Drag state\n    this.isDragging = false;\n    this.hasDragged = false;\n    this.dragOffset = { x: 0, y: 0 };\n    this.selectedWaypoint = null;\n    \n    // Bind methods\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleCanvasClick = this.handleCanvasClick.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleDragOver = this.handleDragOver.bind(this);\n    this.handleDrop = this.handleDrop.bind(this);\n    \n    this.setupEventListeners();\n  }\n  \n  /**\n   * Set up all interaction event listeners\n   */\n  setupEventListeners() {\n    // Mouse events\n    this.canvas.addEventListener('mousedown', this.handleMouseDown);\n    this.canvas.addEventListener('mousemove', this.handleMouseMove);\n    this.canvas.addEventListener('mouseup', this.handleMouseUp);\n    this.canvas.addEventListener('click', this.handleCanvasClick);\n    \n    // Touch events (for mobile support)\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });\n    \n    // Keyboard events\n    document.addEventListener('keydown', this.handleKeyDown);\n    \n    // Drag and drop for images\n    this.canvas.addEventListener('dragover', this.handleDragOver);\n    this.canvas.addEventListener('drop', this.handleDrop);\n    \n    // Context menu (right-click)\n    this.canvas.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.handleContextMenu(e);\n    });\n  }\n  \n  /**\n   * Handle mouse down event\n   */\n  handleMouseDown(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on a waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        this.selectedWaypoint = waypoint;\n        this.isDragging = true;\n        this.hasDragged = false;\n        \n        // Calculate drag offset\n        this.eventBus.emit('coordinate:image-to-canvas', \n          { imgX: waypoint.imgX, imgY: waypoint.imgY }, \n          (canvasPos) => {\n            this.dragOffset.x = x - canvasPos.x;\n            this.dragOffset.y = y - canvasPos.y;\n          }\n        );\n        \n        // Add dragging class to canvas\n        this.canvas.classList.add('dragging');\n        \n        // Select the waypoint\n        this.eventBus.emit('waypoint:selected', waypoint);\n      }\n    });\n  }\n  \n  /**\n   * Handle mouse move event\n   */\n  handleMouseMove(event) {\n    if (this.isDragging && this.selectedWaypoint) {\n      const rect = this.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      \n      // Track that we actually moved\n      this.hasDragged = true;\n      \n      // Calculate new position accounting for offset\n      const newX = x - this.dragOffset.x;\n      const newY = y - this.dragOffset.y;\n      \n      // Convert to image coordinates\n      this.eventBus.emit('coordinate:canvas-to-image',\n        { canvasX: newX, canvasY: newY },\n        (imgPos) => {\n          // Emit position change event\n          this.eventBus.emit('waypoint:position-changed', {\n            waypoint: this.selectedWaypoint,\n            imgX: imgPos.x,\n            imgY: imgPos.y,\n            isDragging: true\n          });\n        }\n      );\n    }\n  }\n  \n  /**\n   * Handle mouse up event\n   */\n  handleMouseUp(event) {\n    if (this.isDragging) {\n      this.isDragging = false;\n      this.canvas.classList.remove('dragging');\n      \n      // If we actually dragged, save the position\n      if (this.hasDragged) {\n        this.eventBus.emit('waypoint:drag-ended', this.selectedWaypoint);\n      }\n      \n      this.selectedWaypoint = null;\n      this.hasDragged = false;\n    }\n  }\n  \n  /**\n   * Handle canvas click event\n   */\n  handleCanvasClick(event) {\n    // Don't add waypoint if we actually dragged\n    if (this.hasDragged) {\n      this.hasDragged = false;\n      return;\n    }\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        // Select existing waypoint\n        this.eventBus.emit('waypoint:selected', waypoint);\n      } else {\n        // Add new waypoint\n        const isMajor = !event.shiftKey; // Shift+click for minor waypoint\n        \n        // Convert to image coordinates\n        this.eventBus.emit('coordinate:canvas-to-image',\n          { canvasX: x, canvasY: y },\n          (imgPos) => {\n            this.eventBus.emit('waypoint:add', {\n              imgX: imgPos.x,\n              imgY: imgPos.y,\n              isMajor: isMajor\n            });\n          }\n        );\n      }\n    });\n  }\n  \n  /**\n   * Handle keyboard events\n   */\n  handleKeyDown(event) {\n    // Don't interfere with input fields\n    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n      return;\n    }\n    \n    const key = event.key.toLowerCase();\n    const shift = event.shiftKey;\n    const ctrl = event.ctrlKey || event.metaKey;\n    \n    // Animation controls\n    if (key === ' ') {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:toggle');\n    } else if (key === 'arrowleft' && !shift) {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:skip-start');\n    } else if (key === 'arrowright' && !shift) {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:skip-end');\n    }\n    \n    // Playback speed controls (J/K/L keys)\n    else if (key === 'j') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-decrease');\n    } else if (key === 'k') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-reset');\n    } else if (key === 'l') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-increase');\n    }\n    \n    // Waypoint movement (arrow keys with shift)\n    else if (shift && this.selectedWaypoint) {\n      const moveAmount = ctrl ? 10 : 1; // Ctrl for larger movements\n      let dx = 0, dy = 0;\n      \n      switch (key) {\n        case 'arrowup':\n          dy = -moveAmount;\n          break;\n        case 'arrowdown':\n          dy = moveAmount;\n          break;\n        case 'arrowleft':\n          dx = -moveAmount;\n          break;\n        case 'arrowright':\n          dx = moveAmount;\n          break;\n        default:\n          return;\n      }\n      \n      if (dx !== 0 || dy !== 0) {\n        event.preventDefault();\n        this.eventBus.emit('waypoint:move-by-pixels', {\n          waypoint: this.selectedWaypoint,\n          dx: dx,\n          dy: dy\n        });\n      }\n    }\n    \n    // Delete selected waypoint\n    else if ((key === 'delete' || key === 'backspace') && this.selectedWaypoint) {\n      event.preventDefault();\n      this.eventBus.emit('waypoint:delete-selected');\n    }\n    \n    // Select next/previous waypoint\n    else if (key === 'tab') {\n      event.preventDefault();\n      const direction = shift ? 'previous' : 'next';\n      this.eventBus.emit('waypoint:select-adjacent', direction);\n    }\n    \n    // Toggle waypoint type\n    else if (key === 't' && this.selectedWaypoint) {\n      event.preventDefault();\n      this.eventBus.emit('waypoint:toggle-type', this.selectedWaypoint);\n    }\n    \n    // Undo/Redo (Ctrl+Z, Ctrl+Shift+Z)\n    else if (ctrl && key === 'z') {\n      event.preventDefault();\n      if (shift) {\n        this.eventBus.emit('history:redo');\n      } else {\n        this.eventBus.emit('history:undo');\n      }\n    }\n    \n    // Save (Ctrl+S)\n    else if (ctrl && key === 's') {\n      event.preventDefault();\n      this.eventBus.emit('file:save');\n    }\n    \n    // Help (? or H, but not Cmd+H or Ctrl+H)\n    else if ((key === '?' || key === 'h') && !ctrl) {\n      event.preventDefault();\n      this.eventBus.emit('help:toggle');\n    }\n  }\n  \n  /**\n   * Handle touch start (mobile)\n   */\n  handleTouchStart(event) {\n    if (event.touches.length === 1) {\n      const touch = event.touches[0];\n      const rect = this.canvas.getBoundingClientRect();\n      const x = touch.clientX - rect.left;\n      const y = touch.clientY - rect.top;\n      \n      // Simulate mouse down\n      this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n  }\n  \n  /**\n   * Handle touch move (mobile)\n   */\n  handleTouchMove(event) {\n    if (event.touches.length === 1 && this.isDragging) {\n      event.preventDefault();\n      const touch = event.touches[0];\n      \n      // Simulate mouse move\n      this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n  }\n  \n  /**\n   * Handle touch end (mobile)\n   */\n  handleTouchEnd(event) {\n    if (event.changedTouches.length === 1) {\n      const touch = event.changedTouches[0];\n      \n      // Simulate mouse up\n      this.handleMouseUp({ clientX: touch.clientX, clientY: touch.clientY });\n      \n      // If no drag occurred, treat as click\n      if (!this.hasDragged) {\n        this.handleCanvasClick({ \n          clientX: touch.clientX, \n          clientY: touch.clientY,\n          shiftKey: false \n        });\n      }\n    }\n  }\n  \n  /**\n   * Handle drag over event (for image drop)\n   */\n  handleDragOver(event) {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n    this.canvas.classList.add('drag-over');\n  }\n  \n  /**\n   * Handle drop event (for image drop)\n   */\n  handleDrop(event) {\n    event.preventDefault();\n    this.canvas.classList.remove('drag-over');\n    \n    const files = event.dataTransfer.files;\n    if (files.length > 0) {\n      const file = files[0];\n      if (file.type.startsWith('image/')) {\n        this.eventBus.emit('background:upload', file);\n      }\n    }\n  }\n  \n  /**\n   * Handle context menu (right-click)\n   */\n  handleContextMenu(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if right-clicking on a waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        // Show waypoint context menu\n        this.eventBus.emit('waypoint:show-context-menu', {\n          waypoint: waypoint,\n          x: event.clientX,\n          y: event.clientY\n        });\n      } else {\n        // Show canvas context menu\n        this.eventBus.emit('canvas:show-context-menu', {\n          x: event.clientX,\n          y: event.clientY,\n          canvasX: x,\n          canvasY: y\n        });\n      }\n    });\n  }\n  \n  /**\n   * Set selected waypoint (for external updates)\n   */\n  setSelectedWaypoint(waypoint) {\n    this.selectedWaypoint = waypoint;\n  }\n  \n  /**\n   * Clean up event listeners\n   */\n  destroy() {\n    this.canvas.removeEventListener('mousedown', this.handleMouseDown);\n    this.canvas.removeEventListener('mousemove', this.handleMouseMove);\n    this.canvas.removeEventListener('mouseup', this.handleMouseUp);\n    this.canvas.removeEventListener('click', this.handleCanvasClick);\n    document.removeEventListener('keydown', this.handleKeyDown);\n    this.canvas.removeEventListener('dragover', this.handleDragOver);\n    this.canvas.removeEventListener('drop', this.handleDrop);\n  }\n}\n", "// Import modular utilities\nimport { CatmullRom } from './utils/CatmullRom.js';\nimport { Easing } from './utils/Easing.js';\nimport { RENDERING, ANIMATION, INTERACTION, PATH } from './config/constants.js';\nimport { StorageService } from './services/StorageService.js';\nimport { CoordinateTransform } from './services/CoordinateTransform.js';\nimport { PathCalculatorWithWorker } from './services/PathCalculatorWithWorker.js';\nimport { AnimationEngine } from './services/AnimationEngine.js';\nimport { RenderingService } from './services/RenderingService.js';\nimport { EventBus } from './core/EventBus.js';\nimport { Waypoint } from './models/Waypoint.js';\nimport { UIController } from './controllers/UIController.js';\nimport { InteractionHandler } from './handlers/InteractionHandler.js';\n\n// Main application class for Route Plotter v3\nclass RoutePlotter {\n  constructor() {\n    // Services\n    this.storageService = new StorageService();\n    this.coordinateTransform = new CoordinateTransform();\n    this.pathCalculator = new PathCalculatorWithWorker(); // Use Web Worker version\n    this.renderingService = new RenderingService();\n    this.eventBus = new EventBus(); // Event-driven architecture for decoupled communication\n    this.animationEngine = new AnimationEngine(this.eventBus); // Animation loop management\n    \n    // Render optimization - batch multiple render requests into single frame\n    this.renderQueued = false;\n    \n    // Batch mode for loading operations (prevents redundant calculations)\n    this._batchMode = false;\n    \n    // Performance optimizations for Phase 7\n    this._lastDisplayedSecond = -1; // Throttle time display updates\n    this._majorWaypointsCache = null; // Cache major waypoint positions\n    this._durationUpdateTimeout = null; // Debounce duration calculations\n    \n    // DOM Elements\n    this.canvas = document.getElementById('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    \n    // Waypoints and path data\n    this.waypoints = []; // Will hold Waypoint model instances\n    this.waypointsById = new Map(); // O(1) lookup by waypoint ID\n    this.pathPoints = [];\n    this.selectedWaypoint = null;\n    this.isDragging = false;\n    this.hasDragged = false; // Track if mouse actually moved during drag\n    this.dragOffset = { x: 0, y: 0 };\n    \n    // Animation state now managed by AnimationEngine service\n    // Access via: this.animationEngine.state\n    \n    // Style settings\n    this.styles = {\n      pathColor: '#FF6B6B',\n      pathThickness: 3,\n      pathStyle: 'solid', // solid, dashed, dotted\n      pathShape: 'line', // line, squiggle, randomised\n      markerStyle: 'dot', // dot, square, flag, none\n      dotColor: '#FF6B6B',\n      dotSize: RENDERING.DEFAULT_DOT_SIZE,\n      beaconStyle: 'pulse', // none, pulse, ripple\n      beaconColor: '#FF6B6B',\n      labelMode: 'none', // none, on, fade, persist\n      labelPosition: 'auto', // auto, top, right, bottom, left\n      pathHead: {\n        style: 'arrow', // dot, arrow, custom, none\n        color: '#111111',\n        size: 8,\n        image: null, // For custom image\n        rotation: 0 // Automatically calculated based on path direction\n      }\n    };\n    \n    // Beacon animation state\n    this.beaconAnimation = {\n      pulsePhase: 0,\n      ripples: []\n    };\n    \n    // Background layer state\n    this.background = {\n      image: null,\n      overlay: 0,        // -100 (black) .. 0 (none) .. 100 (white)\n      fit: 'fit'         // 'fit' | 'fill'\n    };\n    \n    // Offscreen canvas for vector layer compositing\n    this.vectorCanvas = null;\n    \n    // Label management\n    this.labels = {\n      active: [],       // Currently visible labels\n      fadeTime: RENDERING.LABEL_FADE_TIME    // Fade duration in ms for 'fade' mode\n    };\n    \n    // UI Elements\n    this.elements = {\n      canvas: document.getElementById('canvas'),\n      waypoints: document.getElementById('waypoints-tab'),\n      settings: document.getElementById('settings-tab'),\n      tabBtns: document.querySelectorAll('.tab-btn'),\n      waypointList: document.getElementById('waypoint-list'),\n      bgUploadBtn: document.getElementById('bg-upload-btn'),\n      bgUpload: document.getElementById('bg-upload'),\n      bgOverlay: document.getElementById('bg-overlay'),\n      bgOverlayValue: document.getElementById('bg-overlay-value'),\n      bgFitToggle: document.getElementById('bg-fit-toggle'),\n      playBtn: document.getElementById('play-btn'),\n      pauseBtn: document.getElementById('pause-btn'),\n      skipStartBtn: document.getElementById('skip-start-btn'),\n      skipEndBtn: document.getElementById('skip-end-btn'),\n      timelineSlider: document.getElementById('timeline-slider'),\n      currentTime: document.getElementById('current-time'),\n      totalTime: document.getElementById('total-time'),\n      // animationMode: document.getElementById('animation-mode'), // Removed from UI\n      animationSpeed: document.getElementById('animation-speed'),\n      animationSpeedValue: document.getElementById('animation-speed-value'),\n      // animationDuration: document.getElementById('animation-duration'), // Removed from UI\n      // animationDurationValue: document.getElementById('animation-duration-value'), // Removed from UI\n      speedControl: document.getElementById('speed-control'),\n      // durationControl: document.getElementById('duration-control'), // Removed from UI\n      waypointEditor: document.getElementById('waypoint-editor'),\n      waypointEditorPlaceholder: document.getElementById('waypoint-editor-placeholder'),\n      waypointPauseTime: document.getElementById('waypoint-pause-time'),\n      waypointPauseTimeValue: document.getElementById('waypoint-pause-time-value'),\n      pauseTimeControl: document.getElementById('pause-time-control'),\n      splash: document.getElementById('splash'),\n      splashClose: document.getElementById('splash-close'),\n      splashDontShow: document.getElementById('splash-dont-show'),\n      segmentColor: document.getElementById('segment-color'),\n      segmentWidth: document.getElementById('segment-width'),\n      segmentWidthValue: document.getElementById('segment-width-value'),\n      segmentStyle: document.getElementById('segment-style'),\n      dotColor: document.getElementById('dot-color'),\n      dotSize: document.getElementById('dot-size'),\n      dotSizeValue: document.getElementById('dot-size-value'),\n      markerStyle: document.getElementById('marker-style'),\n      pathShape: document.getElementById('path-shape'),\n      editorBeaconStyle: document.getElementById('editor-beacon-style'),\n      editorBeaconColor: document.getElementById('editor-beacon-color'),\n      waypointLabel: document.getElementById('waypoint-label'),\n      labelMode: document.getElementById('label-mode'),\n      labelPosition: document.getElementById('label-position'),\n      helpBtn: document.getElementById('help-btn'),\n      clearBtn: document.getElementById('clear-btn'),\n      announcer: document.getElementById('announcer'),\n      // Path head elements\n      pathHeadStyle: document.getElementById('path-head-style'),\n      pathHeadColor: document.getElementById('path-head-color'),\n      pathHeadSize: document.getElementById('path-head-size'),\n      pathHeadSizeValue: document.getElementById('path-head-size-value'),\n      customHeadControls: document.getElementById('custom-head-controls'),\n      headUploadBtn: document.getElementById('head-upload-btn'),\n      headUpload: document.getElementById('head-upload'),\n      headPreview: document.getElementById('head-preview'),\n      headFilename: document.getElementById('head-filename'),\n      headPreviewImg: document.getElementById('head-preview-img')\n    };\n    \n    this.init();\n  }\n  \n  init() {\n    // Set up canvas size\n    this.resizeCanvas();\n    window.addEventListener('resize', () => {\n      this.resizeCanvas();\n      // Re-render after resize to rescale markers and waypoints\n      this.render();\n    });\n    \n    // Initialize marker style controls\n    this.elements.markerStyle.value = this.styles.markerStyle;\n    \n    // Initialize path shape control\n    this.elements.pathShape.value = this.styles.pathShape;\n    \n    // Initialize path head control values\n    this.elements.pathHeadStyle.value = this.styles.pathHead.style;\n    this.elements.pathHeadColor.value = this.styles.pathHead.color;\n    this.elements.pathHeadSize.value = this.styles.pathHead.size;\n    this.elements.pathHeadSizeValue.textContent = this.styles.pathHead.size;\n    \n    // Show/hide custom image controls based on initial style\n    this.elements.customHeadControls.style.display = \n      this.styles.pathHead.style === 'custom' ? 'block' : 'none';\n    \n    // Initialize animation speed display\n    const defaultDuration = this.animationEngine.state.duration / 1000;\n    this.elements.animationSpeedValue.textContent = defaultDuration + 's';\n    // Slider value will be set via event after UIController is initialized\n    \n    // Slider is now properly synchronized after resets\n    \n    // Set up event listeners\n    this.setupEventListeners();\n    \n    // Set up EventBus listeners for decoupled component communication\n    this.setupEventBusListeners();\n    \n    // Initialize UI Controller and Interaction Handler\n    this.uiController = new UIController(this.elements, this.eventBus);\n    this.interactionHandler = new InteractionHandler(this.canvas, this.eventBus);\n    \n    // Now that UIController is ready, set the initial slider value\n    const defaultSpeed = this.animationEngine.state.speed || ANIMATION.DEFAULT_SPEED;\n    const timestamp = performance.now().toFixed(2);\n    console.log(`\uD83D\uDE80 [${timestamp}ms] [init] Setting initial slider speed:`, defaultSpeed);\n    this.eventBus.emit('ui:slider:update-speed', defaultSpeed);\n    \n    // Set up controller event connections\n    this.setupControllerEventConnections();\n    \n    // Show splash on first load\n    if (this.storageService.shouldShowSplash()) {\n      this.showSplash();\n    }\n    \n    // Load autosave if present\n    this.loadAutosave();\n    \n    // Load default image if no background image is present (for dev testing)\n    if (!this.background.image) {\n      this.loadDefaultImage();\n    }\n    \n    // Set up AnimationEngine waypoint checking callback\n    this.animationEngine.setWaypointCheckCallback((progress) => {\n      const majorWaypoints = this.getMajorWaypointPositions();\n      if (majorWaypoints.length > 0) {\n        this.checkForWaypointWait(progress, majorWaypoints);\n      }\n    });\n    \n    // Set up AnimationEngine event listeners\n    this.setupAnimationEngineListeners();\n    \n    // Set default animation state: at end position, not playing\n    this.animationEngine.seekToProgress(1.0);\n    this.animationEngine.pause();\n    \n    // Initial render\n    this.render();\n    \n    // Start animation loop (runs continuously for rendering)\n    this.startRenderLoop();\n    \n    console.log('Route Plotter v3 initialized');\n  }\n  \n  resizeCanvas() {\n    const rect = this.canvas.getBoundingClientRect();\n    \n    // Controls panel is 80px tall and overlays the bottom of the canvas\n    // We need to subtract this from the usable height\n    const controlsHeight = RENDERING.CONTROLS_HEIGHT;\n    \n    // Use high DPI for better quality (aim for ~4K resolution)\n    const dpr = window.devicePixelRatio || 1;\n    const scale = Math.min(dpr * 2, 3); // Cap at 3x for performance\n    \n    // Set canvas pixel dimensions (high resolution)\n    this.canvas.width = rect.width * scale;\n    this.canvas.height = rect.height * scale;\n    \n    // Store scale for rendering\n    this.canvasScale = scale;\n    \n    // Scale context to match (this happens after canvas resize, so it's reset)\n    this.ctx.scale(scale, scale);\n    \n    // Disable image smoothing for crisp rendering\n    this.ctx.imageSmoothingEnabled = false;\n    \n    // Store the display dimensions for rendering calculations (CSS pixels)\n    // Account for the controls panel overlay\n    this.displayWidth = rect.width;\n    this.displayHeight = rect.height - controlsHeight;\n    \n    // Update coordinate transform service with new canvas dimensions\n    this.coordinateTransform.setCanvasDimensions(this.displayWidth, this.displayHeight);\n    \n    console.log('Canvas resized to:', rect.width, 'x', rect.height, 'at', scale + 'x scale', '(usable height:', this.displayHeight + ')');\n    \n    // Re-render after resize\n    this.render();\n  }\n  \n  setupEventListeners() {\n    // Sidebar tabs\n    document.querySelectorAll('.tab-btn').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        const tabName = e.target.dataset.tab;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));\n        e.target.classList.add('active');\n        \n        // Update tab content\n        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));\n        document.getElementById(`${tabName}-tab`).classList.add('active');\n      });\n    });\n    \n    // ===== SPLASH SCREEN EVENT LISTENERS =====\n    // Must be OUTSIDE commented blocks!\n    console.log('\uD83D\uDD27 [Splash] Setting up event listeners:', {\n      splash: !!this.elements.splash,\n      splashClose: !!this.elements.splashClose,\n      splashDontShow: !!this.elements.splashDontShow\n    });\n    \n    if (this.elements.splashClose) {\n      this.elements.splashClose.addEventListener('click', (e) => {\n        console.log('\uD83C\uDFAF [Splash] Close button clicked');\n        e.stopPropagation();\n        this.hideSplash();\n      });\n    } else {\n      console.error('\u274C [Splash] Close button element not found!');\n    }\n    \n    if (this.elements.splash) {\n      this.elements.splash.addEventListener('click', (e) => {\n        console.log('\uD83C\uDFAF [Splash] Background clicked, target:', e.target.id || e.target.className);\n        if (e.target === this.elements.splash) {\n          console.log('\u2705 [Splash] Closing splash (background click)');\n          this.hideSplash();\n        } else {\n          console.log('\u274C [Splash] Not closing (clicked on content)');\n        }\n      });\n    } else {\n      console.error('\u274C [Splash] Splash element not found!');\n    }\n    \n    /* Canvas events now handled by InteractionHandler\n    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n    this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n    this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));\n    // Drag & drop background image\n    this.canvas.addEventListener('dragover', (e) => { e.preventDefault(); });\n    this.canvas.addEventListener('drop', (e) => {\n      e.preventDefault();\n      const file = e.dataTransfer?.files?.[0];\n      if (file && file.type.startsWith('image/')) {\n        this.loadImageFile(file).then((img) => {\n          this.background.image = img;\n          this.updateImageTransform(img);\n          // Recalculate path with proper image bounds\n          if (this.waypoints.length >= 2) {\n            this.calculatePath();\n          }\n          this.render();\n          this.autoSave();\n          this.announce('Background image loaded');\n        });\n      }\n    });\n    */\n    \n    /* Header and transport controls now handled by UIController\n    this.elements.helpBtn.addEventListener('click', () => this.showSplash());\n    this.elements.clearBtn.addEventListener('click', () => this.clearAll());\n    \n    // Transport controls\n    this.elements.playBtn.addEventListener('click', () => this.play());\n    this.elements.pauseBtn.addEventListener('click', () => this.pause());\n    this.elements.skipStartBtn.addEventListener('click', () => this.skipToStart());\n    this.elements.skipEndBtn.addEventListener('click', () => this.skipToEnd());\n    \n    // Timeline slider\n    this.elements.timelineSlider.addEventListener('input', (e) => {\n      // Seeking clears any waiting state automatically in AnimationEngine\n      // Update progress and time based on slider position via AnimationEngine\n      const progress = e.target.value / ANIMATION.TIMELINE_RESOLUTION;\n      this.animationEngine.seekToProgress(progress);\n    });\n    \n    // Style controls\n    \n    // Waypoint editor controls\n    // Segment color affects path rendering (requires recalculation)\n    this.elements.segmentColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentColor = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Segment width affects path rendering (requires recalculation)\n    this.elements.segmentWidth.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentWidth = parseFloat(e.target.value);\n        this.elements.segmentWidthValue.textContent = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Segment style affects path rendering (requires recalculation)\n    this.elements.segmentStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentStyle = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Path shape control (line, squiggle, randomised) - affects path generation\n    this.elements.pathShape.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.pathShape = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Marker style control (dot, square, flag, none) - visual only\n    this.elements.markerStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.markerStyle = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Dot color and size controls - visual only, no path recalculation\n    this.elements.dotColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.dotColor = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Per-waypoint beacon edits (only apply to major waypoints) - visual only\n    this.elements.editorBeaconStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.beaconStyle = e.target.value;\n        if (this.selectedWaypoint.beaconStyle !== 'ripple') {\n          this.beaconAnimation.ripples = [];\n        }\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Beacon color - visual only\n    this.elements.editorBeaconColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.beaconColor = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Label controls (only enabled for major waypoints) - visual only\n    this.elements.waypointLabel.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.label = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Label display mode - visual only\n    this.elements.labelMode.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.labelMode = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Label position - visual only\n    this.elements.labelPosition.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.labelPosition = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Path Head Style Controls\n    this.elements.pathHeadStyle.addEventListener('change', (e) => {\n      this.styles.pathHead.style = e.target.value;\n      \n      // Show/hide custom image controls based on style selection\n      this.elements.customHeadControls.style.display = \n        e.target.value === 'custom' ? 'block' : 'none';\n      \n      this.autoSave();\n    });\n    \n    this.elements.pathHeadColor.addEventListener('input', (e) => {\n      this.styles.pathHead.color = e.target.value;\n      this.autoSave();\n    });\n    \n    this.elements.pathHeadSize.addEventListener('input', (e) => {\n      this.styles.pathHead.size = parseInt(e.target.value);\n      this.elements.pathHeadSizeValue.textContent = e.target.value;\n      this.autoSave();\n    });\n    \n    // Custom Path Head Image Upload\n    this.elements.headUploadBtn.addEventListener('click', () => {\n      this.elements.headUpload.click();\n    });\n    \n    this.elements.headUpload.addEventListener('change', (e) => {\n      const file = e.target.files?.[0];\n      if (file) {\n        // Load the image\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          const img = new Image();\n          img.onload = () => {\n            // Store the image in the styles\n            this.styles.pathHead.image = img;\n            \n            // Update preview\n            this.elements.headPreview.style.display = 'block';\n            this.elements.headFilename.textContent = file.name;\n            this.elements.headPreviewImg.src = event.target.result;\n            \n            this.autoSave();\n          };\n          img.src = event.target.result;\n        };\n        reader.readAsDataURL(file);\n      }\n    });\n    \n    // Dot size - visual only\n    this.elements.dotSize.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.dotSize = parseInt(e.target.value);\n        this.elements.dotSizeValue.textContent = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Always use constant-speed mode now (animation mode dropdown removed)\n    // Animation speed now handled by UIController -> EventBus -> animation:speed-change event\n    \n    // Waypoint pause time (in waypoint editor)\n    this.elements.waypointPauseTime.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        // Update the selected waypoint's pause time (in milliseconds)\n        const pauseTimeSec = parseFloat(e.target.value);\n        this.selectedWaypoint.pauseTime = pauseTimeSec * 1000;\n        this.elements.waypointPauseTimeValue.textContent = pauseTimeSec + 's';\n        \n        // Automatically set pauseMode based on time value\n        this.selectedWaypoint.pauseMode = pauseTimeSec > 0 ? 'timed' : 'none';\n        \n        this.autoSave();\n      }\n    });\n    \n    // Background controls\n    this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());\n    this.elements.bgUpload.addEventListener('change', (e) => {\n      const file = e.target.files?.[0];\n      if (file) {\n        this.loadImageFile(file).then((img) => {\n          this.background.image = img;\n          this.updateImageTransform(img);\n          // Recalculate path with proper image bounds\n          if (this.waypoints.length >= 2) {\n            this.calculatePath();\n          }\n          this.render();\n          this.autoSave();\n          this.announce('Background image loaded');\n        });\n      }\n    });\n    this.elements.bgOverlay.addEventListener('input', (e) => {\n      this.background.overlay = parseInt(e.target.value);\n      this.elements.bgOverlayValue.textContent = e.target.value;\n      this.render();\n      this.autoSave();\n    });\n    // Toggle fit/fill button\n    this.elements.bgFitToggle.addEventListener('click', (e) => {\n      const currentMode = this.background.fit;\n      const newMode = currentMode === 'fit' ? 'fill' : 'fit';\n      this.background.fit = newMode;\n      \n      // Update coordinateTransform with new fit mode\n      if (this.background.image) {\n        this.updateImageTransform(this.background.image);\n      }\n      \n      // Update button text and data attribute\n      e.target.textContent = newMode === 'fit' ? 'Fit' : 'Fill';\n      e.target.dataset.mode = newMode;\n      \n      console.log('Fit mode changed to:', newMode);\n      // Recalculate path since waypoints need to be repositioned\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.render();\n      this.autoSave();\n    });\n    \n    /* Keyboard shortcuts now handled by InteractionHandler\n    document.addEventListener('keydown', (e) => {\n      const nudgeAmount = e.shiftKey ? 0.05 : 0.01; // 5% or 1%\n      const canvasWidth = this.canvas.width;\n      const canvasHeight = this.canvas.height;\n      \n      switch(e.code) {\n        case 'Space':\n          e.preventDefault();\n          if (this.animationEngine.state.isPlaying && !this.animationEngine.state.isPaused) {\n            this.pause();\n          } else {\n            this.play();\n          }\n          break;\n          \n        case 'KeyJ': // 0.5x speed\n          this.animationEngine.setPlaybackSpeed(0.5);\n          this.announce('Playback speed: 0.5x');\n          break;\n          \n        case 'KeyK': // 1x speed\n          this.animationEngine.setPlaybackSpeed(1);\n          this.announce('Playback speed: 1x');\n          break;\n          \n        case 'KeyL': // 2x speed\n          this.animationEngine.setPlaybackSpeed(2);\n          this.announce('Playback speed: 2x');\n          break;\n          \n        case 'ArrowLeft':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            // Convert current position to canvas, nudge, then back to image coords\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasX = canvasPos.x - nudgeAmount * canvasWidth;\n            const newImgPos = this.canvasToImage(newCanvasX, canvasPos.y);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event for consistent updates\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowRight':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasX = canvasPos.x + nudgeAmount * canvasWidth;\n            const newImgPos = this.canvasToImage(newCanvasX, canvasPos.y);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowUp':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasY = canvasPos.y - nudgeAmount * canvasHeight;\n            const newImgPos = this.canvasToImage(canvasPos.x, newCanvasY);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowDown':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasY = canvasPos.y + nudgeAmount * canvasHeight;\n            const newImgPos = this.canvasToImage(canvasPos.x, newCanvasY);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'Escape':\n          if (this.isDragging) {\n            this.isDragging = false;\n            this.canvas.classList.remove('dragging');\n          }\n          this.selectedWaypoint = null;\n          this.updateWaypointList();\n          this.updateWaypointEditor();\n          break;\n      }\n    });\n    */\n  }\n  \n  /**\n   * Queue a render operation to be executed on next animation frame\n   * Prevents multiple renders in same frame for better performance\n   * Example: Changing 3 waypoint properties = 1 render instead of 3\n   */\n  queueRender() {\n    if (!this.renderQueued) {\n      this.renderQueued = true;\n      requestAnimationFrame(() => {\n        this.render();\n        this.renderQueued = false;\n      });\n    }\n  }\n  \n  /**\n   * Begin batch mode - prevents redundant calculations during bulk operations\n   * Use when adding/loading multiple waypoints at once\n   */\n  beginBatch() {\n    this._batchMode = true;\n  }\n  \n  /**\n   * End batch mode and trigger single update\n   * Calculates path once for all batched changes\n   */\n  endBatch() {\n    this._batchMode = false;\n    // Trigger single update for all batched changes\n    if (this.waypoints.length >= 2) {\n      this.calculatePath();\n    }\n    this.updateWaypointList();\n    this.autoSave();\n    this.queueRender();\n  }\n  \n  /**\n   * Get waypoint by ID with O(1) lookup\n   * @param {string} id - Waypoint ID\n   * @returns {Waypoint|undefined} Waypoint instance or undefined\n   */\n  getWaypointById(id) {\n    return this.waypointsById.get(id);\n  }\n  \n  /**\n   * Add waypoint to ID lookup map\n   * @private\n   * @param {Waypoint} waypoint - Waypoint to add\n   */\n  _addWaypointToMap(waypoint) {\n    this.waypointsById.set(waypoint.id, waypoint);\n  }\n  \n  /**\n   * Remove waypoint from ID lookup map\n   * @private\n   * @param {Waypoint} waypoint - Waypoint to remove\n   */\n  _removeWaypointFromMap(waypoint) {\n    this.waypointsById.delete(waypoint.id);\n  }\n  \n  /**\n   * Set up EventBus listeners for decoupled component communication\n   * Uses event-driven architecture to reduce tight coupling between methods\n   * Events are categorized by change type for optimal performance:\n   * - position-changed: Requires path recalculation (expensive)\n   * - style-changed: Only visual update needed (cheap)\n   * - path-property-changed: Affects path generation (medium cost)\n   */\n  setupEventBusListeners() {\n    // ========== WAYPOINT LIFECYCLE EVENTS ==========\n    \n    /**\n     * waypoint:added - New waypoint created\n     * Triggers: Full update pipeline (path, list, save, render)\n     * Skipped during batch mode for performance\n     */\n    this.eventBus.on('waypoint:added', (waypoint) => {\n      // Validate waypoint instance\n      if (!(waypoint instanceof Waypoint)) {\n        console.error('Invalid waypoint: not a Waypoint instance', waypoint);\n        return;\n      }\n      \n      // Add to ID lookup map for O(1) access\n      this._addWaypointToMap(waypoint);\n      \n      // Invalidate major waypoints cache\n      this._majorWaypointsCache = null;\n      \n      // Skip individual updates during batch operations\n      if (this._batchMode) return;\n      \n      if (this.waypoints.length >= 2) {\n        this.calculatePath(); // Only calculate if we have enough waypoints for a path\n      }\n      this.updateWaypointList();\n      this.autoSave();\n      this.queueRender(); // Batched render\n    });\n    \n    /**\n     * waypoint:deleted - Waypoint removed\n     * Triggers: Full update pipeline\n     */\n    this.eventBus.on('waypoint:deleted', (index) => {\n      // Invalidate major waypoints cache\n      this._majorWaypointsCache = null;\n      \n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      } else {\n        this.pathPoints = []; // Clear path if too few waypoints\n      }\n      this.updateWaypointList();\n      this.updateWaypointEditor();\n      this.autoSave();\n      this.queueRender();\n    });\n    \n    /**\n     * waypoint:selected - Waypoint selected in UI\n     * Triggers: Only UI update\n     */\n    this.eventBus.on('waypoint:selected', (waypoint) => {\n      this.updateWaypointEditor();\n      this.queueRender(); // Highlight selection\n    });\n    \n    // ========== WAYPOINT PROPERTY CHANGE EVENTS ==========\n    \n    /**\n     * waypoint:position-changed - Waypoint moved/dragged\n     * MOST EXPENSIVE: Requires full path recalculation\n     * Note: During drag, path is calculated immediately for smooth feedback\n     * Event is only emitted on mouseup to trigger auto-save once\n     */\n    this.eventBus.on('waypoint:position-changed', (waypoint) => {\n      // Validate position bounds and clamp if needed\n      if (waypoint.imgX < 0 || waypoint.imgX > 1 || \n          waypoint.imgY < 0 || waypoint.imgY > 1) {\n        console.warn('Waypoint position out of bounds, clamping:', waypoint.id);\n        waypoint.setPosition(waypoint.imgX, waypoint.imgY); // Uses Math.max/min internally\n      }\n      \n      this.calculatePath(); // Recalculate path with new position\n      this.updateWaypointList();\n      this.autoSave(); // Debounced in StorageService\n      this.queueRender();\n    });\n    \n    /**\n     * waypoint:style-changed - Visual properties changed\n     * LEAST EXPENSIVE: Only re-render, no path calculation needed\n     * Examples: dot color, dot size, marker style, beacon color, label\n     */\n    this.eventBus.on('waypoint:style-changed', (waypoint) => {\n      this.queueRender(); // Visual update only\n      this.autoSave();\n    });\n    \n    /**\n     * waypoint:path-property-changed - Properties affecting path generation\n     * MEDIUM EXPENSE: Requires path recalculation\n     * Examples: segment color, segment width, segment style, path shape\n     */\n    this.eventBus.on('waypoint:path-property-changed', (waypoint) => {\n      this.calculatePath(); // Path appearance changed\n      this.autoSave();\n      this.queueRender();\n    });\n  }\n  \n  /**\n   * Set up AnimationEngine event listeners\n   * AnimationEngine emits events through EventBus with 'animation:' prefix\n   * Provides event-driven updates for animation state changes\n   * Performance optimization: React to engine events instead of polling\n   */\n  setupAnimationEngineListeners() {\n    // Animation playback events - listen via EventBus\n    this.eventBus.on('animation:play', () => {\n      // Toggle button visibility: hide Play, show Pause\n      this.elements.playBtn.style.display = 'none';\n      this.elements.pauseBtn.style.display = 'inline-block';\n      this.announce('Playing animation');\n    });\n    \n    this.eventBus.on('animation:pause', () => {\n      // Toggle button visibility: show Play, hide Pause\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation paused');\n    });\n    \n    this.eventBus.on('animation:complete', () => {\n      // Show Play button when complete\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation complete');\n    });\n    \n    this.eventBus.on('animation:reset', () => {\n      const timestamp = performance.now().toFixed(2);\n      // Show Play button when reset\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation reset');\n      \n      // CRITICAL FIX: Update slider to match preserved speed after reset\n      const preservedSpeed = this.animationEngine.state.speed;\n      console.log(`\uD83D\uDD27 [${timestamp}ms] [animation:reset] Syncing slider to preserved speed:`, preservedSpeed);\n      console.trace('Reset origin');\n      \n      // CRITICAL FIX #2: Recalculate duration based on preserved speed and path length\n      if (this.pathPoints && this.pathPoints.length > 0) {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const totalDuration = (totalLength / preservedSpeed) * 1000;\n        console.log(`\uD83D\uDCCF [${timestamp}ms] [animation:reset] Recalculating duration - length:`, totalLength.toFixed(1), 'speed:', preservedSpeed, 'duration:', (totalDuration/1000).toFixed(1) + 's');\n        this.animationEngine.setDuration(totalDuration);\n        \n        const durationSec = Math.round(totalDuration / 100) / 10; // Round to 1 decimal\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      \n      // Use event to avoid feedback loop\n      this.eventBus.emit('ui:slider:update-speed', preservedSpeed);\n    });\n    \n    // Waypoint wait events\n    this.eventBus.on('animation:waypointWaitEnd', (waypointIndex) => {\n      console.log('Wait complete at waypoint', waypointIndex);\n      this.announce('Continuing animation');\n    });\n  }\n  \n  /**\n   * Set up event connections for UI Controller and Interaction Handler\n   */\n  setupControllerEventConnections() {\n    // Background events from UIController\n    this.eventBus.on('background:upload', (file) => {\n      this.loadImageFile(file).then(img => {\n        this.background.image = img;\n        this.updateImageTransform(img);\n        if (this.waypoints.length >= 2) {\n          this.calculatePath();\n        }\n        this.render();\n        this.autoSave();\n      });\n    });\n    \n    this.eventBus.on('background:overlay-change', (value) => {\n      this.background.overlay = value;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('background:mode-change', (mode) => {\n      this.background.fit = mode;\n      this.coordinateTransform.fitMode = mode;\n      this.updateImageTransform(this.background.image);\n      this.render();\n      this.autoSave();\n    });\n    \n    // Animation control events from UIController\n    // NOTE: These are command events from UI, NOT the state events emitted by AnimationEngine\n    // AnimationEngine emits 'play', 'pause', etc. internally - we listen to those in setupAnimationEngineListeners()\n    // These listeners are for UI button clicks, keyboard shortcuts, etc.\n    this.eventBus.on('ui:animation:play', () => {\n      console.log('\u25B6\uFE0F  [UI Event] ui:animation:play - progress:', this.animationEngine.getProgress());\n      // If animation is at 100%, restart from beginning\n      if (this.animationEngine.getProgress() >= 1.0) {\n        console.log('\uD83D\uDD04 [UI Event] Progress at 100%, calling reset()');\n        this.animationEngine.reset();\n      }\n      this.animationEngine.play();\n    });\n    this.eventBus.on('ui:animation:pause', () => this.animationEngine.pause());\n    this.eventBus.on('ui:animation:skip-start', () => {\n      console.log('\u23EA [UI Event] ui:animation:skip-start - calling reset()');\n      this.animationEngine.reset();\n    });\n    this.eventBus.on('ui:animation:skip-end', () => this.animationEngine.seekToProgress(1.0));\n    this.eventBus.on('ui:animation:seek', (progress) => this.animationEngine.seekToProgress(progress));\n    this.eventBus.on('animation:speed-change', (speed) => {\n      const timestamp = performance.now().toFixed(2);\n      console.log(`\uD83C\uDFAF [${timestamp}ms] [Event] animation:speed-change - new speed:`, speed, 'px/s');\n      console.trace('Speed change origin');\n      \n      this.animationEngine.setSpeed(speed);\n      \n      // Calculate and display total duration based on path length\n      if (this.pathPoints && this.pathPoints.length > 0) {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const totalDuration = (totalLength / speed) * 1000;\n        console.log('\uD83D\uDCCF [Event] Recalculating duration - length:', totalLength.toFixed(1), 'speed:', speed, 'duration:', (totalDuration/1000).toFixed(1) + 's');\n        this.animationEngine.setDuration(totalDuration);\n        \n        const durationSec = Math.round(totalDuration / 100) / 10; // Round to 1 decimal\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      } else {\n        // No path yet, show estimate\n        const estimatedDuration = 10000 / speed * this.animationEngine.state.speed;\n        const durationSec = Math.round(estimatedDuration / 100) / 10;\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      \n      this.updateTimeDisplay();\n      this.autoSave();\n    });\n    this.eventBus.on('ui:animation:toggle', () => {\n      if (this.animationEngine.state.isPlaying) {\n        this.animationEngine.pause();\n      } else {\n        this.animationEngine.play();\n      }\n    });\n    \n    // Playback speed events from InteractionHandler\n    this.eventBus.on('animation:speed-decrease', () => {\n      const current = this.animationEngine.state.playbackSpeed;\n      this.animationEngine.setPlaybackSpeed(Math.max(0.1, current - 0.1));\n    });\n    \n    this.eventBus.on('animation:speed-reset', () => {\n      this.animationEngine.setPlaybackSpeed(1.0);\n    });\n    \n    this.eventBus.on('animation:speed-increase', () => {\n      const current = this.animationEngine.state.playbackSpeed;\n      this.animationEngine.setPlaybackSpeed(Math.min(10, current + 0.1));\n    });\n    \n    // Waypoint events from InteractionHandler\n    this.eventBus.on('waypoint:add', (data) => {\n      const waypoint = data.isMajor ? \n        Waypoint.createMajor(data.imgX, data.imgY) : \n        Waypoint.createMinor(data.imgX, data.imgY);\n      \n      // Copy properties from last waypoint if exists\n      if (this.waypoints.length > 0) {\n        const lastWaypoint = this.waypoints[this.waypoints.length - 1];\n        waypoint.copyPropertiesFrom(lastWaypoint);\n      }\n      \n      this.waypoints.push(waypoint);\n      this._addWaypointToMap(waypoint);\n      this.eventBus.emit('waypoint:added', waypoint);\n    });\n    \n    this.eventBus.on('waypoint:position-changed', (data) => {\n      const { waypoint, imgX, imgY, isDragging } = data;\n      waypoint.imgX = imgX;\n      waypoint.imgY = imgY;\n      \n      if (!isDragging) {\n        this.autoSave();\n      }\n      \n      this.eventBus.emit('waypoint:position-updated', waypoint);\n    });\n    \n    this.eventBus.on('waypoint:selected', (waypoint) => {\n      this.selectedWaypoint = waypoint;\n      this.interactionHandler?.setSelectedWaypoint(waypoint);\n      this.uiController?.updateWaypointEditor(waypoint);\n      this.updateWaypointList();\n    });\n    \n    this.eventBus.on('waypoint:deleted', (waypoint) => {\n      this.deleteWaypoint(waypoint);\n    });\n    \n    this.eventBus.on('waypoint:delete-selected', () => {\n      if (this.selectedWaypoint) {\n        this.deleteWaypoint(this.selectedWaypoint);\n        this.selectedWaypoint = null;\n      }\n    });\n    \n    this.eventBus.on('waypoints:clear-all', () => {\n      this.clearAll();\n    });\n    \n    // Waypoint reordering from UIController drag-and-drop\n    this.eventBus.on('waypoints:reordered', (newOrder) => {\n      // Find all major waypoints and update their order\n      const allWaypoints = [...this.waypoints];\n      const minorWaypoints = allWaypoints.filter(wp => !wp.isMajor);\n      \n      // Rebuild waypoints array with new major order, keeping minors in place\n      this.waypoints = [];\n      let majorIndex = 0;\n      \n      allWaypoints.forEach(wp => {\n        if (wp.isMajor) {\n          this.waypoints.push(newOrder[majorIndex]);\n          majorIndex++;\n        } else {\n          this.waypoints.push(wp);\n        }\n      });\n      \n      // Recalculate path and update\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.updateWaypointList();\n      this.autoSave();\n      this.render();\n    });\n    \n    // Coordinate conversion callbacks\n    this.eventBus.on('coordinate:canvas-to-image', (data, callback) => {\n      const result = this.canvasToImage(data.canvasX, data.canvasY);\n      if (callback) callback(result);\n    });\n    \n    this.eventBus.on('coordinate:image-to-canvas', (data, callback) => {\n      const result = this.imageToCanvas(data.imgX, data.imgY);\n      if (callback) callback(result);\n    });\n    \n    this.eventBus.on('waypoint:check-at-position', (pos, callback) => {\n      const waypoint = this.findWaypointAt(pos.x, pos.y);\n      if (callback) callback(waypoint);\n    });\n    \n    // Help events\n    this.eventBus.on('help:toggle', () => {\n      if (this.elements.splash.style.display === 'none' || \n          this.elements.splash.style.display === '') {\n        this.showSplash();\n      } else {\n        this.hideSplash();\n      }\n    });\n    \n    // Path head style events\n    this.eventBus.on('pathhead:style-changed', (style) => {\n      this.styles.pathHead.style = style;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('pathhead:color-changed', (color) => {\n      this.styles.pathHead.color = color;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('pathhead:size-changed', (size) => {\n      this.styles.pathHead.size = size;\n      this.render();\n      this.autoSave();\n    });\n  }\n  \n  /* Mouse handlers now managed by InteractionHandler\n  handleMouseDown(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint\n    const clickedWaypoint = this.findWaypointAt(x, y);\n    \n    if (clickedWaypoint) {\n      this.selectedWaypoint = clickedWaypoint;\n      this.isDragging = true;\n      this.hasDragged = false; // Reset drag flag\n      // Store canvas offset for smooth dragging\n      const wpCanvas = this.imageToCanvas(clickedWaypoint.imgX, clickedWaypoint.imgY);\n      this.dragOffset.x = x - wpCanvas.x;\n      this.dragOffset.y = y - wpCanvas.y;\n      this.canvas.classList.add('dragging');\n      \n      // Emit selection event (updates editor UI)\n      this.eventBus.emit('waypoint:selected', clickedWaypoint);\n      this.updateWaypointList(); // Update list to show selection\n      event.preventDefault();\n    }\n  }\n  \n  handleMouseMove(event) {\n    if (this.isDragging && this.selectedWaypoint) {\n      const rect = this.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      \n      // Convert canvas position to image coordinates\n      const canvasX = x - this.dragOffset.x;\n      const canvasY = y - this.dragOffset.y;\n      const imgPos = this.canvasToImage(canvasX, canvasY);\n      this.selectedWaypoint.imgX = imgPos.x;\n      this.selectedWaypoint.imgY = imgPos.y;\n      this.hasDragged = true; // Mark that actual dragging occurred\n      \n      // Update path immediately for smooth visual feedback during drag\n      this.calculatePath();\n      // Batch render calls to prevent excessive rendering (60fps \u2192 ~2-3fps)\n      this.queueRender();\n    }\n  }\n  \n  handleMouseUp(event) {\n    if (this.isDragging) {\n      this.isDragging = false;\n      this.canvas.classList.remove('dragging');\n      \n      // Emit position changed event if waypoint was actually moved\n      // This triggers single auto-save instead of 60+ during drag\n      if (this.hasDragged && this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n        this.hasDragged = false;\n        this.announce('Waypoint moved');\n      }\n      \n      this.updateWaypointList();\n    }\n  }\n  \n  handleCanvasClick(event) {\n    // Don't add waypoint if we actually dragged\n    if (this.hasDragged) {\n      this.hasDragged = false; // Reset for next time\n      return;\n    }\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint for selection\n    const clickedWaypoint = this.findWaypointAt(x, y);\n    if (clickedWaypoint) {\n      this.selectedWaypoint = clickedWaypoint;\n      this.updateWaypointList();\n      this.updateWaypointEditor();\n      return;\n    }\n    \n    // Determine if major or minor waypoint (Shift+Click for minor)\n    const isMajor = !event.shiftKey;\n    \n    // Convert canvas coordinates to normalized image coordinates\n    const imgPos = this.canvasToImage(x, y);\n    \n    // Create waypoint using factory method\n    // Waypoint model handles default properties and validation\n    const waypoint = isMajor\n      ? Waypoint.createMajor(imgPos.x, imgPos.y)\n      : Waypoint.createMinor(imgPos.x, imgPos.y);\n    \n    // Set default label for major waypoints\n    if (isMajor) {\n      waypoint.label = `Waypoint ${this.waypoints.length + 1}`;\n    }\n    \n    // Inherit properties from previous waypoint if exists\n    // This ensures consistent styling across the route\n    if (this.waypoints.length > 0) {\n      const previousWaypoint = this.waypoints[this.waypoints.length - 1];\n      waypoint.copyPropertiesFrom(previousWaypoint);\n    }\n    \n    // Add waypoint to array\n    this.waypoints.push(waypoint);\n    \n    // Emit waypoint added event (triggers path calculation, save, render)\n    // Decoupled approach prevents tight coupling to specific update sequence\n    this.eventBus.emit('waypoint:added', waypoint);\n    \n    this.announce(`${isMajor ? 'Major' : 'Minor'} waypoint added`);\n    console.log(`Added ${isMajor ? 'major' : 'minor'} waypoint at (${x.toFixed(0)}, ${y.toFixed(0)})`);\n  }\n  */ // End of mouse/keyboard handlers now managed by InteractionHandler\n  \n  findWaypointAt(x, y) {\n    const threshold = INTERACTION.WAYPOINT_HIT_RADIUS; // pixels\n    return this.waypoints.find(wp => {\n      // Convert waypoint from image coords to canvas coords for comparison\n      const wpCanvas = this.imageToCanvas(wp.imgX, wp.imgY);\n      const dist = Math.sqrt(Math.pow(wpCanvas.x - x, 2) + Math.pow(wpCanvas.y - y, 2));\n      return dist <= threshold;\n    });\n  }\n  \n  updateWaypointList() {\n    // Delegate to UIController\n    if (this.uiController) {\n      this.uiController.updateWaypointList(this.waypoints);\n      return;\n    }\n    \n    // Fallback if UIController not initialized\n    this.elements.waypointList.innerHTML = '';\n    const majorWaypoints = this.waypoints.filter(wp => wp.isMajor);\n    \n    majorWaypoints.forEach((waypoint, index) => {\n      const item = document.createElement('div');\n      item.className = 'waypoint-item';\n      if (waypoint === this.selectedWaypoint) {\n        item.classList.add('selected');\n      }\n      \n      // Header row\n      const handle = document.createElement('span');\n      handle.className = 'waypoint-item-handle';\n      handle.textContent = '\u2630';\n      const label = document.createElement('span');\n      label.className = 'waypoint-item-label';\n      label.textContent = `Waypoint ${index + 1}`;\n      const delBtn = document.createElement('button');\n      delBtn.className = 'waypoint-item-delete';\n      delBtn.textContent = '\u00D7';\n      \n      item.appendChild(handle);\n      item.appendChild(label);\n      item.appendChild(delBtn);\n      \n      // Selection by clicking header bits\n      const selectWaypoint = (e) => {\n        e.stopPropagation();\n        this.selectedWaypoint = waypoint;\n        this.updateWaypointList();\n        this.updateWaypointEditor();\n      };\n      label.addEventListener('click', selectWaypoint);\n      handle.addEventListener('click', selectWaypoint);\n      item.addEventListener('click', selectWaypoint);\n      \n      // Delete button\n      delBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.deleteWaypoint(waypoint);\n      });\n      \n      this.elements.waypointList.appendChild(item);\n    });\n  }\n  \n  updateWaypointEditor() {\n    if (this.selectedWaypoint) {\n      // Show editor and hide placeholder\n      this.elements.waypointEditor.style.display = 'block';\n      this.elements.waypointEditorPlaceholder.style.display = 'none';\n      \n      // Path properties\n      this.elements.segmentColor.value = this.selectedWaypoint.segmentColor;\n      this.elements.segmentWidth.value = this.selectedWaypoint.segmentWidth;\n      this.elements.segmentWidthValue.textContent = this.selectedWaypoint.segmentWidth;\n      this.elements.segmentStyle.value = this.selectedWaypoint.segmentStyle || 'solid';\n      this.elements.pathShape.value = this.selectedWaypoint.pathShape || 'line';\n      \n      // Marker properties\n      this.elements.markerStyle.value = this.selectedWaypoint.markerStyle || 'dot';\n      this.elements.dotColor.value = this.selectedWaypoint.dotColor || this.selectedWaypoint.segmentColor || this.styles.dotColor;\n      this.elements.dotSize.value = this.selectedWaypoint.dotSize || this.styles.dotSize;\n      this.elements.dotSizeValue.textContent = this.elements.dotSize.value;\n      \n      // Path head properties\n      this.elements.pathHeadStyle.value = this.selectedWaypoint.pathHeadStyle || this.styles.pathHead.style;\n      this.elements.pathHeadColor.value = this.selectedWaypoint.pathHeadColor || this.styles.pathHead.color;\n      this.elements.pathHeadSize.value = this.selectedWaypoint.pathHeadSize || this.styles.pathHead.size;\n      this.elements.pathHeadSizeValue.textContent = this.elements.pathHeadSize.value;\n      this.elements.customHeadControls.style.display = \n        (this.selectedWaypoint.pathHeadStyle || this.styles.pathHead.style) === 'custom' ? 'block' : 'none';\n      // Beacon editor fields\n      if (this.selectedWaypoint.isMajor) {\n        // Enable dot & beacon controls for major\n        this.elements.dotColor.disabled = false;\n        this.elements.dotSize.disabled = false;\n        this.elements.editorBeaconStyle.disabled = false;\n        this.elements.editorBeaconColor.disabled = false;\n        this.elements.editorBeaconStyle.value = this.selectedWaypoint.beaconStyle || this.styles.beaconStyle;\n        this.elements.editorBeaconColor.value = this.selectedWaypoint.beaconColor || this.styles.beaconColor;\n        \n        // Label controls\n        this.elements.waypointLabel.disabled = false;\n        this.elements.labelMode.disabled = false;\n        this.elements.labelPosition.disabled = false;\n        this.elements.waypointLabel.value = this.selectedWaypoint.label || '';\n        this.elements.labelMode.value = this.selectedWaypoint.labelMode || 'none';\n        this.elements.labelPosition.value = this.selectedWaypoint.labelPosition || 'auto';\n        \n        // Enable pause controls for major waypoints\n        this.elements.waypointPauseTime.disabled = false;\n        const pauseTimeSec = (this.selectedWaypoint.pauseTime || 0) / 1000;\n        this.elements.waypointPauseTime.value = pauseTimeSec;\n        this.elements.waypointPauseTimeValue.textContent = pauseTimeSec + 's';\n        this.elements.pauseTimeControl.style.display = 'flex';\n      } else {\n        // Minor waypoint - disable features that don't apply\n        this.elements.dotColor.disabled = true;\n        this.elements.dotSize.disabled = true;\n        this.elements.editorBeaconStyle.disabled = true;\n        this.elements.editorBeaconColor.disabled = true;\n        this.elements.editorBeaconStyle.value = 'none';\n        this.elements.editorBeaconColor.value = this.styles.beaconColor;\n        \n        // Disable label controls for minor waypoints\n        this.elements.waypointLabel.disabled = true;\n        this.elements.labelMode.disabled = true;\n        this.elements.labelPosition.disabled = true;\n        this.elements.waypointLabel.value = '';\n        this.elements.labelMode.value = 'none';\n        this.elements.labelPosition.value = 'auto';\n        \n        // Disable pause controls for minor waypoints\n        this.elements.waypointPauseTime.disabled = true;\n        this.elements.waypointPauseTime.value = 0;\n        this.elements.waypointPauseTimeValue.textContent = '0s';\n        this.elements.pauseTimeControl.style.display = 'none';\n      }\n    } else {\n      // Hide editor and show placeholder\n      this.elements.waypointEditor.style.display = 'none';\n      this.elements.waypointEditorPlaceholder.style.display = 'flex';\n    }\n  }\n  \n  deleteWaypoint(waypoint) {\n    const index = this.waypoints.indexOf(waypoint);\n    if (index > -1) {\n      // Remove from array\n      this.waypoints.splice(index, 1);\n      \n      // Remove from ID lookup map\n      this._removeWaypointFromMap(waypoint);\n      \n      // Clear selection if this waypoint was selected\n      if (this.selectedWaypoint === waypoint) {\n        this.selectedWaypoint = null;\n      }\n      \n      // Emit waypoint deleted event (triggers path recalc, UI update, save)\n      // Event-driven approach ensures consistent update sequence\n      this.eventBus.emit('waypoint:deleted', index);\n      \n      this.announce('Waypoint deleted');\n    }\n  }\n  \n  /**\n   * Update coordinateTransform service when image changes\n   * @param {HTMLImageElement} img - The loaded image\n   */\n  updateImageTransform(img) {\n    if (!img) {\n      // No image - coordinateTransform will use normalized coordinates\n      return;\n    }\n    \n    const width = img.naturalWidth || img.width;\n    const height = img.naturalHeight || img.height;\n    this.coordinateTransform.setImageDimensions(width, height, this.background.fit);\n  }\n  \n  /**\n   * Convert canvas coordinates to normalized image coordinates (0-1)\n   * Delegates to CoordinateTransform service\n   */\n  canvasToImage(canvasX, canvasY) {\n    return this.coordinateTransform.canvasToImage(canvasX, canvasY);\n  }\n  \n  /**\n   * Convert normalized image coordinates (0-1) to canvas coordinates\n   * Delegates to CoordinateTransform service\n   */\n  imageToCanvas(imageX, imageY) {\n    return this.coordinateTransform.imageToCanvas(imageX, imageY);\n  }\n  \n  async calculatePath() {\n    this.pathPoints = [];\n    \n    if (this.waypoints.length < 2) {\n      return;\n    }\n    \n    // Convert waypoint image coordinates to canvas coordinates\n    // This ensures the path is rendered correctly on the canvas\n    const canvasWaypoints = this.waypoints.map(wp => {\n      const canvasPos = this.imageToCanvas(wp.imgX, wp.imgY);\n      return {\n        ...wp,\n        x: canvasPos.x,\n        y: canvasPos.y\n      };\n    });\n    \n    try {\n      // Try to use async Web Worker calculation\n      this.pathPoints = await this.pathCalculator.calculatePathAsync(canvasWaypoints);\n    } catch (error) {\n      console.warn('Async path calculation failed, falling back to sync:', error);\n      // Fall back to synchronous calculation\n      this.pathPoints = this.pathCalculator.calculatePath(canvasWaypoints);\n    }\n    \n    // Performance optimization: Debounce duration calculation\n    // Prevents redundant calculations during multi-waypoint operations\n    if (this._durationUpdateTimeout) {\n      clearTimeout(this._durationUpdateTimeout);\n    }\n    \n    this._durationUpdateTimeout = setTimeout(() => {\n      // Calculate duration based on animation mode\n      if (this.animationEngine.state.mode === 'constant-speed') {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const currentSpeed = this.animationEngine.state.speed;\n        const totalDuration = (totalLength / currentSpeed) * 1000; // Convert to ms\n        \n        console.log('\uD83D\uDEE4\uFE0F  [calculatePath] Updating duration - speed:', currentSpeed, 'px/s, length:', totalLength.toFixed(1), 'px, duration:', (totalDuration/1000).toFixed(1) + 's');\n        \n        this.animationEngine.setDuration(totalDuration);\n        \n        // Update duration display immediately to show correct time\n        const durationSec = Math.round(totalDuration / 100) / 10;\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      // For constant-time mode, duration is already set by the slider\n      \n      // Update total time display\n      this.updateTimeDisplay();\n    }, 50); // Wait 50ms for batch changes\n  }\n  \n  /**\n   * Get positions of major waypoints as normalized progress values (0-1)\n   * Performance optimization: Results are cached and only recalculated when waypoints change\n   * Reduces ~99% of waypoint position calculations (was every frame \u2192 once per change)\n   */\n  getMajorWaypointPositions() {\n    if (this.waypoints.length < 2) return [];\n    \n    // Return cached result if available (99% of calls hit cache)\n    if (this._majorWaypointsCache) {\n      return this._majorWaypointsCache;\n    }\n    \n    // Calculate fresh (only when waypoints change)\n    const majorWaypoints = [];\n    let totalSegments = this.waypoints.length - 1;\n    \n    for (let i = 0; i < this.waypoints.length; i++) {\n      if (this.waypoints[i].isMajor) {\n        // Calculate position as progress (0-1) along the path\n        const progress = i / totalSegments;\n        majorWaypoints.push({ \n          index: i, \n          progress: progress,\n          waypoint: this.waypoints[i]\n        });\n      }\n    }\n    \n    // Cache the result for subsequent calls\n    this._majorWaypointsCache = majorWaypoints;\n    return majorWaypoints;\n  }\n  \n  // Apply smooth easing to entire animation with EXACT waypoint positioning\n  // Gives professional smooth start/stop while preserving waypoint pause precision\n  applyEasing(rawProgress, majorWaypoints) {\n    // Check if we should be EXACTLY at a waypoint with pause\n    for (const wp of majorWaypoints) {\n      // If we're very close to the waypoint's progress and it has a pause setting\n      if (wp.waypoint && \n          wp.waypoint.pauseMode === 'timed' && \n          Math.abs(rawProgress - wp.progress) < 0.001) {\n        // Force exact position at waypoint - no easing\n        return wp.progress;\n      }\n    }\n    \n    // Apply smooth cubic ease-in-out for professional animation feel\n    return Easing.cubicInOut(rawProgress);\n  }\n  \n  // Find which segment of the path we're currently in based on progress\n  findSegmentIndexForProgress(progress) {\n    if (this.waypoints.length < 2) return -1;\n    \n    const totalSegments = this.waypoints.length - 1;\n    // Clamp progress between 0 and 1\n    const clampedProgress = Math.max(0, Math.min(1, progress));\n    \n    // Convert progress to segment index\n    const segmentPosition = clampedProgress * totalSegments;\n    const segmentIndex = Math.floor(segmentPosition);\n    \n    return Math.min(segmentIndex, totalSegments - 1);\n  }\n  \n  /**\n   * Check if we need to wait at any waypoint\n   * Performance optimization: Only checks waypoints within proximity threshold (~80% reduction)\n   */\n  checkForWaypointWait(rawProgress, majorWaypoints) {\n    // Skip if already waiting at a waypoint or not playing\n    if (this.animationEngine.state.isWaitingAtWaypoint || this.animationEngine.state.isPaused) return;\n    \n    // Performance optimization: Only check waypoints within 1% of current progress\n    // Reduces waypoint checking by ~80% (10 waypoints \u2192 ~1-2 checked)\n    const proximityThreshold = 0.01;\n    const nearbyWaypoints = majorWaypoints.filter(wp => \n      Math.abs(rawProgress - wp.progress) < proximityThreshold\n    );\n    \n    // No waypoints nearby - early return (most common case)\n    if (nearbyWaypoints.length === 0) return;\n    \n    // Find which waypoint we're currently at (or between)\n    const segmentIndex = this.findSegmentIndexForProgress(rawProgress);\n    if (segmentIndex < 0) return;\n    \n    // Only log major waypoint info on the first frame (when near the beginning)\n    if (rawProgress < 0.01) {\n      console.log('All major waypoints:', majorWaypoints.map(wp => ({\n        index: wp.index,\n        progress: wp.progress, \n        pauseMode: wp.waypoint && wp.waypoint.pauseMode\n      })));\n    }\n    \n    // First, find the next waypoint we'll encounter\n    let nextWaypoint = null;\n    let minPositiveDistance = Infinity;\n    \n    // Only iterate through nearby waypoints (performance optimization)\n    for (const wp of nearbyWaypoints) {\n      // Skip waypoints we've already waited at\n      if (wp.index === this.animationEngine.state.pauseWaypointIndex) continue;\n      \n      // Extra careful check for pauseMode property and pause time\n      const pauseMode = wp.waypoint && wp.waypoint.pauseMode;\n      const pauseTime = wp.waypoint && wp.waypoint.pauseTime;\n      \n      // Skip if no wait time or pause mode isn't timed\n      if (!wp.waypoint || pauseMode !== 'timed' || !pauseTime || pauseTime <= 0) {\n        continue;\n      }\n      \n      // Calculate exact position values for this waypoint\n      const exactWaypointProgress = wp.index / (this.waypoints.length - 1);\n      \n      // Calculate precise distance from current position to waypoint\n      // We want the closest waypoint ahead of us (positive distance)\n      const distanceToWaypoint = exactWaypointProgress - rawProgress;\n      \n      // Only consider waypoints ahead of us (positive distance) or very close\n      // Use a small negative threshold to catch waypoints we just passed by a tiny bit\n      if (distanceToWaypoint > -0.005 && distanceToWaypoint < minPositiveDistance) {\n        minPositiveDistance = distanceToWaypoint;\n        nextWaypoint = wp;\n      }\n    }\n    \n    // If no valid waypoint found, return\n    if (!nextWaypoint) return;\n    \n    // Calculate exact waypoint position\n    const exactWaypointProgress = nextWaypoint.index / (this.waypoints.length - 1);\n    \n    // More flexible threshold to catch waypoints\n    // This prevents skipping over waypoints during fast animations\n    // 0.005 is 0.5% of the total path length - small enough to be precise but not miss\n    const atOrJustPassedWaypoint = \n      Math.abs(rawProgress - exactWaypointProgress) < 0.005 && \n      rawProgress >= exactWaypointProgress - 0.005;\n    \n    if (atOrJustPassedWaypoint) {\n      console.log(`WAITING at waypoint ${nextWaypoint.index} (progress ${nextWaypoint.progress.toFixed(3)})`, nextWaypoint.waypoint);\n      \n      // Use AnimationEngine to handle waypoint waiting\n      // This centralizes wait logic in the animation service\n      this.animationEngine.startWaypointWait(\n        nextWaypoint.index,\n        nextWaypoint.waypoint.pauseTime\n      );\n          \n      // Announce wait period with duration\n      const waitDuration = nextWaypoint.waypoint.pauseTime / 1000;\n      this.announce(`Waiting at waypoint ${nextWaypoint.index + 1} for ${waitDuration} seconds`);\n    }\n  }\n  \n  // Kept for potential future use\n  continueAnimation() {\n    // Click-to-continue functionality removed\n  }\n  \n  // Easing functions moved to utils/Easing.js for better modularity and performance\n  // Corner slowing and curvature calculation moved to services/PathCalculator.js\n  \n  /**\n   * Play the animation\n   * Delegates to AnimationEngine for state management\n   */\n  play() {\n    if (this.waypoints.length < 2) return;\n    \n    // If animation is finished (at 100%), reset to beginning\n    if (this.animationEngine.state.progress >= 1.0) {\n      this.animationEngine.reset();\n    }\n    \n    // Delegate to AnimationEngine\n    this.animationEngine.play();\n    \n    // UI update handled by AnimationEngine event listeners\n  }\n  \n  /**\n   * Pause the animation\n   * Delegates to AnimationEngine for state management\n   */\n  pause() {\n    // Delegate to AnimationEngine\n    this.animationEngine.pause();\n    \n    // UI update handled by AnimationEngine event listeners\n  }\n  \n  /**\n   * Skip to start of animation\n   * Delegates to AnimationEngine for state management\n   */\n  skipToStart() {\n    this.animationEngine.reset();\n    this.announce('Skipped to start');\n  }\n  \n  /**\n   * Skip to end of animation\n   * Delegates to AnimationEngine for state management\n   */\n  skipToEnd() {\n    this.animationEngine.seekToProgress(1.0);\n    this.announce('Skipped to end');\n  }\n  \n  clearAll() {\n    this.waypoints = []; // Clear Waypoint instances\n    this.waypointsById.clear(); // Clear ID lookup map\n    this.pathPoints = [];\n    this.selectedWaypoint = null;\n    \n    // Reset animation state via AnimationEngine\n    this.animationEngine.reset();\n    this.animationEngine.setDuration(0);\n    \n    this.pause();\n    this.updateTimeDisplay();\n    this.updateWaypointList();\n    console.log('Cleared all waypoints and path');\n  }\n  \n  showSplash() {\n    console.log('\uD83D\uDCD6 [Splash] Showing splash screen');\n    this.elements.splash.style.display = 'flex';\n  }\n  \n  hideSplash() {\n    console.log('\uD83D\uDEAB [Splash] Hiding splash screen');\n    this.elements.splash.style.display = 'none';\n    \n    if (this.elements.splashDontShow.checked) {\n      console.log('\u2705 [Splash] Marking as \"don\\'t show again\"');\n      this.storageService.markSplashShown();\n    }\n  }\n\n  // ----- Accessibility and persistence helpers -----\n  announce(message, priority = 'polite') {\n    const el = document.getElementById('announcer');\n    if (!el) return;\n    el.setAttribute('aria-live', priority);\n    el.textContent = message;\n    // Clear after a short delay so repeated messages are announced\n    setTimeout(() => { el.textContent = ''; }, 2000);\n  }\n\n  autoSave() {\n    try {\n      // Create a clean copy of styles without the pathHead image object\n      const stylesCopy = { ...this.styles };\n      if (stylesCopy.pathHead && stylesCopy.pathHead.image) {\n        stylesCopy.pathHead = { ...stylesCopy.pathHead, image: null };\n      }\n      \n      const data = {\n        coordVersion: 6, // Version tracking for coordinate system changes\n        waypoints: this.waypoints.map(wp => wp.toJSON()), // Serialize Waypoint instances\n        styles: stylesCopy,\n        animationState: {\n          mode: this.animationEngine.state.mode,\n          speed: this.animationEngine.state.speed,\n          duration: this.animationEngine.state.duration,\n          playbackSpeed: this.animationEngine.state.playbackSpeed\n        },\n        background: {\n          overlay: this.background.overlay,\n          fit: this.background.fit\n        }\n      };\n      \n      // Use StorageService with debounced auto-save\n      this.storageService.autoSave(data);\n    } catch (e) {\n      console.error('Error saving state:', e);\n    }\n  }\n  \n  loadAutosave() {\n    console.log('\uD83D\uDCE5 [loadAutosave] Loading saved state...');\n    try {\n      const data = this.storageService.loadAutoSave();\n      if (!data) return;\n      \n      // Check version - if old version, clear and start fresh\n      const COORD_SYSTEM_VERSION = 6; // v6: Changed pause settings from global to per-waypoint\n      if (!data.coordVersion || data.coordVersion < COORD_SYSTEM_VERSION) {\n        console.log('Old data version detected (v' + (data.coordVersion || 1) + '), clearing saved data for v' + COORD_SYSTEM_VERSION);\n        this.storageService.clearAutoSave();\n        return;\n      }\n      \n      // Hydrate waypoints from plain objects to Waypoint instances\n      if (data.waypoints && Array.isArray(data.waypoints)) {\n        // Use batch mode to prevent redundant calculations during loading\n        this.beginBatch();\n        \n        // Convert plain objects to Waypoint instances with validation\n        this.waypoints = data.waypoints\n          .map(wpData => {\n            // Validate waypoint data before hydration\n            if (!Waypoint.validate(wpData)) {\n              console.warn('Invalid waypoint data, skipping:', wpData);\n              return null;\n            }\n            return Waypoint.fromJSON(wpData);\n          })\n          .filter(wp => wp !== null); // Remove invalid waypoints\n        \n        // Populate ID lookup map\n        this.waypoints.forEach(wp => this._addWaypointToMap(wp));\n        \n        // End batch mode - triggers single path calculation\n        this.endBatch();\n        \n        console.log('Loaded waypoints:', this.waypoints.length);\n      }\n      if (data.styles) {\n        this.styles = { ...this.styles, ...data.styles };\n      }\n      \n      // IMPORTANT: Load animation state BEFORE calculating path\n      // This ensures path calculation uses the correct saved speed\n      if (data.animationState) {\n        const savedState = data.animationState;\n        \n        // Restore animation state to AnimationEngine\n        this.animationEngine.setMode(savedState.mode || 'constant-speed');\n        this.animationEngine.setSpeed(savedState.speed || ANIMATION.DEFAULT_SPEED);\n        this.animationEngine.setPlaybackSpeed(savedState.playbackSpeed || 1);\n        // Don't restore duration yet - will be recalculated from path length + speed\n        \n        // Update UI to match loaded values\n        if (this.elements.animationSpeed) {\n          const loadedSpeed = savedState.speed || ANIMATION.DEFAULT_SPEED;\n          console.log('\uD83C\uDFAF [loadAutosave] Setting slider to:', loadedSpeed, '(from savedState.speed:', savedState.speed, ')');\n          // Use event to avoid feedback loop\n          this.eventBus.emit('ui:slider:update-speed', loadedSpeed);\n          // Duration display will be updated after path calculation\n        }\n        \n        // Always show speed control\n        if (this.elements.speedControl) {\n          this.elements.speedControl.style.display = 'flex';\n        }\n      }\n      \n      if (data.background) {\n        this.background.overlay = data.background.overlay ?? this.background.overlay;\n        this.background.fit = data.background.fit ?? this.background.fit;\n        \n        // Update toggle button to match loaded state\n        if (this.elements.bgFitToggle) {\n          this.elements.bgFitToggle.textContent = this.background.fit === 'fit' ? 'Fit' : 'Fill';\n          this.elements.bgFitToggle.dataset.mode = this.background.fit;\n        }\n        // Reflect overlay in UI if controls exist\n        if (this.elements.bgOverlay) {\n          this.elements.bgOverlay.value = String(this.background.overlay);\n          this.elements.bgOverlayValue.textContent = String(this.background.overlay);\n        }\n      }\n      \n      // Calculate path with loaded speed - this will recalculate correct duration\n      this.calculatePath();\n      this.updateWaypointList();\n      \n      // Set animation to end position by default (not playing)\n      this.animationEngine.seekToProgress(1.0);\n      this.animationEngine.pause();\n      \n      this.announce('Previous session restored');\n    } catch (e) {\n      console.warn('No autosave found or failed to load');\n    }\n  }\n  \n  /**\n   * Start the render loop using AnimationEngine\n   * Performance optimizations:\n   * - Conditional rendering: Only renders when state changes (~90% CPU reduction when paused)\n   * - Throttled time display: Updates only when seconds change (~98% fewer DOM updates)\n   * - Delegates animation logic to AnimationEngine service\n   */\n  startRenderLoop() {\n    // Track state changes for conditional rendering\n    let lastProgress = -1;\n    let lastWaitingState = false;\n    \n    // Start AnimationEngine with update callback\n    this.animationEngine.start((state) => {\n      // Performance optimization: Only render when animation state changes\n      const progressChanged = Math.abs(state.progress - lastProgress) > 0.0001;\n      const waitingChanged = state.isWaitingAtWaypoint !== lastWaitingState;\n      const shouldRender = state.isPlaying || progressChanged || waitingChanged;\n      \n      if (shouldRender) {\n        // Sync UI with animation state (minimal updates)\n        this.syncUIWithAnimationState(state);\n        \n        // Render canvas\n        this.render();\n        \n        // Update tracking for next frame\n        lastProgress = state.progress;\n        lastWaitingState = state.isWaitingAtWaypoint;\n      }\n    });\n  }\n  \n  /**\n   * Synchronize UI elements with AnimationEngine state\n   * Performance optimization: Throttles time display updates to once per second\n   */\n  syncUIWithAnimationState(state) {\n    // Update timeline slider (needs high precision)\n    const timelineProgress = state.currentTime / state.duration;\n    this.elements.timelineSlider.value = timelineProgress * ANIMATION.TIMELINE_RESOLUTION;\n    \n    // Update time display only when seconds change (98% fewer DOM updates)\n    const currentSeconds = Math.floor(state.currentTime / 1000);\n    if (currentSeconds !== this._lastDisplayedSecond) {\n      this.updateTimeDisplay(state.currentTime, state.duration);\n      this._lastDisplayedSecond = currentSeconds;\n    }\n  }\n  \n  /**\n   * Update time display with current and total time\n   * @param {number} currentTime - Current time in milliseconds (optional, uses engine state if not provided)\n   * @param {number} duration - Total duration in milliseconds (optional, uses engine state if not provided)\n   */\n  updateTimeDisplay(currentTime = null, duration = null) {\n    const formatTime = (ms) => {\n      const seconds = Math.floor(ms / 1000);\n      const minutes = Math.floor(seconds / 60);\n      const secs = seconds % 60;\n      return `${minutes}:${secs.toString().padStart(2, '0')}`;\n    };\n    \n    // Use provided values or fall back to AnimationEngine state\n    const current = currentTime !== null ? currentTime : this.animationEngine.state.currentTime;\n    const total = duration !== null ? duration : this.animationEngine.state.duration;\n    \n    this.elements.currentTime.textContent = formatTime(current);\n    this.elements.totalTime.textContent = formatTime(total);\n  }\n  \n  render() {\n    const { ctx } = this;\n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    // Safety check - ensure canvas has valid dimensions\n    if (cw <= 0 || ch <= 0) {\n      console.warn('Cannot render to canvas with invalid dimensions:', { width: cw, height: ch });\n      return; // Skip rendering\n    }\n    \n    // Clear\n    ctx.clearRect(0, 0, cw, ch);\n    \n    // 1) Base image\n    this.renderBackground(ctx);\n    // 2) Contrast overlay\n    this.renderOverlay(ctx);\n    \n    // 3-6) Vector + head + UI handles on offscreen canvas\n    const vCanvas = this.getVectorCanvas();\n    \n    // Safety check for vector canvas\n    if (vCanvas.width <= 0 || vCanvas.height <= 0) {\n      console.warn('Vector canvas has invalid dimensions:', { width: vCanvas.width, height: vCanvas.height });\n      return; // Skip drawing vector layer\n    }\n    \n    const vctx = vCanvas.getContext('2d');\n    vctx.clearRect(0, 0, vCanvas.width, vCanvas.height);\n    this.renderVectorLayerTo(vctx);\n    \n    // Safety check before drawing vector layer\n    if (vCanvas.width > 0 && vCanvas.height > 0) {\n      // Blit vector layer to main\n      ctx.drawImage(vCanvas, 0, 0);\n    }\n  }\n\n  // ----- Layer helpers -----\n  getVectorCanvas() {\n    if (!this.vectorCanvas) {\n      this.vectorCanvas = document.createElement('canvas');\n    }\n    \n    // Get canvas dimensions with safety checks\n    const cw = this.displayWidth || this.canvas.width || 100; // Fallback to minimum size\n    const ch = this.displayHeight || this.canvas.height || 100;\n    \n    // Ensure we have valid dimensions > 0\n    const safeWidth = Math.max(1, cw);\n    const safeHeight = Math.max(1, ch);\n    \n    // Only update if dimensions changed\n    if (this.vectorCanvas.width !== safeWidth || this.vectorCanvas.height !== safeHeight) {\n      console.log('Resizing vector canvas to:', safeWidth, 'x', safeHeight);\n      this.vectorCanvas.width = safeWidth;\n      this.vectorCanvas.height = safeHeight;\n      \n      // Disable smoothing on vector canvas too\n      const vctx = this.vectorCanvas.getContext('2d');\n      if (vctx) {\n        vctx.imageSmoothingEnabled = false;\n      }\n    }\n    \n    return this.vectorCanvas;\n  }\n  \n  \n  renderBackground(ctx) {\n    if (!this.background.image) return;\n    \n    const img = this.background.image;\n    const iw = img.naturalWidth || img.width;\n    const ih = img.naturalHeight || img.height;\n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    if (this.background.fit === 'fit') {\n      // Fit: scale image to fit entirely within canvas (may have letterboxing)\n      const scale = Math.min(cw / iw, ch / ih);\n      const dw = Math.round(iw * scale);\n      const dh = Math.round(ih * scale);\n      const dx = Math.floor((cw - dw) / 2);\n      const dy = Math.floor((ch - dh) / 2);\n      // Draw entire source image scaled to fit\n      ctx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);\n    } else {\n      // Fill: enlarge so smaller dimension fills the canvas, center and crop\n      const scale = Math.max(cw / iw, ch / ih);\n      // Calculate which portion of source to show\n      const sw = cw / scale;  // source width to show\n      const sh = ch / scale;  // source height to show\n      const sx = (iw - sw) / 2;  // center horizontally\n      const sy = (ih - sh) / 2;  // center vertically\n      // Draw cropped portion of source image to fill entire canvas\n      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);\n    }\n  }\n  \n  renderOverlay(ctx) {\n    const v = this.background.overlay;\n    if (v === 0) return;\n    \n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    ctx.save();\n    ctx.globalAlpha = Math.min(Math.abs(v) / 100, 0.6);\n    ctx.fillStyle = v < 0 ? '#000' : '#fff';\n    ctx.fillRect(0, 0, cw, ch);\n    ctx.restore();\n  }\n\n  renderVectorLayerTo(targetCtx) {\n    const orig = this.ctx; this.ctx = targetCtx;\n    // 4) Vector layer (paths, labels, waypoints)\n    if (this.pathPoints.length > 0 && this.waypoints.length > 1) {\n      const totalPoints = this.pathPoints.length;\n      // Get current animation progress from AnimationEngine\n      const progress = this.animationEngine.getProgress();\n      const pointsToRender = Math.floor(totalPoints * progress);\n      const segments = this.waypoints.length - 1;\n      const pointsPerSegment = Math.floor(totalPoints / segments);\n      const controllerForSegment = new Array(segments);\n      \n      // Store exact waypoint positions in path points for later use in labels\n      this.waypointPositions = [];\n      this.waypoints.forEach((wp, index) => {\n        if (index < this.waypoints.length - 1) {\n          const exactPointIndex = (index / segments) * totalPoints;\n          this.waypointPositions.push({\n            waypointIndex: index,\n            pointIndex: exactPointIndex\n          });\n        }\n      });\n      \n      let lastMajorIdx = -1;\n      for (let s = 0; s < segments; s++) {\n        if (this.waypoints[s].isMajor) lastMajorIdx = s;\n        controllerForSegment[s] = lastMajorIdx;\n      }\n      for (let i = 1; i < pointsToRender; i++) {\n        const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n        const controllerIdx = controllerForSegment[segmentIndex];\n        const controller = controllerIdx >= 0 ? this.waypoints[controllerIdx] : {\n          segmentColor: this.styles.pathColor,\n          segmentWidth: this.styles.pathThickness,\n          segmentStyle: 'solid',\n          pathShape: 'line'\n        };\n        this.ctx.strokeStyle = controller.segmentColor;\n        this.ctx.lineWidth = controller.segmentWidth;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        this.applyLineStyle(controller.segmentStyle);\n        this.ctx.beginPath();\n        \n        const pathShape = controller.pathShape || 'line';\n        const p1 = this.pathPoints[i - 1];\n        const p2 = this.pathPoints[i];\n        \n        if (pathShape === 'squiggle') {\n          // Create a wavy path using control points\n          const midX = (p1.x + p2.x) / 2;\n          const midY = (p1.y + p2.y) / 2;\n          const perpX = -(p2.y - p1.y) * 0.15; // Perpendicular offset\n          const perpY = (p2.x - p1.x) * 0.15;\n          \n          this.ctx.moveTo(p1.x, p1.y);\n          const wave = Math.sin(i * 0.5) * 0.5;\n          this.ctx.quadraticCurveTo(\n            midX + perpX * wave, \n            midY + perpY * wave,\n            p2.x, p2.y\n          );\n        } else if (pathShape === 'randomised') {\n          // Add random jitter to the path\n          const jitterAmount = 3;\n          const jitteredP1 = {\n            x: p1.x + (Math.random() - 0.5) * jitterAmount,\n            y: p1.y + (Math.random() - 0.5) * jitterAmount\n          };\n          const jitteredP2 = {\n            x: p2.x + (Math.random() - 0.5) * jitterAmount,\n            y: p2.y + (Math.random() - 0.5) * jitterAmount\n          };\n          this.ctx.moveTo(jitteredP1.x, jitteredP1.y);\n          this.ctx.lineTo(jitteredP2.x, jitteredP2.y);\n        } else {\n          // Default line\n          this.ctx.moveTo(p1.x, p1.y);\n          this.ctx.lineTo(p2.x, p2.y);\n        }\n        \n        this.ctx.stroke();\n      }\n      this.ctx.setLineDash([]);\n      \n      // 5) Path head layer\n      if (pointsToRender > 1) {\n        // Get the path head position\n        const headIndex = Math.min(pointsToRender - 1, this.pathPoints.length - 1);\n        const head = this.pathPoints[headIndex];\n        \n        // Calculate direction for rotation (based on previous point)\n        let rotation = 0;\n        if (headIndex > 0) {\n          const prevPoint = this.pathPoints[headIndex - 1];\n          rotation = Math.atan2(head.y - prevPoint.y, head.x - prevPoint.x);\n        }\n        \n        // Store calculated rotation\n        this.styles.pathHead.rotation = rotation;\n        \n        // Draw path head based on style\n        this.drawPathHead(head.x, head.y, rotation);\n      }\n    }\n    \n    // Beacons\n    if (this.pathPoints.length > 0) {\n      // Get current progress from AnimationEngine\n      const currentProgress = this.animationEngine.getProgress();\n      const totalPoints = this.pathPoints.length;\n      \n      // Use exact progress comparison instead of point index for more precision\n      this.waypoints.forEach((waypoint, wpIndex) => {\n        if (waypoint.isMajor) {\n          // Calculate normalized progress for this waypoint\n          const exactWaypointProgress = wpIndex / (this.waypoints.length - 1);\n          \n          // Show beacon EXACTLY when we reach a waypoint (not after)\n          // Use a small threshold to ensure reliable triggering\n          const atWaypoint = Math.abs(currentProgress - exactWaypointProgress) < 0.001;\n          \n          // Show beacon exactly when paused at this waypoint\n          const isPausedHere = this.animationEngine.state.isPaused && \n                              this.animationEngine.state.pauseWaypointIndex === wpIndex;\n          \n          // Show beacon when either exactly at waypoint or paused at it\n          if (atWaypoint || isPausedHere) {\n            // Convert waypoint to canvas coords for drawing beacon\n            const wpCanvas = this.imageToCanvas(waypoint.imgX, waypoint.imgY);\n            this.drawBeacon({ ...waypoint, x: wpCanvas.x, y: wpCanvas.y });\n          }\n        }\n      });\n    }\n    \n    // 6) UI handles (visible markers)\n    this.waypoints.forEach(waypoint => {\n      if (waypoint.isMajor) {\n        // Convert waypoint from image coords to canvas coords\n        const wpCanvas = this.imageToCanvas(waypoint.imgX, waypoint.imgY);\n        const isSelected = waypoint === this.selectedWaypoint;\n        const markerSize = waypoint.dotSize || this.styles.dotSize;\n        const size = isSelected ? markerSize * 1.3 : markerSize;\n        const markerStyle = waypoint.markerStyle || this.styles.markerStyle;\n        \n        // Skip rendering if marker style is 'none'\n        if (markerStyle === 'none') {\n          this.renderLabel(waypoint, wpCanvas.x, wpCanvas.y, 0);\n          return;\n        }\n        \n        this.ctx.fillStyle = waypoint.dotColor || waypoint.segmentColor || this.styles.dotColor;\n        this.ctx.strokeStyle = isSelected ? '#4a90e2' : 'white';\n        this.ctx.lineWidth = isSelected ? 3 : 2;\n        \n        // Draw different marker types\n        if (markerStyle === 'square') {\n          // Square marker\n          this.ctx.beginPath();\n          this.ctx.rect(wpCanvas.x - size, wpCanvas.y - size, size * 2, size * 2);\n          this.ctx.fill();\n          this.ctx.stroke();\n        } else if (markerStyle === 'flag') {\n          // Flag marker\n          this.ctx.beginPath();\n          // Pole\n          this.ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          this.ctx.lineTo(wpCanvas.x, wpCanvas.y + size);\n          // Flag\n          this.ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          this.ctx.lineTo(wpCanvas.x + size * 1.5, wpCanvas.y - size * 1.3);\n          this.ctx.lineTo(wpCanvas.x + size * 1.2, wpCanvas.y - size);\n          this.ctx.lineTo(wpCanvas.x, wpCanvas.y - size * 0.7);\n          this.ctx.closePath();\n          this.ctx.fill();\n          this.ctx.stroke();\n        } else {\n          // Default to dot\n          this.ctx.beginPath();\n          this.ctx.arc(wpCanvas.x, wpCanvas.y, size, 0, Math.PI * 2);\n          this.ctx.fill();\n          this.ctx.stroke();\n        }\n        \n        // Draw labels for major waypoints\n        this.renderLabel(waypoint, wpCanvas.x, wpCanvas.y, size);\n      }\n    });\n    this.ctx = orig;\n  }\n  \n  // Label rendering with positioning and show/hide behavior\n  renderLabel(waypoint, x, y, dotSize) {\n    // Skip if no label text or mode is 'none'\n    if (!waypoint.label || waypoint.labelMode === 'none') return;\n    \n    // Find the true waypoint position in path coordinates\n    const wpIndex = this.waypoints.indexOf(waypoint);\n    const totalPoints = this.pathPoints.length;\n    \n    // Get exact path position for this waypoint\n    let waypointPointIndex = 0;\n    if (wpIndex < this.waypoints.length - 1) {\n      waypointPointIndex = (wpIndex / (this.waypoints.length - 1)) * totalPoints;\n    } else {\n      waypointPointIndex = totalPoints;\n    }\n    \n    // Current animation position in path coordinates\n    const exactCurrentPoint = totalPoints * this.animationEngine.getProgress();\n    \n    // Calculate animation timing parameters\n    // Increased fade time for more noticeable transition\n    const fadeTimeInPoints = totalPoints * 0.02; // 1% of animation = 0.5 seconds\n    let opacity = 0; // Start with zero opacity\n    \n    // Handle different label modes\n    switch (waypoint.labelMode) {\n      case 'on': \n        // Always visible with full opacity\n        opacity = 1.0;\n        break;\n        \n      case 'fade':\n        // Only show label when waypoint is reached\n        if (exactCurrentPoint < waypointPointIndex) return;\n        \n        // Calculate time since waypoint was reached\n        const elapsed = exactCurrentPoint - waypointPointIndex;\n        \n        // Fade in quickly (over 0.25 seconds)\n        if (elapsed <= fadeTimeInPoints / 2) {\n          opacity = Math.min(1.0, elapsed / (fadeTimeInPoints / 2));\n          opacity = Math.pow(opacity, 0.5); // Use square root for faster initial appearance\n        }\n        // Hold during the future waypoint pause time (to be implemented)\n        else if (elapsed <= fadeTimeInPoints * 3) {\n          opacity = 1.0;\n        }\n        // Fade out over 0.5 seconds\n        else if (elapsed <= fadeTimeInPoints * 4) {\n          opacity = 1.0 - Math.min(1.0, (elapsed - fadeTimeInPoints * 3) / fadeTimeInPoints);\n        }\n        // Don't show after fade out\n        else {\n          return;\n        }\n        break;\n        \n      case 'persist':\n        // Start fading in exactly 0.5 seconds before waypoint\n        const timeBeforeWaypoint = waypointPointIndex - exactCurrentPoint;\n        \n        // If we haven't reached the fade-in period yet\n        if (timeBeforeWaypoint > fadeTimeInPoints) return;\n        \n        // If we're in the fade-in period before reaching waypoint\n        if (timeBeforeWaypoint > 0) {\n          // Accelerated fade-in (starts faster)\n          const fadeProgress = 1.0 - (timeBeforeWaypoint / fadeTimeInPoints);\n          opacity = Math.pow(fadeProgress, 0.5); // Square root for quicker initial appearance\n        }\n        // After reaching waypoint, full opacity\n        else {\n          opacity = 1.0;\n        }\n        break;\n        \n      default:\n        return; // Unknown mode\n    }\n    \n    // Debug output to console\n    // if (wpIndex === 0) console.log(`Label ${wpIndex}: opacity=${opacity.toFixed(2)}`);\n    \n    // Save context for restoring later\n    this.ctx.save();\n    \n    // Apply calculated opacity with a higher minimum to make fade-in more noticeable\n    this.ctx.globalAlpha = Math.max(0.15, opacity);\n    \n    // Label style\n    this.ctx.font = 'bold 16px Arial';\n    \n    // Visual effect depends on opacity during fade\n    // Subtle blue highlight during fade-in, white at full opacity\n    const blueAmount = opacity < 1.0 ? Math.max(0, 1 - opacity) * 60 : 0;\n    this.ctx.fillStyle = `rgb(${255-blueAmount}, ${255-blueAmount}, 255)`;\n    this.ctx.strokeStyle = '#000';\n    this.ctx.lineWidth = 3;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    \n    // Add shadow for better visibility\n    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.shadowBlur = 5;\n    this.ctx.shadowOffsetX = 2;\n    this.ctx.shadowOffsetY = 2;\n    \n    // Calculate label position based on position setting\n    const padding = RENDERING.LABEL_OFFSET_X; // Distance from dot edge to label\n    const position = waypoint.labelPosition || 'auto';\n    let labelX = x;\n    let labelY = y;\n    \n    // Adjust position based on setting\n    switch (position) {\n      case 'top':\n        labelY = y - dotSize - padding;\n        break;\n      case 'right':\n        labelX = x + dotSize + padding;\n        this.ctx.textAlign = 'left';\n        break;\n      case 'bottom':\n        labelY = y + dotSize + padding;\n        break;\n      case 'left':\n        labelX = x - dotSize - padding;\n        this.ctx.textAlign = 'right';\n        break;\n      case 'auto':\n      default:\n        // Auto position to avoid going off-screen\n        const cw = this.displayWidth || this.canvas.width;\n        const ch = this.displayHeight || this.canvas.height;\n        \n        // Default to top position\n        labelY = y - dotSize - padding;\n        \n        // Check if too close to top edge\n        if (labelY < 30) {\n          labelY = y + dotSize + padding; // Switch to bottom\n        }\n        \n        // Check if too close to sides\n        if (x < 100) {\n          labelX = x + dotSize + padding;\n          this.ctx.textAlign = 'left';\n        } else if (x > cw - 100) {\n          labelX = x - dotSize - padding;\n          this.ctx.textAlign = 'right';\n        }\n        break;\n    }\n    \n    // Draw text with outline for readability\n    this.ctx.strokeText(waypoint.label, labelX, labelY);\n    this.ctx.fillText(waypoint.label, labelX, labelY);\n    \n    // Restore context to clear shadow and alpha\n    this.ctx.restore();\n  }\n\n  // ----- Assets -----\n  loadImageFile(file) {\n    return new Promise((resolve, reject) => {\n      const url = URL.createObjectURL(file);\n      const img = new Image();\n      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };\n      img.onerror = reject;\n      img.src = url;\n    });\n  }\n  \n  loadDefaultImage() {\n    const img = new Image();\n    img.onload = () => {\n      this.background.image = img;\n      this.updateImageTransform(img);\n      // Recalculate path with proper image bounds now that image is loaded\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.render();\n      console.log('Default image (UoN_map.png) loaded for dev testing');\n    };\n    img.onerror = (err) => {\n      console.warn('Could not load default image:', err);\n      // Continue rendering even without image\n      this.render();\n    };\n    img.src = './UoN_map.png';\n  }\n  \n  applyLineStyle(style) {\n    switch (style) {\n      case 'dotted':\n        this.ctx.setLineDash([2, 6]);\n        break;\n      case 'dashed':\n        this.ctx.setLineDash([10, 5]);\n        break;\n      case 'squiggle':\n        // Approximated with dashed pattern - true squiggle would need complex path manipulation\n        this.ctx.setLineDash([5, 3, 2, 3]);\n        break;\n      case 'solid':\n      default:\n        this.ctx.setLineDash([]);\n        break;\n    }\n  }\n  \n  // Draw the path head based on current style settings\n  drawPathHead(x, y, rotation) {\n    // Safety check for valid coordinates\n    if (!isFinite(x) || !isFinite(y)) {\n      console.warn('Invalid path head coordinates:', {x, y});\n      return;\n    }\n    \n    const pathHead = this.styles.pathHead;\n    const size = pathHead.size;\n    \n    this.ctx.save();\n    this.ctx.translate(x, y);\n    this.ctx.rotate(rotation);\n    \n    switch (pathHead.style) {\n      case 'dot':\n        // Simple dot (filled circle)\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        this.ctx.fill();\n        break;\n        \n      case 'arrow':\n        // Arrow shape\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        \n        // Draw arrow pointing right (rotation will handle direction)\n        this.ctx.moveTo(size, 0);            // Tip\n        this.ctx.lineTo(-size/2, size/2);    // Bottom corner\n        this.ctx.lineTo(-size/4, 0);         // Indentation\n        this.ctx.lineTo(-size/2, -size/2);   // Top corner\n        this.ctx.closePath();\n        this.ctx.fill();\n        break;\n        \n      case 'custom':\n        // Custom image\n        if (pathHead.image) {\n          const imgSize = size * 2; // Make image slightly larger for better visibility\n          // Draw the image centered and rotated\n          this.ctx.drawImage(\n            pathHead.image, \n            -imgSize/2, -imgSize/2,\n            imgSize, imgSize\n          );\n        } else {\n          // Fallback to dot if no image loaded\n          this.ctx.beginPath();\n          this.ctx.fillStyle = pathHead.color;\n          this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n          this.ctx.fill();\n        }\n        break;\n        \n      default:\n        // Default to dot\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    \n    this.ctx.restore();\n  }\n\n  drawBeacon(point) {\n    const bStyle = point.beaconStyle || 'none';\n    const bColor = point.beaconColor || this.styles.beaconColor;\n    if (bStyle === 'none') return;\n    \n    // Safety check for valid coordinates\n    if (!isFinite(point.x) || !isFinite(point.y)) {\n      console.warn('Invalid beacon coordinates:', point);\n      return;\n    }\n    \n    if (bStyle === 'pulse') {\n      // Update pulse phase\n      this.beaconAnimation.pulsePhase = performance.now() * 0.003;\n      \n      // Pulsing dot\n      const pulse = 1 + Math.sin(this.beaconAnimation.pulsePhase) * 0.3;\n      const pulseSize = RENDERING.BEACON_PULSE_SIZE * pulse;\n      \n      // Outer glow\n      this.ctx.beginPath();\n      this.ctx.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);\n      this.ctx.fillStyle = bColor;\n      this.ctx.globalAlpha = RENDERING.BEACON_PULSE_OPACITY;\n      this.ctx.fill();\n      \n      // Update pulse animation state\n      this.beaconAnimation.pulsePhase = (this.beaconAnimation.pulsePhase + 0.1) % (Math.PI * 2);\n    } \n    else if (bStyle === 'ripple') {\n      // Ripple effect - expanding circles that fade out\n      const now = Date.now();\n      \n      // Add a new ripple every interval\n      if (!point.lastRipple || now - point.lastRipple > RENDERING.BEACON_RIPPLE_INTERVAL) {\n        this.beaconAnimation.ripples.push({\n          x: point.x, \n          y: point.y, \n          radius: 0,\n          opacity: 0.5,\n          startTime: now,\n          color: bColor\n        });\n        point.lastRipple = now;\n      }\n      \n      // Draw all active ripples\n      this.beaconAnimation.ripples = this.beaconAnimation.ripples.filter(ripple => {\n        const age = now - ripple.startTime;\n        if (age > RENDERING.BEACON_RIPPLE_DURATION) return false; // Remove old ripples\n        \n        // Calculate current radius with smooth fade-out\n        const radius = age / RENDERING.BEACON_RIPPLE_SPEED;\n        const fadeProgress = age / RENDERING.BEACON_RIPPLE_DURATION;\n        const opacity = 0.5 * (1 - Easing.cubicOut(fadeProgress));\n        \n        // Draw ripple\n        this.ctx.beginPath();\n        this.ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);\n        this.ctx.strokeStyle = ripple.color;\n        this.ctx.lineWidth = 2;\n        this.ctx.globalAlpha = opacity;\n        this.ctx.stroke();\n        \n        return true;\n      });\n      \n      // Draw center dot\n      this.ctx.beginPath();\n      this.ctx.fillStyle = bColor;\n      this.ctx.globalAlpha = 0.8;\n      this.ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);\n      this.ctx.fill();\n    }\n    \n    // Reset global alpha to prevent affecting subsequent draws\n    this.ctx.globalAlpha = 1.0;\n  }\n  \n  /**\n   * Clean up resources and event listeners\n   */\n  destroy() {\n    // Stop animation\n    this.animationEngine?.stop();\n    \n    // Clean up controllers\n    this.interactionHandler?.destroy();\n    this.pathCalculator?.destroy();\n    \n    // Remove all event listeners\n    this.eventBus?.removeAll();\n    \n    // Clear render queue\n    if (this.renderQueued) {\n      cancelAnimationFrame(this.renderQueued);\n      this.renderQueued = false;\n    }\n    \n    // Clear timeouts\n    if (this._durationUpdateTimeout) {\n      clearTimeout(this._durationUpdateTimeout);\n    }\n    \n    // Clear canvases\n    this.ctx?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    if (this.vectorCanvas) {\n      const vctx = this.vectorCanvas.getContext('2d');\n      vctx?.clearRect(0, 0, this.vectorCanvas.width, this.vectorCanvas.height);\n    }\n    \n    // Nullify references for garbage collection\n    this.waypoints = null;\n    this.pathPoints = null;\n    this.selectedWaypoint = null;\n    this.waypointsById = null;\n    this.background = null;\n    this.elements = null;\n    \n    console.log('Route Plotter destroyed');\n  }\n}\n\n// Initialize app when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  window.app = new RoutePlotter();\n});\n"],
  "mappings": "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",
  "names": ["exactWaypointProgress"]
}
