{
  "version": 3,
  "sources": ["../src/utils/CatmullRom.js", "../src/utils/Easing.js", "../src/config/constants.js", "../src/services/StorageService.js", "../src/services/CoordinateTransform.js", "../src/services/PathCalculator.js", "../src/services/PathCalculatorWithWorker.js", "../src/models/AnimationState.js", "../src/services/AnimationEngine.js", "../src/services/RenderingService.js", "../src/core/EventBus.js", "../src/models/Waypoint.js", "../src/controllers/UIController.js", "../src/handlers/InteractionHandler.js", "../src/main.js"],
  "sourcesContent": ["/**\n * Catmull-Rom Spline Implementation\n * Provides smooth curve interpolation through a set of waypoints\n */\nexport class CatmullRom {\n  /**\n   * Interpolates a point on a Catmull-Rom spline between p1 and p2\n   * @param {Object} p0 - Previous control point {x, y}\n   * @param {Object} p1 - Start point of segment {x, y}\n   * @param {Object} p2 - End point of segment {x, y}\n   * @param {Object} p3 - Next control point {x, y}\n   * @param {number} t - Interpolation parameter (0 to 1)\n   * @param {number} tension - Tension value (lower = tighter curves, higher = looser curves)\n   * @returns {Object} Interpolated point {x, y}\n   */\n  static interpolate(p0, p1, p2, p3, t, tension) {\n    \n    const t2 = t * t;\n    const t3 = t2 * t;\n    \n    // Pre-calculate tangent vectors\n    const v0x = (p2.x - p0.x) * tension;\n    const v0y = (p2.y - p0.y) * tension;\n    const v1x = (p3.x - p1.x) * tension;\n    const v1y = (p3.y - p1.y) * tension;\n    \n    // Calculate position using Hermite basis functions\n    const dx = p2.x - p1.x;\n    const dy = p2.y - p1.y;\n    \n    return {\n      x: p1.x + v0x * t + (3 * dx - 2 * v0x - v1x) * t2 + (2 * -dx + v0x + v1x) * t3,\n      y: p1.y + v0y * t + (3 * dy - 2 * v0y - v1y) * t2 + (2 * -dy + v0y + v1y) * t3\n    };\n  }\n  \n  /**\n   * Creates a smooth path through waypoints using Catmull-Rom splines\n   * @param {Array} waypoints - Array of waypoint objects with x and y properties\n   * @param {number} pointsPerSegment - Number of points to generate per segment (default: 30)\n   * @param {number} tension - Tension value (lower = tighter curves, higher = looser curves)\n   * @returns {Array} Array of interpolated points forming the path\n   */\n  static createPath(waypoints, pointsPerSegment = 30, tension = 0.5) {\n    if (waypoints.length < 2) return [];\n    \n    const path = [];\n    const lastIndex = waypoints.length - 1;\n    const step = 1 / pointsPerSegment;\n    \n    // Generate path segments\n    for (let i = 0; i < lastIndex; i++) {\n      const p0 = waypoints[i === 0 ? 0 : i - 1];\n      const p1 = waypoints[i];\n      const p2 = waypoints[i + 1];\n      const p3 = waypoints[i === lastIndex - 1 ? lastIndex : i + 2];\n      \n      // Generate points for this segment\n      for (let j = 0; j < pointsPerSegment; j++) {\n        path.push(CatmullRom.interpolate(p0, p1, p2, p3, j * step, tension));\n      }\n    }\n    \n    // Add the final waypoint\n    path.push(waypoints[lastIndex]);\n    \n    return path;\n  }\n}\n", "/**\n * Essential easing functions for Route Plotter\n * Optimized for performance and clarity\n * \n * All functions: t \u2208 [0,1] \u2192 result \u2208 [0,1]\n */\nexport class Easing {\n  /**\n   * Quadratic ease-in - slow start, accelerating\n   * \n   * Usage: Corner slowing calculations in path generation\n   * Called ~1000+ times per path during reparameterization\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static quadIn(t) {\n    return t * t;\n  }\n  \n  /**\n   * Cubic ease-out - fast start, decelerating\n   * \n   * Usage: Ripple fade effects in beacon animations\n   * Called every frame (60 FPS) for each active ripple\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static cubicOut(t) {\n    const t1 = t - 1;\n    return t1 * t1 * t1 + 1;\n  }\n  \n  /**\n   * Cubic ease-in-out - smooth S-curve\n   * \n   * Usage: Global animation timing for smooth start/stop\n   * Called every frame (60 FPS) in main animation loop\n   * \n   * @param {number} t - Progress (0 to 1)\n   * @returns {number} Eased value\n   */\n  static cubicInOut(t) {\n    return t < 0.5 \n      ? 4 * t * t * t \n      : 1 + 4 * (t - 1) * (t - 1) * (t - 1);\n  }\n}\n", "/**\n * Application-wide constants for Route Plotter v3\n */\n\n// Animation timing and performance\nexport const ANIMATION = {\n  DEFAULT_DURATION: 10000,       // 10 seconds (default duration)\n  DEFAULT_SPEED: 400,            // pixels per second (default animation speed - reasonable starting speed)\n  TARGET_FPS: 60,\n  FRAME_INTERVAL: 1000 / 60,     // ~16.67ms per frame\n  MAX_DELTA_TIME: 100,           // Maximum time jump to prevent huge leaps\n  DEFAULT_PLAYBACK_SPEED: 1,\n  DEFAULT_WAIT_TIME: 0,          // Default waypoint pause time\n  TIMELINE_RESOLUTION: 1000      // Slider steps (0-1000)\n};\n\n// Rendering and visual styles\nexport const RENDERING = {\n  DEFAULT_PATH_COLOR: '#FF6B6B',\n  DEFAULT_PATH_THICKNESS: 3,\n  DEFAULT_DOT_SIZE: 8,\n  MINOR_DOT_SIZE: 4,\n  PATH_HEAD_SIZE: 8,\n  BEACON_PULSE_DURATION: 2000,   // Beacon animation cycle\n  BEACON_MAX_RADIUS: 30,\n  BEACON_PULSE_SIZE: 10,         // Base size for pulse effect\n  BEACON_PULSE_OPACITY: 0.4,     // Opacity for pulse glow\n  BEACON_RIPPLE_DURATION: 1500,  // Ripple lifetime in ms\n  BEACON_RIPPLE_INTERVAL: 500,   // Time between ripples in ms\n  BEACON_RIPPLE_SPEED: 30,       // Ripple expansion speed (pixels per ms)\n  LABEL_OFFSET_X: 10,\n  LABEL_OFFSET_Y: 5,\n  LABEL_FONT_SIZE: 14,\n  LABEL_FADE_TIME: 2000,         // Label fade duration in ms\n  SQUIGGLE_AMPLITUDE: 0.15,      // Wave amplitude for squiggle paths\n  RANDOMISED_JITTER: 3,          // Jitter amount for randomised paths\n  CONTROLS_HEIGHT: 80            // Height of bottom controls panel in pixels\n};\n\n// Path calculation parameters\nexport const PATH = {\n  POINTS_PER_SEGMENT: 100,        // Catmull-Rom interpolation density\n  DEFAULT_TENSION: 0.2,           // Catmull-Rom tension - lower = tighter curves; higher = looser curves\n  TARGET_SPACING: 2,              // Pixels between points after reparameterization\n  MAX_CURVATURE: 0.1,             // Threshold for maximum corner slowing\n  MIN_CORNER_SPEED: 0.2,          // Minimum 20% speed at tight corners (was 40% - now slows more)\n  CORNER_THRESHOLD: 30,           // Degrees for corner detection\n  CORNER_SLOW_RADIUS: 15,\n  CORNER_SLOW_FACTOR: 0.7\n};\n\n// UI interaction thresholds\nexport const INTERACTION = {\n  WAYPOINT_HIT_RADIUS: 15,        // Click detection radius for waypoints (pixels)\n  DRAG_THRESHOLD: 3,              // Minimum pixels to consider a drag\n  DOUBLE_CLICK_TIME: 300,         // Maximum ms between clicks for double-click\n  LONG_PRESS_TIME: 500,           // Time for long press detection\n  ZOOM_SENSITIVITY: 0.001,\n  PAN_SENSITIVITY: 1\n};\n\n// Storage keys for persistence\nexport const STORAGE = {\n  AUTOSAVE_KEY: 'routePlotter_autosave',\n  PREFERENCES_KEY: 'routePlotter_preferences',\n  SPLASH_SHOWN_KEY: 'routePlotter_splashShown',\n  AUTOSAVE_INTERVAL: 1000         // Debounce time for autosave\n};\n\n// Accessibility\nexport const A11Y = {\n  ANNOUNCEMENT_DELAY: 100,        // Delay for screen reader announcements\n  FOCUS_VISIBLE_OUTLINE: '2px solid #0066CC',\n  HIGH_CONTRAST_RATIO: 4.5        // WCAG AA standard\n};\n\n// Z-index layers for rendering order\nexport const LAYERS = {\n  BACKGROUND: 0,\n  OVERLAY: 1,\n  PATH: 2,\n  WAYPOINTS: 3,\n  LABELS: 4,\n  UI_HANDLES: 5,\n  PATH_HEAD: 6,\n  BEACONS: 7\n};\n", "import { STORAGE } from '../config/constants.js';\n\n/**\n * Service for handling localStorage operations\n * Provides methods for saving and loading application state with error handling\n */\nexport class StorageService {\n  constructor() {\n    this.debounceTimer = null;\n    this._lastSerialized = null; // Track last saved state for change detection\n  }\n  \n  /**\n   * Save data to localStorage\n   * @param {string} key - Storage key\n   * @param {any} data - Data to save (will be JSON stringified)\n   * @returns {boolean} True if successful\n   */\n  save(key, data) {\n    try {\n      const serialized = JSON.stringify(data);\n      localStorage.setItem(key, serialized);\n      return true;\n    } catch (error) {\n      console.error(`Failed to save to localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Load data from localStorage\n   * @param {string} key - Storage key\n   * @param {any} defaultValue - Default value if key doesn't exist or parse fails\n   * @returns {any} Parsed data or default value\n   */\n  load(key, defaultValue = null) {\n    try {\n      const item = localStorage.getItem(key);\n      if (item === null) return defaultValue;\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Failed to load from localStorage (${key}):`, error);\n      return defaultValue;\n    }\n  }\n  \n  /**\n   * Remove item from localStorage\n   * @param {string} key - Storage key\n   * @returns {boolean} True if successful\n   */\n  remove(key) {\n    try {\n      localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove from localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Check if a key exists in localStorage\n   * @param {string} key - Storage key\n   * @returns {boolean} True if key exists\n   */\n  exists(key) {\n    try {\n      return localStorage.getItem(key) !== null;\n    } catch (error) {\n      console.error(`Failed to check localStorage (${key}):`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Save application state (debounced with change detection)\n   * @param {Object} state - Application state to save\n   */\n  autoSave(state) {\n    // Skip if nothing changed - pure optimization with no downside\n    const newSerialized = JSON.stringify(state);\n    if (newSerialized === this._lastSerialized) {\n      return; // No changes detected, skip save\n    }\n    \n    // Clear existing timer\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n    \n    // Set new timer\n    this.debounceTimer = setTimeout(() => {\n      this.save(STORAGE.AUTOSAVE_KEY, state);\n      this._lastSerialized = newSerialized; // Remember for next comparison\n      console.log('Auto-saved state');\n    }, STORAGE.AUTOSAVE_INTERVAL);\n  }\n  \n  /**\n   * Load auto-saved application state\n   * @returns {Object|null} Saved state or null\n   */\n  loadAutoSave() {\n    return this.load(STORAGE.AUTOSAVE_KEY, null);\n  }\n  \n  /**\n   * Clear auto-saved state\n   * @returns {boolean} True if successful\n   */\n  clearAutoSave() {\n    return this.remove(STORAGE.AUTOSAVE_KEY);\n  }\n  \n  /**\n   * Save user preferences\n   * @param {Object} preferences - User preferences\n   * @returns {boolean} True if successful\n   */\n  savePreferences(preferences) {\n    return this.save(STORAGE.PREFERENCES_KEY, preferences);\n  }\n  \n  /**\n   * Load user preferences\n   * @returns {Object} User preferences with defaults\n   */\n  loadPreferences() {\n    return this.load(STORAGE.PREFERENCES_KEY, {\n      showSplash: true,\n      theme: 'light',\n      animationSpeed: 1,\n      autoSave: true,\n      keyboardShortcuts: true,\n      highContrast: false\n    });\n  }\n  \n  /**\n   * Check if splash screen should be shown\n   * @returns {boolean} True if splash should be shown\n   */\n  shouldShowSplash() {\n    return !this.exists(STORAGE.SPLASH_SHOWN_KEY);\n  }\n  \n  /**\n   * Mark splash screen as shown\n   */\n  markSplashShown() {\n    this.save(STORAGE.SPLASH_SHOWN_KEY, true);\n  }\n  \n  /**\n   * Export all data as JSON string\n   * @returns {string} JSON string of all localStorage data\n   */\n  exportData() {\n    const data = {\n      autosave: this.loadAutoSave(),\n      preferences: this.loadPreferences(),\n      timestamp: new Date().toISOString()\n    };\n    return JSON.stringify(data, null, 2);\n  }\n  \n  /**\n   * Import data from JSON string\n   * @param {string} jsonString - JSON string to import\n   * @returns {boolean} True if successful\n   */\n  importData(jsonString) {\n    try {\n      const data = JSON.parse(jsonString);\n      \n      if (data.autosave) {\n        this.save(STORAGE.AUTOSAVE_KEY, data.autosave);\n      }\n      \n      if (data.preferences) {\n        this.save(STORAGE.PREFERENCES_KEY, data.preferences);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to import data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Clear all stored data\n   * @returns {boolean} True if successful\n   */\n  clearAll() {\n    try {\n      const keys = [\n        STORAGE.AUTOSAVE_KEY,\n        STORAGE.PREFERENCES_KEY,\n        STORAGE.SPLASH_SHOWN_KEY\n      ];\n      \n      keys.forEach(key => this.remove(key));\n      return true;\n    } catch (error) {\n      console.error('Failed to clear all data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Get storage size estimate\n   * @returns {Promise<Object>} Storage quota and usage\n   */\n  async getStorageInfo() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      try {\n        const estimate = await navigator.storage.estimate();\n        return {\n          usage: estimate.usage,\n          quota: estimate.quota,\n          percentage: (estimate.usage / estimate.quota) * 100\n        };\n      } catch (error) {\n        console.error('Failed to estimate storage:', error);\n      }\n    }\n    return null;\n  }\n}\n", "/**\n * Service for handling coordinate transformations between different coordinate systems\n * Simplified version using 1:1 mapping when canvas matches image dimensions\n * Falls back to complex transformation for fit/fill modes\n */\nexport class CoordinateTransform {\n  constructor() {\n    this.canvasWidth = 0;\n    this.canvasHeight = 0;\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n    this.imageBounds = null;\n    this.fitMode = 'fit'; // 'fit' or 'fill'\n    this.transform = null; // Cached transformation matrix for performance\n  }\n  \n  /**\n   * Update canvas dimensions\n   * @param {number} width - Canvas width\n   * @param {number} height - Canvas height\n   */\n  setCanvasDimensions(width, height) {\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n  }\n  \n  /**\n   * Update image dimensions and calculate display bounds\n   * @param {number} width - Image width\n   * @param {number} height - Image height\n   * @param {string} fitMode - How to fit image ('fit' or 'fill')\n   */\n  setImageDimensions(width, height, fitMode = 'fit') {\n    this.imageWidth = width;\n    this.imageHeight = height;\n    this.fitMode = fitMode;\n    this.calculateImageBounds();\n  }\n  \n  /**\n   * Calculate image display bounds and pre-compute transformation matrix\n   * @private\n   */\n  calculateImageBounds() {\n    if (!this.imageWidth || !this.imageHeight || !this.canvasWidth || !this.canvasHeight) {\n      this.imageBounds = null;\n      this.transform = null;\n      return;\n    }\n    \n    const canvasAspect = this.canvasWidth / this.canvasHeight;\n    const imageAspect = this.imageWidth / this.imageHeight;\n    \n    let scale, x, y, w, h;\n    \n    if (this.fitMode === 'fit') {\n      // Scale image to fit within canvas\n      if (imageAspect > canvasAspect) {\n        // Image is wider - fit to width\n        scale = this.canvasWidth / this.imageWidth;\n      } else {\n        // Image is taller - fit to height\n        scale = this.canvasHeight / this.imageHeight;\n      }\n      \n      w = this.imageWidth * scale;\n      h = this.imageHeight * scale;\n      x = (this.canvasWidth - w) / 2;\n      y = (this.canvasHeight - h) / 2;\n    } else {\n      // Fill mode - scale image to cover canvas\n      if (imageAspect > canvasAspect) {\n        // Image is wider - fit to height\n        scale = this.canvasHeight / this.imageHeight;\n      } else {\n        // Image is taller - fit to width\n        scale = this.canvasWidth / this.imageWidth;\n      }\n      \n      w = this.imageWidth * scale;\n      h = this.imageHeight * scale;\n      x = (this.canvasWidth - w) / 2;\n      y = (this.canvasHeight - h) / 2;\n    }\n    \n    this.imageBounds = { x, y, w, h, scale };\n    \n    // Pre-calculate transformation matrix for fast coordinate conversion\n    // This eliminates repeated calculations on every transform call\n    if (this.fitMode === 'fit') {\n      // Fit mode: simple linear transform\n      this.transform = {\n        // canvasToImage coefficients\n        c2i_scaleX: 1 / w,              // Cache reciprocal (multiply faster than divide)\n        c2i_scaleY: 1 / h,\n        c2i_offsetX: -x / w,            // Pre-calculate offset\n        c2i_offsetY: -y / h,\n        \n        // imageToCanvas coefficients\n        i2c_scaleX: w,\n        i2c_scaleY: h,\n        i2c_offsetX: x,\n        i2c_offsetY: y\n      };\n    } else {\n      // Fill mode: account for cropping\n      const sw = this.canvasWidth / scale;\n      const sh = this.canvasHeight / scale;\n      const sx = (this.imageWidth - sw) / 2;\n      const sy = (this.imageHeight - sh) / 2;\n      \n      // Pre-calculate all the division-heavy operations\n      this.transform = {\n        // canvasToImage coefficients\n        c2i_scaleX: sw / this.canvasWidth / this.imageWidth,\n        c2i_scaleY: sh / this.canvasHeight / this.imageHeight,\n        c2i_offsetX: sx / this.imageWidth,\n        c2i_offsetY: sy / this.imageHeight,\n        \n        // imageToCanvas coefficients\n        i2c_scaleX: this.canvasWidth / sw * this.imageWidth,\n        i2c_scaleY: this.canvasHeight / sh * this.imageHeight,\n        i2c_offsetX: -sx / sw * this.canvasWidth,\n        i2c_offsetY: -sy / sh * this.canvasHeight\n      };\n    }\n  }\n  \n  /**\n   * Convert canvas coordinates to normalized image coordinates (0-1)\n   * Simplified for 1:1 mapping when canvas matches image\n   * @param {number} canvasX - X coordinate on canvas\n   * @param {number} canvasY - Y coordinate on canvas\n   * @returns {{x: number, y: number}} Normalized image coordinates (0-1)\n   */\n  canvasToImage(canvasX, canvasY) {\n    // Check for 1:1 mapping scenario (canvas matches image)\n    if (this.canvasWidth === this.imageWidth && this.canvasHeight === this.imageHeight) {\n      // Direct 1:1 mapping - no transformation needed\n      return {\n        x: canvasX / this.canvasWidth,\n        y: canvasY / this.canvasHeight\n      };\n    }\n    if (!this.transform) {\n      // No image loaded, return normalized canvas coordinates\n      return {\n        x: this.canvasWidth > 0 ? canvasX / this.canvasWidth : 0,\n        y: this.canvasHeight > 0 ? canvasY / this.canvasHeight : 0\n      };\n    }\n    \n    // Use pre-calculated transformation matrix (2.5-4x faster)\n    const t = this.transform;\n    let x = canvasX * t.c2i_scaleX + t.c2i_offsetX;\n    let y = canvasY * t.c2i_scaleY + t.c2i_offsetY;\n    \n    // Fast clamp to 0-1 range (ternary faster than Math.max/min)\n    x = x < 0 ? 0 : (x > 1 ? 1 : x);\n    y = y < 0 ? 0 : (y > 1 ? 1 : y);\n    \n    return { x, y };\n  }\n  \n  /**\n   * Convert normalized image coordinates (0-1) to canvas coordinates\n   * Simplified for 1:1 mapping when canvas matches image\n   * @param {number} imageX - Normalized X coordinate (0-1)\n   * @param {number} imageY - Normalized Y coordinate (0-1)\n   * @returns {{x: number, y: number}} Canvas coordinates\n   */\n  imageToCanvas(imageX, imageY) {\n    // Check for 1:1 mapping scenario (canvas matches image)\n    if (this.canvasWidth === this.imageWidth && this.canvasHeight === this.imageHeight) {\n      // Direct 1:1 mapping - no transformation needed\n      return {\n        x: imageX * this.canvasWidth,\n        y: imageY * this.canvasHeight\n      };\n    }\n    if (!this.transform) {\n      // No image loaded, convert from normalized to canvas coordinates\n      return {\n        x: imageX * this.canvasWidth,\n        y: imageY * this.canvasHeight\n      };\n    }\n    \n    // Use pre-calculated transformation matrix (2.5-4.5x faster)\n    const t = this.transform;\n    return {\n      x: imageX * t.i2c_scaleX + t.i2c_offsetX,\n      y: imageY * t.i2c_scaleY + t.i2c_offsetY\n    };\n  }\n  \n  /**\n   * Check if a point is within the image bounds\n   * @param {number} canvasX - X coordinate on canvas\n   * @param {number} canvasY - Y coordinate on canvas\n   * @returns {boolean} True if point is within image bounds\n   */\n  isWithinImageBounds(canvasX, canvasY) {\n    if (!this.imageBounds) return false;\n    \n    const bounds = this.imageBounds;\n    return canvasX >= bounds.x && \n           canvasX <= bounds.x + bounds.w &&\n           canvasY >= bounds.y && \n           canvasY <= bounds.y + bounds.h;\n  }\n  \n  /**\n   * Get the current image bounds\n   * @returns {Object|null} Image bounds {x, y, w, h, scale} or null\n   */\n  getImageBounds() {\n    return this.imageBounds;\n  }\n  \n  /**\n   * Get display dimensions for the image\n   * @returns {Object} Display dimensions {width, height}\n   */\n  getDisplayDimensions() {\n    if (!this.imageBounds) {\n      return { width: this.canvasWidth, height: this.canvasHeight };\n    }\n    return { width: this.imageBounds.w, height: this.imageBounds.h };\n  }\n  \n  /**\n   * Reset all transformations\n   */\n  reset() {\n    this.canvasWidth = 0;\n    this.canvasHeight = 0;\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n    this.imageBounds = null;\n    this.transform = null;\n    this.fitMode = 'fit';\n  }\n}\n", "import { CatmullRom } from '../utils/CatmullRom.js';\nimport { Easing } from '../utils/Easing.js';\nimport { PATH, RENDERING } from '../config/constants.js';\n\n/**\n * Service for calculating paths through waypoints\n * Handles spline interpolation, reparameterization, and path shape generation\n * Optimized with curvature caching, binary search, and fast approximations\n */\nexport class PathCalculator {\n  constructor() {\n    this._majorWaypointsCache = new Map();\n    this._curvatureCache = new Map();\n    this._useFastCurvature = true; // Use fast approximation by default\n  }\n  \n  /**\n   * Calculate a smooth path through waypoints\n   * @param {Array} waypoints - Array of waypoint objects\n   * @param {Object} options - Path calculation options\n   * @returns {Array} Array of path points\n   */\n  calculatePath(waypoints, options = {}) {\n    if (waypoints.length < 2) {\n      return [];\n    }\n    \n    // Convert waypoints to coordinates for spline calculation\n    const coords = waypoints.map(wp => ({ \n      x: wp.x || wp.imgX, \n      y: wp.y || wp.imgY,\n      isMajor: wp.isMajor\n    }));\n    \n    // Generate initial path using Catmull-Rom splines\n    const roughPath = CatmullRom.createPath(\n      coords, \n      options.pointsPerSegment || PATH.POINTS_PER_SEGMENT,\n      options.tension || PATH.DEFAULT_TENSION\n    );\n    \n    // Apply corner-based velocity modulation for smoother animation\n    const evenPath = this.reparameterizeWithCornerSlowing(\n      roughPath, \n      options.targetSpacing || PATH.TARGET_SPACING\n    );\n    \n    // Apply path shapes and generate stable points\n    return this.applyPathShapes(evenPath, waypoints);\n  }\n  \n  /**\n   * Reparameterize path with corner slowing for smoother animation\n   * Uses curvature-based velocity modulation with binary search optimization\n   * @param {Array} rawPath - Original path points\n   * @param {number} targetSpacing - Target spacing between points\n   * @returns {Array} Reparameterized path\n   */\n  reparameterizeWithCornerSlowing(rawPath, targetSpacing = PATH.TARGET_SPACING) {\n    if (rawPath.length < 2) return rawPath;\n    \n    // Calculate curvature at each point (with caching)\n    const curvatures = this._getCachedCurvature(rawPath);\n    \n    // Build distance array with velocity modulation based on curvature\n    const distances = [0];\n    let totalDistance = 0;\n    \n    for (let i = 1; i < rawPath.length; i++) {\n      const dx = rawPath[i].x - rawPath[i-1].x;\n      const dy = rawPath[i].y - rawPath[i-1].y;\n      const physicalDist = Math.sqrt(dx * dx + dy * dy);\n      \n      // Calculate velocity factor based on curvature\n      const curvature = curvatures[i];\n      const velocityFactor = this._calculateVelocityFactor(curvature);\n      \n      // Adjust distance based on velocity (slower = more time = more \"distance\" in time-space)\n      const adjustedDist = physicalDist / velocityFactor;\n      totalDistance += adjustedDist;\n      distances.push(totalDistance);\n    }\n    \n    // Create evenly-spaced points in adjusted distance space using binary search\n    const evenPath = [];\n    const numPoints = Math.floor(totalDistance / targetSpacing);\n    \n    for (let i = 0; i <= numPoints; i++) {\n      const targetDist = (i / numPoints) * totalDistance;\n      \n      // Binary search for segment (optimized from linear search)\n      const segmentIdx = this._binarySearchSegment(distances, targetDist);\n      \n      // Interpolate within the segment\n      const segStart = distances[segmentIdx];\n      const segEnd = distances[segmentIdx + 1] || segStart;\n      const segLength = segEnd - segStart;\n      const t = segLength > 0 ? (targetDist - segStart) / segLength : 0;\n      \n      const p1 = rawPath[segmentIdx];\n      const p2 = rawPath[segmentIdx + 1] || p1;\n      \n      evenPath.push({\n        x: p1.x + (p2.x - p1.x) * t,\n        y: p1.y + (p2.y - p1.y) * t\n      });\n    }\n    \n    return evenPath;\n  }\n  \n  /**\n   * Calculate velocity factor based on curvature\n   * High curvature = slower, low curvature = faster\n   * @private\n   */\n  _calculateVelocityFactor(curvature) {\n    const maxCurvature = PATH.MAX_CURVATURE;\n    const minSpeed = PATH.MIN_CORNER_SPEED;\n    \n    // Apply quadratic easing for smoother corner slowing\n    const normalizedCurvature = Math.min(curvature / maxCurvature, 1);\n    const easedCurvature = Easing.quadIn(normalizedCurvature);\n    const velocityFactor = Math.max(minSpeed, 1 - easedCurvature * (1 - minSpeed));\n    \n    return velocityFactor;\n  }\n  \n  /**\n   * Binary search to find segment containing target distance\n   * Optimized from O(n) linear search to O(log n)\n   * @private\n   */\n  _binarySearchSegment(distances, targetDist) {\n    let left = 0;\n    let right = distances.length - 1;\n    \n    // Handle edge cases\n    if (targetDist <= distances[0]) return 0;\n    if (targetDist >= distances[right]) return right - 1;\n    \n    while (left < right - 1) {\n      const mid = Math.floor((left + right) / 2);\n      if (distances[mid] < targetDist) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    \n    return left;\n  }\n  \n  /**\n   * Apply path shapes (squiggle, randomised) to the path points\n   * @param {Array} evenPath - Evenly spaced path points\n   * @param {Array} waypoints - Original waypoints with shape information\n   * @returns {Array} Path with shapes applied\n   */\n  applyPathShapes(evenPath, waypoints) {\n    const finalPath = [];\n    \n    // Create stable seed for randomised paths\n    let pathSeed = 0;\n    waypoints.forEach(wp => {\n      pathSeed += (wp.imgX || wp.x || 0) * 1000 + (wp.imgY || wp.y || 0);\n    });\n    \n    // Process each point\n    for (let i = 0; i < evenPath.length; i++) {\n      const point = evenPath[i];\n      \n      // Find which segment this point belongs to\n      const totalSegments = waypoints.length - 1;\n      const segmentProgress = i / evenPath.length;\n      const segmentIndex = Math.min(\n        Math.floor(segmentProgress * totalSegments), \n        totalSegments - 1\n      );\n      \n      // Find the controlling waypoint\n      let controllerIdx = segmentIndex;\n      while (controllerIdx >= 0 && !waypoints[controllerIdx].isMajor) {\n        controllerIdx--;\n      }\n      \n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : null;\n      const pathShape = controller?.pathShape || 'line';\n      \n      // Apply shape transformations\n      if (pathShape === 'randomised') {\n        // Generate stable random offset\n        const pointSeed = pathSeed + i * 100;\n        const rng1 = Math.sin(pointSeed) * 10000;\n        const rng2 = Math.cos(pointSeed) * 10000;\n        const randX = (rng1 - Math.floor(rng1)) * 2 - 1;\n        const randY = (rng2 - Math.floor(rng2)) * 2 - 1;\n        \n        finalPath.push({\n          x: point.x + randX * RENDERING.RANDOMISED_JITTER,\n          y: point.y + randY * RENDERING.RANDOMISED_JITTER,\n          originalX: point.x,\n          originalY: point.y,\n          pathShape: pathShape\n        });\n      } else {\n        // For squiggle and line shapes, store shape info but don't transform yet\n        finalPath.push({\n          ...point,\n          pathShape: pathShape\n        });\n      }\n    }\n    \n    return finalPath;\n  }\n  \n  /**\n   * Find major waypoint positions along the path\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Array} Array of major waypoint positions\n   */\n  getMajorWaypointPositions(waypoints) {\n    // Use cache for performance\n    const cacheKey = this._getCacheKey(waypoints);\n    if (this._majorWaypointsCache.has(cacheKey)) {\n      return this._majorWaypointsCache.get(cacheKey);\n    }\n    \n    const majorWaypoints = [];\n    const totalWaypoints = waypoints.length;\n    \n    waypoints.forEach((wp, index) => {\n      if (wp.isMajor) {\n        const progress = totalWaypoints > 1 ? index / (totalWaypoints - 1) : 0;\n        majorWaypoints.push({\n          index: index,\n          progress: progress,\n          waypoint: wp\n        });\n      }\n    });\n    \n    this._majorWaypointsCache.set(cacheKey, majorWaypoints);\n    return majorWaypoints;\n  }\n  \n  /**\n   * Find which segment a given progress value falls into\n   * @param {number} progress - Progress value from 0 to 1\n   * @param {number} totalWaypoints - Total number of waypoints\n   * @returns {number} Segment index\n   */\n  findSegmentIndexForProgress(progress, totalWaypoints) {\n    if (totalWaypoints < 2) return -1;\n    \n    const segments = totalWaypoints - 1;\n    const rawIndex = progress * segments;\n    return Math.min(Math.floor(rawIndex), segments - 1);\n  }\n  \n  /**\n   * Calculate total path length\n   * @param {Array} pathPoints - Array of path points\n   * @returns {number} Total path length in pixels\n   */\n  calculatePathLength(pathPoints) {\n    if (!pathPoints || pathPoints.length === 0) {\n      return 0;\n    }\n    \n    let totalLength = 0;\n    \n    for (let i = 1; i < pathPoints.length; i++) {\n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      const dx = p2.x - p1.x;\n      const dy = p2.y - p1.y;\n      totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    return totalLength;\n  }\n  \n  /**\n   * Get interpolated position along path at given progress\n   * @param {Array} pathPoints - Array of path points\n   * @param {number} progress - Progress value from 0 to 1\n   * @returns {Object} Point with x and y coordinates\n   */\n  getPointAtProgress(pathPoints, progress) {\n    if (pathPoints.length === 0) return null;\n    if (progress <= 0) return pathPoints[0];\n    if (progress >= 1) return pathPoints[pathPoints.length - 1];\n    \n    const index = Math.floor(progress * (pathPoints.length - 1));\n    const localProgress = (progress * (pathPoints.length - 1)) - index;\n    \n    if (index >= pathPoints.length - 1) {\n      return pathPoints[pathPoints.length - 1];\n    }\n    \n    const p1 = pathPoints[index];\n    const p2 = pathPoints[index + 1];\n    \n    return {\n      x: p1.x + (p2.x - p1.x) * localProgress,\n      y: p1.y + (p2.y - p1.y) * localProgress\n    };\n  }\n  \n  /**\n   * Clear the cache\n   */\n  clearCache() {\n    this._majorWaypointsCache.clear();\n    this._curvatureCache.clear();\n  }\n  \n  /**\n   * Get cached curvature or calculate if not in cache\n   * @private\n   */\n  _getCachedCurvature(path) {\n    const pathKey = this._getPathHash(path);\n    \n    if (!this._curvatureCache.has(pathKey)) {\n      const curvatures = this._useFastCurvature\n        ? this._calculateCurvatureFast(path)\n        : this._calculateCurvatureAccurate(path);\n      this._curvatureCache.set(pathKey, curvatures);\n    }\n    \n    return this._curvatureCache.get(pathKey);\n  }\n  \n  /**\n   * Fast curvature approximation using triangle area method\n   * ~2.5x faster than accurate method with 95% similar results\n   * @private\n   */\n  _calculateCurvatureFast(path) {\n    const curvatures = [];\n    \n    for (let i = 0; i < path.length; i++) {\n      if (i === 0 || i === path.length - 1) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      const p0 = path[i - 1];\n      const p1 = path[i];\n      const p2 = path[i + 1];\n      \n      // Triangle area method (cross product)\n      const area = Math.abs(\n        (p1.x - p0.x) * (p2.y - p0.y) - \n        (p2.x - p0.x) * (p1.y - p0.y)\n      );\n      \n      // Calculate distances\n      const d1 = Math.hypot(p1.x - p0.x, p1.y - p0.y);\n      const d2 = Math.hypot(p2.x - p1.x, p2.y - p1.y);\n      const avgDist = (d1 + d2) / 2;\n      \n      // Approximate curvature\n      curvatures.push(avgDist > 0 ? area / (avgDist * avgDist) : 0);\n    }\n    \n    return curvatures;\n  }\n  \n  /**\n   * Accurate curvature calculation using geometric method\n   * More precise but slower than fast approximation\n   * @private\n   */\n  _calculateCurvatureAccurate(path) {\n    const curvatures = [];\n    \n    for (let i = 0; i < path.length; i++) {\n      if (i === 0 || i === path.length - 1) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      const p0 = path[i - 1];\n      const p1 = path[i];\n      const p2 = path[i + 1];\n      \n      // Calculate vectors\n      const v1x = p1.x - p0.x;\n      const v1y = p1.y - p0.y;\n      const v2x = p2.x - p1.x;\n      const v2y = p2.y - p1.y;\n      \n      // Calculate lengths\n      const len1 = Math.sqrt(v1x * v1x + v1y * v1y);\n      const len2 = Math.sqrt(v2x * v2x + v2y * v2y);\n      \n      if (len1 === 0 || len2 === 0) {\n        curvatures.push(0);\n        continue;\n      }\n      \n      // Normalize vectors\n      const n1x = v1x / len1;\n      const n1y = v1y / len1;\n      const n2x = v2x / len2;\n      const n2y = v2y / len2;\n      \n      // Calculate angle change\n      const crossProduct = n1x * n2y - n1y * n2x;\n      const dotProduct = n1x * n2x + n1y * n2y;\n      const angle = Math.atan2(crossProduct, dotProduct);\n      \n      // Curvature is angle change divided by average segment length\n      const avgLen = (len1 + len2) / 2;\n      const curvature = avgLen > 0 ? Math.abs(angle) / avgLen : 0;\n      \n      curvatures.push(curvature);\n    }\n    \n    return curvatures;\n  }\n  \n  /**\n   * Generate cache key for path\n   * @private\n   */\n  _getPathHash(path) {\n    // Use first, middle, and last points for hash (fast approximation)\n    const len = path.length;\n    if (len < 3) return `${path[0].x},${path[0].y}`;\n    \n    const first = path[0];\n    const mid = path[Math.floor(len / 2)];\n    const last = path[len - 1];\n    \n    return `${first.x},${first.y}|${mid.x},${mid.y}|${last.x},${last.y}|${len}`;\n  }\n  \n  /**\n   * Generate cache key for waypoints\n   * @private\n   */\n  _getCacheKey(waypoints) {\n    return waypoints.map(wp => `${wp.imgX},${wp.imgY},${wp.isMajor}`).join('|');\n  }\n}\n", "/**\n * PathCalculatorWithWorker - Enhanced path calculator using Web Workers\n * Falls back to main thread if workers are not available\n */\n\nimport { PathCalculator } from './PathCalculator.js';\n\nexport class PathCalculatorWithWorker extends PathCalculator {\n  constructor() {\n    super();\n    this.worker = null;\n    this.workerAvailable = false;\n    this.pendingRequests = new Map();\n    this.requestId = 0;\n    \n    this.initWorker();\n  }\n  \n  /**\n   * Initialize Web Worker if available\n   */\n  initWorker() {\n    if (typeof Worker !== 'undefined') {\n      try {\n        // Create worker with module type\n        this.worker = new Worker(\n          new URL('../workers/pathWorker.js', import.meta.url),\n          { type: 'module' }\n        );\n        \n        this.worker.onmessage = this.handleWorkerMessage.bind(this);\n        this.worker.onerror = this.handleWorkerError.bind(this);\n        \n        this.workerAvailable = true;\n        console.log('PathCalculator: Web Worker initialized');\n      } catch (error) {\n        console.warn('PathCalculator: Failed to initialize Web Worker, falling back to main thread', error);\n        this.workerAvailable = false;\n      }\n    } else {\n      console.log('PathCalculator: Web Workers not supported, using main thread');\n      this.workerAvailable = false;\n    }\n  }\n  \n  /**\n   * Handle messages from worker\n   */\n  handleWorkerMessage(event) {\n    const { type, data, id, error } = event.data;\n    \n    const request = this.pendingRequests.get(id);\n    if (!request) {\n      console.warn('PathCalculator: Received message for unknown request', id);\n      return;\n    }\n    \n    this.pendingRequests.delete(id);\n    \n    if (error) {\n      request.reject(new Error(error));\n    } else {\n      request.resolve(data.pathPoints);\n    }\n  }\n  \n  /**\n   * Handle worker errors\n   */\n  handleWorkerError(error) {\n    console.error('PathCalculator: Worker error', error);\n    \n    // Reject all pending requests\n    for (const request of this.pendingRequests.values()) {\n      request.reject(error);\n    }\n    this.pendingRequests.clear();\n    \n    // Disable worker and fall back to main thread\n    this.workerAvailable = false;\n    this.worker = null;\n  }\n  \n  /**\n   * Calculate path using worker if available\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Promise<Array>} Promise resolving to path points\n   */\n  async calculatePathAsync(waypoints) {\n    if (!this.workerAvailable) {\n      // Fall back to synchronous calculation on main thread\n      return Promise.resolve(this.calculatePath(waypoints));\n    }\n    \n    return new Promise((resolve, reject) => {\n      const id = this.requestId++;\n      \n      this.pendingRequests.set(id, { resolve, reject });\n      \n      // Send calculation request to worker\n      this.worker.postMessage({\n        type: 'calculate-path',\n        data: {\n          waypoints: waypoints.map(wp => ({\n            x: wp.x || wp.imgX,\n            y: wp.y || wp.imgY,\n            isMajor: wp.isMajor\n          }))\n        },\n        id: id\n      });\n      \n      // Timeout after 5 seconds\n      setTimeout(() => {\n        if (this.pendingRequests.has(id)) {\n          this.pendingRequests.delete(id);\n          reject(new Error('Path calculation timed out'));\n        }\n      }, 5000);\n    });\n  }\n  \n  /**\n   * Override the synchronous method to try async first\n   * @param {Array} waypoints - Array of waypoints\n   * @returns {Array} Path points\n   */\n  calculatePath(waypoints) {\n    // If worker is available and we're not in a rush, use it\n    if (this.workerAvailable && !this.isSynchronousContext()) {\n      console.warn('PathCalculator: Synchronous calculatePath called but worker is available. Consider using calculatePathAsync.');\n    }\n    \n    // Fall back to parent implementation\n    return super.calculatePath(waypoints);\n  }\n  \n  /**\n   * Check if we're in a context that requires synchronous execution\n   */\n  isSynchronousContext() {\n    // Check if we're in an animation frame or other time-critical context\n    // This is a heuristic - you might want to make this more sophisticated\n    return typeof requestAnimationFrame !== 'undefined' && \n           performance.now() % 16.67 < 1; // Roughly in an animation frame\n  }\n  \n  /**\n   * Clean up worker when done\n   */\n  destroy() {\n    if (this.worker) {\n      // Reject all pending requests\n      for (const request of this.pendingRequests.values()) {\n        request.reject(new Error('PathCalculator destroyed'));\n      }\n      this.pendingRequests.clear();\n      \n      // Terminate worker\n      this.worker.terminate();\n      this.worker = null;\n      this.workerAvailable = false;\n    }\n  }\n}\n", "import { ANIMATION } from '../config/constants.js';\n\n/**\n * Model for managing animation state\n * Encapsulates all animation-related properties and provides methods for state updates\n */\nexport class AnimationState {\n  constructor() {\n    this.reset();\n  }\n  \n  /**\n   * Reset animation to initial state\n   * Note: Preserves speed setting - only resets playback position\n   */\n  reset() {\n    // Preserve current speed if already set, otherwise use default\n    const preservedSpeed = this.speed || ANIMATION.DEFAULT_SPEED;\n    \n    console.log('\uD83D\uDD04 [AnimationState.reset()] BEFORE - speed:', this.speed, 'preservedSpeed:', preservedSpeed);\n    \n    this.isPlaying = false;\n    this.progress = 0;                    // 0 to 1\n    this.currentTime = 0;                 // in milliseconds\n    this.duration = ANIMATION.DEFAULT_DURATION;\n    this.mode = 'constant-speed';         // or 'constant-time'\n    this.speed = preservedSpeed;          // Preserve user's speed setting\n    this.playbackSpeed = ANIMATION.DEFAULT_PLAYBACK_SPEED;\n    \n    console.log('\u2705 [AnimationState.reset()] AFTER - speed:', this.speed, 'duration:', this.duration);\n    \n    // Pause states\n    this.isPaused = false;                // User-triggered pause\n    this.isWaitingAtWaypoint = false;     // Waypoint wait state\n    this.pauseWaypointIndex = -1;         // Current waypoint index\n    this.pauseStartTime = 0;              // When wait began\n    this.pauseEndTime = 0;                // When wait should end\n    this.waypointProgressSnapshot = 0;    // Progress frozen during wait\n    \n    // Timing\n    this.lastTime = 0;\n  }\n  \n  /**\n   * Start animation playback\n   */\n  play() {\n    this.isPlaying = true;\n    this.isPaused = false;\n    this.lastTime = performance.now();\n  }\n  \n  /**\n   * Pause animation playback\n   */\n  pause() {\n    this.isPaused = true;\n  }\n  \n  /**\n   * Stop animation and reset\n   */\n  stop() {\n    this.isPlaying = false;\n    this.isPaused = false;\n    this.progress = 0;\n    this.currentTime = 0;\n  }\n  \n  /**\n   * Toggle between play and pause\n   */\n  togglePlayPause() {\n    if (this.isPlaying && !this.isPaused) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  \n  /**\n   * Set animation progress directly\n   * @param {number} progress - Progress value from 0 to 1\n   */\n  setProgress(progress) {\n    this.progress = Math.max(0, Math.min(1, progress));\n    this.currentTime = this.progress * this.duration;\n  }\n  \n  /**\n   * Set animation time directly\n   * @param {number} time - Time in milliseconds\n   */\n  setTime(time) {\n    this.currentTime = Math.max(0, Math.min(this.duration, time));\n    this.progress = this.duration > 0 ? this.currentTime / this.duration : 0;\n  }\n  \n  /**\n   * Update animation mode\n   * @param {string} mode - 'constant-speed' or 'constant-time'\n   */\n  setMode(mode) {\n    if (mode === 'constant-speed' || mode === 'constant-time') {\n      this.mode = mode;\n    } else {\n      throw new Error(`Invalid animation mode: ${mode}`);\n    }\n  }\n  \n  /**\n   * Start waiting at a waypoint\n   * @param {number} waypointIndex - Index of the waypoint\n   * @param {number} waitDuration - Duration to wait in milliseconds\n   * @param {number} progressSnapshot - Progress value to freeze at\n   */\n  startWaypointWait(waypointIndex, waitDuration, progressSnapshot) {\n    this.isWaitingAtWaypoint = true;\n    this.pauseWaypointIndex = waypointIndex;\n    this.pauseStartTime = performance.now();\n    this.pauseEndTime = this.pauseStartTime + waitDuration;\n    this.waypointProgressSnapshot = progressSnapshot;\n  }\n  \n  /**\n   * End waypoint wait\n   */\n  endWaypointWait() {\n    this.isWaitingAtWaypoint = false;\n    this.pauseWaypointIndex = -1;\n    this.waypointProgressSnapshot = 0;\n  }\n  \n  /**\n   * Check if currently waiting at a waypoint\n   * @returns {boolean}\n   */\n  isWaiting() {\n    return this.isWaitingAtWaypoint;\n  }\n  \n  /**\n   * Get effective progress (considering waypoint waits)\n   * @returns {number} Progress value from 0 to 1\n   */\n  getEffectiveProgress() {\n    return this.isWaitingAtWaypoint ? this.waypointProgressSnapshot : this.progress;\n  }\n  \n  /**\n   * Clone current state\n   * @returns {Object} Plain object with current state\n   */\n  toJSON() {\n    return {\n      isPlaying: this.isPlaying,\n      progress: this.progress,\n      currentTime: this.currentTime,\n      duration: this.duration,\n      mode: this.mode,\n      speed: this.speed,\n      playbackSpeed: this.playbackSpeed,\n      isPaused: this.isPaused,\n      isWaitingAtWaypoint: this.isWaitingAtWaypoint,\n      pauseWaypointIndex: this.pauseWaypointIndex\n    };\n  }\n  \n  /**\n   * Restore state from JSON\n   * @param {Object} data - State data to restore\n   */\n  fromJSON(data) {\n    Object.assign(this, data);\n  }\n}\n", "import { ANIMATION } from '../config/constants.js';\nimport { AnimationState } from '../models/AnimationState.js';\n\n/**\n * Service for managing animation playback\n * Handles timing, waypoint waits, and frame rate control\n */\nexport class AnimationEngine {\n  constructor(eventBus = null) {\n    this.eventBus = eventBus;\n    this.state = new AnimationState();\n    this.animationFrameId = null;\n    this.lastFrameTime = 0;\n    this.onUpdate = null; // Callback for animation updates\n  }\n  \n  /**\n   * Start the animation loop\n   * @param {Function} onUpdate - Callback function called on each frame\n   */\n  start(onUpdate) {\n    if (this.animationFrameId) {\n      this.stop();\n    }\n    \n    this.onUpdate = onUpdate;\n    this.state.play();\n    this.lastFrameTime = 0;\n    \n    const loop = (timestamp) => {\n      this.animationFrameId = requestAnimationFrame(loop);\n      \n      // Calculate time since last frame\n      const elapsed = timestamp - this.lastFrameTime;\n      \n      // Only update at target frame rate\n      if (elapsed > ANIMATION.FRAME_INTERVAL) {\n        // Adjust for frame interval to prevent lag accumulation\n        this.lastFrameTime = timestamp - (elapsed % ANIMATION.FRAME_INTERVAL);\n        \n        if (this.state.isPlaying && !this.state.isPaused) {\n          // Cap deltaTime to prevent huge jumps\n          const deltaTime = Math.min(elapsed, ANIMATION.MAX_DELTA_TIME) * this.state.playbackSpeed;\n          \n          // Update animation state\n          this.updateAnimation(deltaTime, timestamp);\n        }\n        \n        // Call update callback\n        if (this.onUpdate) {\n          this.onUpdate(this.state);\n        }\n        \n        // Emit update event\n        this.emit('update', this.state);\n      }\n    };\n    \n    requestAnimationFrame(loop);\n  }\n  \n  /**\n   * Update animation state\n   * @private\n   * @param {number} deltaTime - Time since last update in milliseconds\n   * @param {number} timestamp - Current timestamp\n   */\n  updateAnimation(deltaTime, timestamp) {\n    // Handle waypoint waiting\n    if (this.state.isWaitingAtWaypoint) {\n      if (timestamp >= this.state.pauseEndTime) {\n        this.state.endWaypointWait();\n        this.emit('waypointWaitEnd', this.state.pauseWaypointIndex);\n      } else {\n        // Don't advance time while waiting\n        return;\n      }\n    }\n    \n    // Advance animation time\n    this.state.currentTime += deltaTime;\n    \n    // Check for animation end\n    if (this.state.currentTime >= this.state.duration) {\n      this.state.currentTime = this.state.duration;\n      this.state.progress = 1;\n      this.pause();\n      this.emit('complete');\n    } else {\n      // Update progress\n      this.state.progress = this.state.currentTime / this.state.duration;\n      \n      // Check for waypoint waits\n      if (this.waypointCheckCallback) {\n        this.waypointCheckCallback(this.state.progress);\n      }\n    }\n  }\n  \n  /**\n   * Pause the animation\n   */\n  pause() {\n    this.state.pause();\n    this.emit('pause');\n  }\n  \n  /**\n   * Resume the animation\n   */\n  play() {\n    this.state.play();\n    this.emit('play');\n  }\n  \n  /**\n   * Toggle play/pause\n   */\n  togglePlayPause() {\n    if (this.state.isPlaying && !this.state.isPaused) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  \n  /**\n   * Stop the animation completely\n   */\n  stop() {\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n    this.state.stop();\n    this.emit('stop');\n  }\n  \n  /**\n   * Reset animation to beginning\n   */\n  reset() {\n    this.state.reset();\n    this.emit('reset');\n  }\n  \n  /**\n   * Seek to specific time\n   * @param {number} time - Time in milliseconds\n   */\n  seekToTime(time) {\n    this.state.setTime(time);\n    this.emit('seek', time);\n  }\n  \n  /**\n   * Seek to specific progress\n   * @param {number} progress - Progress from 0 to 1\n   */\n  seekToProgress(progress) {\n    this.state.setProgress(progress);\n    this.emit('seek', progress * this.state.duration);\n  }\n  \n  /**\n   * Set animation duration\n   * @param {number} duration - Duration in milliseconds\n   */\n  setDuration(duration) {\n    const currentProgress = this.state.progress;\n    console.log('\u23F1\uFE0F  [AnimationEngine.setDuration()] duration:', duration, 'ms (', (duration/1000).toFixed(1), 's), progress:', currentProgress);\n    this.state.duration = duration;\n    this.state.setProgress(currentProgress); // Maintain progress\n    this.emit('durationChange', duration);\n  }\n  \n  /**\n   * Set animation speed in pixels per second (for constant-speed mode)\n   * Rounds to nearest step value (5) to match slider constraints\n   * @param {number} speed - Speed in pixels per second\n   */\n  setSpeed(speed) {\n    // Round to nearest step value (5) to match slider\n    const step = 5;\n    const roundedSpeed = Math.round(speed / step) * step;\n    console.log('\uD83C\uDFC3 [AnimationEngine.setSpeed()] speed:', roundedSpeed, 'px/s (was:', this.state.speed, ', raw:', speed, ')');\n    this.state.speed = roundedSpeed;\n    this.emit('speedChange', roundedSpeed);\n  }\n  \n  /**\n   * Set playback speed multiplier\n   * @param {number} speed - Playback speed (1 = normal, 2 = double speed)\n   */\n  setPlaybackSpeed(speed) {\n    this.state.playbackSpeed = Math.max(0.1, Math.min(10, speed));\n    this.emit('playbackSpeedChange', this.state.playbackSpeed);\n  }\n  \n  /**\n   * Set animation mode\n   * @param {string} mode - 'constant-speed' or 'constant-time'\n   */\n  setMode(mode) {\n    this.state.setMode(mode);\n    this.emit('modeChange', mode);\n  }\n  \n  /**\n   * Start waiting at a waypoint\n   * @param {number} waypointIndex - Index of the waypoint\n   * @param {number} waitDuration - Duration to wait in milliseconds\n   */\n  startWaypointWait(waypointIndex, waitDuration) {\n    const progressSnapshot = this.state.progress;\n    this.state.startWaypointWait(waypointIndex, waitDuration, progressSnapshot);\n    this.emit('waypointWaitStart', { index: waypointIndex, duration: waitDuration });\n  }\n  \n  /**\n   * Set callback for checking waypoint waits\n   * @param {Function} callback - Function to check for waypoint waits\n   */\n  setWaypointCheckCallback(callback) {\n    this.waypointCheckCallback = callback;\n  }\n  \n  /**\n   * Check if animation is playing\n   * @returns {boolean}\n   */\n  isPlaying() {\n    return this.state.isPlaying && !this.state.isPaused;\n  }\n  \n  /**\n   * Check if animation is complete\n   * @returns {boolean}\n   */\n  isComplete() {\n    return this.state.progress >= 1;\n  }\n  \n  /**\n   * Get current state\n   * @returns {AnimationState}\n   */\n  getState() {\n    return this.state;\n  }\n  \n  /**\n   * Get current progress\n   * @returns {number} Progress from 0 to 1\n   */\n  getProgress() {\n    return this.state.getEffectiveProgress();\n  }\n  \n  /**\n   * Get current time\n   * @returns {number} Time in milliseconds\n   */\n  getTime() {\n    return this.state.currentTime;\n  }\n  \n  /**\n   * Calculate duration based on path length and speed\n   * @param {number} pathLength - Total path length in pixels\n   * @returns {number} Duration in milliseconds\n   */\n  calculateDurationFromSpeed(pathLength) {\n    if (this.state.mode === 'constant-speed' && this.state.speed > 0) {\n      return (pathLength / this.state.speed) * 1000;\n    }\n    return this.state.duration;\n  }\n  \n  /**\n   * Emit event through event bus\n   * @private\n   */\n  emit(eventName, data) {\n    if (this.eventBus) {\n      this.eventBus.emit(`animation:${eventName}`, data);\n    }\n  }\n  \n  /**\n   * Destroy the animation engine\n   */\n  destroy() {\n    this.stop();\n    this.onUpdate = null;\n    this.waypointCheckCallback = null;\n    this.eventBus = null;\n  }\n}\n", "/**\n * RenderingService - Handles all canvas rendering operations\n * Extracted from main.js for better modularity\n */\n\nimport { RENDERING, INTERACTION } from '../config/constants.js';\nimport { Easing } from '../utils/Easing.js';\n\nexport class RenderingService {\n  constructor() {\n    this.vectorCanvas = null;\n    this.waypointPositions = [];\n  }\n\n  /**\n   * Main render method - orchestrates all rendering layers\n   */\n  render(ctx, displayWidth, displayHeight, state) {\n    const cw = displayWidth || ctx.canvas.width;\n    const ch = displayHeight || ctx.canvas.height;\n    \n    // Safety check - ensure canvas has valid dimensions\n    if (cw <= 0 || ch <= 0) {\n      console.warn('Cannot render to canvas with invalid dimensions:', { width: cw, height: ch });\n      return; // Skip rendering\n    }\n    \n    // Clear\n    ctx.clearRect(0, 0, cw, ch);\n    \n    // 1) Base image\n    this.renderBackground(ctx, state.background, cw, ch);\n    \n    // 2) Contrast overlay\n    this.renderOverlay(ctx, state.background.overlay, cw, ch);\n    \n    // 3-6) Vector + head + UI handles on offscreen canvas\n    const vCanvas = this.getVectorCanvas(displayWidth, displayHeight);\n    \n    // Safety check for vector canvas\n    if (vCanvas.width <= 0 || vCanvas.height <= 0) {\n      console.warn('Vector canvas has invalid dimensions:', { width: vCanvas.width, height: vCanvas.height });\n      return; // Skip drawing vector layer\n    }\n    \n    const vctx = vCanvas.getContext('2d');\n    vctx.clearRect(0, 0, vCanvas.width, vCanvas.height);\n    this.renderVectorLayerTo(vctx, state);\n    \n    // Safety check before drawing vector layer\n    if (vCanvas.width > 0 && vCanvas.height > 0) {\n      // Blit vector layer to main\n      ctx.drawImage(vCanvas, 0, 0);\n    }\n  }\n\n  /**\n   * Get or create offscreen canvas for vector layer\n   */\n  getVectorCanvas(displayWidth, displayHeight) {\n    if (!this.vectorCanvas) {\n      this.vectorCanvas = document.createElement('canvas');\n    }\n    \n    // Get canvas dimensions with safety checks\n    const cw = displayWidth || 100; // Fallback to minimum size\n    const ch = displayHeight || 100;\n    \n    // Ensure we have valid dimensions > 0\n    const safeWidth = Math.max(1, cw);\n    const safeHeight = Math.max(1, ch);\n    \n    // Only update if dimensions changed\n    if (this.vectorCanvas.width !== safeWidth || this.vectorCanvas.height !== safeHeight) {\n      console.log('Resizing vector canvas to:', safeWidth, 'x', safeHeight);\n      this.vectorCanvas.width = safeWidth;\n      this.vectorCanvas.height = safeHeight;\n      \n      // Disable smoothing on vector canvas too\n      const vctx = this.vectorCanvas.getContext('2d');\n      if (vctx) {\n        vctx.imageSmoothingEnabled = false;\n      }\n    }\n    \n    return this.vectorCanvas;\n  }\n  \n  /**\n   * Render background image with fit/fill mode\n   */\n  renderBackground(ctx, background, canvasWidth, canvasHeight) {\n    if (!background.image) return;\n    \n    const img = background.image;\n    const iw = img.naturalWidth || img.width;\n    const ih = img.naturalHeight || img.height;\n    const cw = canvasWidth;\n    const ch = canvasHeight;\n    \n    if (background.fit === 'fit') {\n      // Fit: scale image to fit entirely within canvas (may have letterboxing)\n      const scale = Math.min(cw / iw, ch / ih);\n      const dw = Math.round(iw * scale);\n      const dh = Math.round(ih * scale);\n      const dx = Math.floor((cw - dw) / 2);\n      const dy = Math.floor((ch - dh) / 2);\n      // Draw entire source image scaled to fit\n      ctx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);\n    } else {\n      // Fill: enlarge so smaller dimension fills the canvas, center and crop\n      const scale = Math.max(cw / iw, ch / ih);\n      // Calculate which portion of source to show\n      const sw = cw / scale;  // source width to show\n      const sh = ch / scale;  // source height to show\n      const sx = (iw - sw) / 2;  // center horizontally\n      const sy = (ih - sh) / 2;  // center vertically\n      // Draw cropped portion of source image to fill entire canvas\n      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);\n    }\n  }\n  \n  /**\n   * Render overlay for contrast adjustment\n   */\n  renderOverlay(ctx, overlayValue, canvasWidth, canvasHeight) {\n    if (overlayValue === 0) return;\n    \n    ctx.save();\n    ctx.globalAlpha = Math.min(Math.abs(overlayValue) / 100, 0.6);\n    ctx.fillStyle = overlayValue < 0 ? '#000' : '#fff';\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.restore();\n  }\n\n  /**\n   * Render complete vector layer (paths, waypoints, labels)\n   */\n  renderVectorLayerTo(ctx, state) {\n    const { waypoints, pathPoints, styles, animationEngine, selectedWaypoint, imageToCanvas, displayWidth, displayHeight } = state;\n    \n    // Render path if we have points\n    if (pathPoints.length > 0 && waypoints.length > 1) {\n      this.renderPath(ctx, pathPoints, waypoints, styles, animationEngine);\n      this.renderPathHead(ctx, pathPoints, styles, animationEngine);\n    }\n    \n    // Render beacons\n    this.renderBeacons(ctx, waypoints, animationEngine, state.beaconAnimation, imageToCanvas, styles);\n    \n    // Render waypoint markers\n    this.renderWaypoints(ctx, waypoints, selectedWaypoint, styles, imageToCanvas, displayWidth, displayHeight);\n  }\n  \n  /**\n   * Render the animated path\n   */\n  renderPath(ctx, pathPoints, waypoints, styles, animationEngine) {\n    const totalPoints = pathPoints.length;\n    const progress = animationEngine.getProgress();\n    const exactPosition = totalPoints * progress;\n    const pointsToRender = Math.floor(exactPosition);\n    const fraction = exactPosition - pointsToRender; // Fractional part for partial segment\n    const segments = waypoints.length - 1;\n    const pointsPerSegment = Math.floor(totalPoints / segments);\n    const controllerForSegment = new Array(segments);\n    \n    // Store exact waypoint positions in path points for later use in labels\n    this.waypointPositions = [];\n    waypoints.forEach((wp, index) => {\n      if (index < waypoints.length - 1) {\n        const exactPointIndex = (index / segments) * totalPoints;\n        this.waypointPositions.push({\n          waypointIndex: index,\n          pointIndex: exactPointIndex\n        });\n      }\n    });\n    \n    let lastMajorIdx = -1;\n    for (let s = 0; s < segments; s++) {\n      if (waypoints[s].isMajor) lastMajorIdx = s;\n      controllerForSegment[s] = lastMajorIdx;\n    }\n    \n    for (let i = 1; i < pointsToRender; i++) {\n      const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n      const controllerIdx = controllerForSegment[segmentIndex];\n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : {\n        segmentColor: styles.pathColor,\n        segmentWidth: styles.pathThickness,\n        segmentStyle: 'solid',\n        pathShape: 'line'\n      };\n      \n      ctx.strokeStyle = controller.segmentColor;\n      ctx.lineWidth = controller.segmentWidth;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      this.applyLineStyle(ctx, controller.segmentStyle);\n      ctx.beginPath();\n      \n      const pathShape = controller.pathShape || 'line';\n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      \n      if (pathShape === 'squiggle') {\n        // Create a wavy path using control points\n        const midX = (p1.x + p2.x) / 2;\n        const midY = (p1.y + p2.y) / 2;\n        const perpX = -(p2.y - p1.y) * 0.15; // Perpendicular offset\n        const perpY = (p2.x - p1.x) * 0.15;\n        \n        ctx.moveTo(p1.x, p1.y);\n        const wave = Math.sin(i * 0.5) * 0.5;\n        ctx.quadraticCurveTo(\n          midX + perpX * wave, \n          midY + perpY * wave,\n          p2.x, p2.y\n        );\n      } else if (pathShape === 'randomised') {\n        // Add random jitter to the path\n        const jitterAmount = 3;\n        const jitteredP1 = {\n          x: p1.x + (Math.random() - 0.5) * jitterAmount,\n          y: p1.y + (Math.random() - 0.5) * jitterAmount\n        };\n        const jitteredP2 = {\n          x: p2.x + (Math.random() - 0.5) * jitterAmount,\n          y: p2.y + (Math.random() - 0.5) * jitterAmount\n        };\n        ctx.moveTo(jitteredP1.x, jitteredP1.y);\n        ctx.lineTo(jitteredP2.x, jitteredP2.y);\n      } else {\n        // Default line\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(p2.x, p2.y);\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Draw partial final segment for smooth animation (sub-pixel interpolation)\n    // Use tiny threshold (0.001%) to avoid degenerate cases while maintaining perfect smoothness\n    if (pointsToRender > 0 && pointsToRender < totalPoints && fraction > 0.00001) {\n      if (Math.random() < 0.01) { // Log 1% of the time to avoid spam\n        console.log('[RenderPath] Drawing partial segment - fraction:', fraction.toFixed(5), 'at point:', pointsToRender);\n      }\n      const i = pointsToRender;\n      const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n      const controllerIdx = controllerForSegment[segmentIndex];\n      const controller = controllerIdx >= 0 ? waypoints[controllerIdx] : {\n        segmentColor: styles.pathColor,\n        segmentWidth: styles.pathThickness,\n        segmentStyle: 'solid',\n        pathShape: 'line'\n      };\n      \n      ctx.strokeStyle = controller.segmentColor;\n      ctx.lineWidth = controller.segmentWidth;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n      this.applyLineStyle(ctx, controller.segmentStyle);\n      ctx.beginPath();\n      \n      const p1 = pathPoints[i - 1];\n      const p2 = pathPoints[i];\n      \n      // Interpolate end point for smooth partial segment\n      const partialEnd = {\n        x: p1.x + (p2.x - p1.x) * fraction,\n        y: p1.y + (p2.y - p1.y) * fraction\n      };\n      \n      const pathShape = controller.pathShape || 'line';\n      \n      if (pathShape === 'squiggle') {\n        const midX = (p1.x + partialEnd.x) / 2;\n        const midY = (p1.y + partialEnd.y) / 2;\n        const perpX = -(partialEnd.y - p1.y) * 0.15;\n        const perpY = (partialEnd.x - p1.x) * 0.15;\n        \n        ctx.moveTo(p1.x, p1.y);\n        const wave = Math.sin(i * 0.5) * 0.5;\n        ctx.quadraticCurveTo(\n          midX + perpX * wave,\n          midY + perpY * wave,\n          partialEnd.x, partialEnd.y\n        );\n      } else if (pathShape === 'randomised') {\n        // For randomised, use simple line to avoid flickering\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(partialEnd.x, partialEnd.y);\n      } else {\n        // Default line with interpolated end point\n        ctx.moveTo(p1.x, p1.y);\n        ctx.lineTo(partialEnd.x, partialEnd.y);\n      }\n      \n      ctx.stroke();\n    }\n    \n    ctx.setLineDash([]);\n  }\n  \n  /**\n   * Render the path head (animated marker)\n   */\n  renderPathHead(ctx, pathPoints, styles, animationEngine) {\n    const progress = animationEngine.getProgress();\n    const totalPoints = pathPoints.length;\n    const exactPosition = totalPoints * progress;\n    const pointsToRender = Math.floor(exactPosition);\n    \n    if (pointsToRender > 1 && pointsToRender < totalPoints) {\n      // Interpolate between current and next point for smooth movement\n      const currentIndex = Math.min(pointsToRender - 1, pathPoints.length - 2);\n      const nextIndex = currentIndex + 1;\n      const fraction = exactPosition - pointsToRender; // Fractional part (0-1)\n      \n      const currentPoint = pathPoints[currentIndex];\n      const nextPoint = pathPoints[nextIndex];\n      \n      // Linear interpolation between points for smooth sub-pixel movement\n      const head = {\n        x: currentPoint.x + (nextPoint.x - currentPoint.x) * fraction,\n        y: currentPoint.y + (nextPoint.y - currentPoint.y) * fraction\n      };\n      \n      // Calculate direction for rotation (use interpolated position)\n      let rotation = 0;\n      if (currentIndex > 0) {\n        const prevPoint = pathPoints[currentIndex - 1];\n        rotation = Math.atan2(nextPoint.y - prevPoint.y, nextPoint.x - prevPoint.x);\n      }\n      \n      // Store calculated rotation\n      styles.pathHead.rotation = rotation;\n      \n      // Draw path head based on style with interpolated position\n      this.drawPathHead(ctx, head.x, head.y, rotation, styles.pathHead);\n    } else if (pointsToRender >= totalPoints && totalPoints > 0) {\n      // At end of animation, use final point\n      const head = pathPoints[totalPoints - 1];\n      const prevPoint = totalPoints > 1 ? pathPoints[totalPoints - 2] : head;\n      const rotation = Math.atan2(head.y - prevPoint.y, head.x - prevPoint.x);\n      styles.pathHead.rotation = rotation;\n      this.drawPathHead(ctx, head.x, head.y, rotation, styles.pathHead);\n    }\n  }\n  \n  /**\n   * Draw the path head based on current style settings\n   */\n  drawPathHead(ctx, x, y, rotation, pathHead) {\n    // Safety check for valid coordinates\n    if (!isFinite(x) || !isFinite(y)) {\n      console.warn('Invalid path head coordinates:', {x, y});\n      return;\n    }\n    \n    const size = pathHead.size;\n    \n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rotation);\n    \n    switch (pathHead.style) {\n      case 'dot':\n        // Simple dot (filled circle)\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        ctx.fill();\n        break;\n        \n      case 'arrow':\n        // Arrow shape\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        \n        // Draw arrow pointing right (rotation will handle direction)\n        ctx.moveTo(size, 0);            // Tip\n        ctx.lineTo(-size/2, size/2);    // Bottom corner\n        ctx.lineTo(-size/4, 0);         // Indentation\n        ctx.lineTo(-size/2, -size/2);   // Top corner\n        ctx.closePath();\n        ctx.fill();\n        break;\n        \n      case 'custom':\n        // Custom image\n        if (pathHead.image) {\n          const imgSize = size * 2; // Make image slightly larger for better visibility\n          // Draw the image centered and rotated\n          ctx.drawImage(\n            pathHead.image, \n            -imgSize/2, -imgSize/2,\n            imgSize, imgSize\n          );\n        } else {\n          // Fallback to dot if no image loaded\n          ctx.beginPath();\n          ctx.fillStyle = pathHead.color;\n          ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n          ctx.fill();\n        }\n        break;\n        \n      default:\n        // Default to dot\n        ctx.beginPath();\n        ctx.fillStyle = pathHead.color;\n        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        ctx.fill();\n    }\n    \n    ctx.restore();\n  }\n  \n  /**\n   * Render beacon effects at waypoints\n   */\n  renderBeacons(ctx, waypoints, animationEngine, beaconAnimation, imageToCanvas, styles) {\n    if (!waypoints.length) return;\n    \n    const currentProgress = animationEngine.getProgress();\n    \n    waypoints.forEach((waypoint, wpIndex) => {\n      if (waypoint.isMajor) {\n        // Calculate normalized progress for this waypoint\n        const exactWaypointProgress = wpIndex / (waypoints.length - 1);\n        \n        // Show beacon EXACTLY when we reach a waypoint (not after)\n        // Use a small threshold to ensure reliable triggering\n        const atWaypoint = Math.abs(currentProgress - exactWaypointProgress) < 0.001;\n        \n        // Show beacon exactly when paused at this waypoint\n        const isPausedHere = animationEngine.state.isPaused && \n                            animationEngine.state.pauseWaypointIndex === wpIndex;\n        \n        // Show beacon when either exactly at waypoint or paused at it\n        if (atWaypoint || isPausedHere) {\n          // Convert waypoint to canvas coords for drawing beacon\n          const wpCanvas = imageToCanvas(waypoint.imgX, waypoint.imgY);\n          this.drawBeacon(ctx, { ...waypoint, x: wpCanvas.x, y: wpCanvas.y }, beaconAnimation, styles);\n        }\n      }\n    });\n  }\n  \n  /**\n   * Draw beacon effect\n   */\n  drawBeacon(ctx, point, beaconAnimation, styles) {\n    const bStyle = point.beaconStyle || 'none';\n    const bColor = point.beaconColor || styles.beaconColor;\n    if (bStyle === 'none') return;\n    \n    // Safety check for valid coordinates\n    if (!isFinite(point.x) || !isFinite(point.y)) {\n      console.warn('Invalid beacon coordinates:', point);\n      return;\n    }\n    \n    if (bStyle === 'pulse') {\n      // Update pulse phase\n      beaconAnimation.pulsePhase = performance.now() * 0.003;\n      \n      // Pulsing dot\n      const pulse = 1 + Math.sin(beaconAnimation.pulsePhase) * 0.3;\n      const pulseSize = RENDERING.BEACON_PULSE_SIZE * pulse;\n      \n      // Outer glow\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);\n      ctx.fillStyle = bColor;\n      ctx.globalAlpha = RENDERING.BEACON_PULSE_OPACITY;\n      ctx.fill();\n      \n      // Update pulse animation state\n      beaconAnimation.pulsePhase = (beaconAnimation.pulsePhase + 0.1) % (Math.PI * 2);\n    } \n    else if (bStyle === 'ripple') {\n      // Ripple effect - expanding circles that fade out\n      const now = Date.now();\n      \n      // Add a new ripple every interval\n      if (!point.lastRipple || now - point.lastRipple > RENDERING.BEACON_RIPPLE_INTERVAL) {\n        beaconAnimation.ripples.push({\n          x: point.x, \n          y: point.y, \n          radius: 0,\n          opacity: 0.5,\n          startTime: now,\n          color: bColor\n        });\n        point.lastRipple = now;\n      }\n      \n      // Draw all active ripples\n      beaconAnimation.ripples = beaconAnimation.ripples.filter(ripple => {\n        const age = now - ripple.startTime;\n        if (age > RENDERING.BEACON_RIPPLE_DURATION) return false; // Remove old ripples\n        \n        // Calculate current radius with smooth fade-out\n        const radius = age / RENDERING.BEACON_RIPPLE_SPEED;\n        const fadeProgress = age / RENDERING.BEACON_RIPPLE_DURATION;\n        const opacity = 0.5 * (1 - Easing.cubicOut(fadeProgress));\n        \n        // Draw ripple\n        ctx.beginPath();\n        ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);\n        ctx.strokeStyle = ripple.color;\n        ctx.lineWidth = 2;\n        ctx.globalAlpha = opacity;\n        ctx.stroke();\n        \n        return true;\n      });\n      \n      // Draw center dot\n      ctx.beginPath();\n      ctx.fillStyle = bColor;\n      ctx.globalAlpha = 0.8;\n      ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset global alpha to prevent affecting subsequent draws\n    ctx.globalAlpha = 1.0;\n  }\n  \n  /**\n   * Render waypoint markers\n   */\n  renderWaypoints(ctx, waypoints, selectedWaypoint, styles, imageToCanvas, displayWidth, displayHeight) {\n    waypoints.forEach(waypoint => {\n      if (waypoint.isMajor) {\n        // Convert waypoint from image coords to canvas coords\n        const wpCanvas = imageToCanvas(waypoint.imgX, waypoint.imgY);\n        const isSelected = waypoint === selectedWaypoint;\n        const markerSize = waypoint.dotSize || styles.dotSize;\n        const size = isSelected ? markerSize * 1.3 : markerSize;\n        const markerStyle = waypoint.markerStyle || styles.markerStyle;\n        \n        // Skip rendering if marker style is 'none'\n        if (markerStyle === 'none') {\n          this.renderLabel(ctx, waypoint, wpCanvas.x, wpCanvas.y, 0, waypoints, styles.animationEngine, displayWidth, displayHeight);\n          return;\n        }\n        \n        ctx.fillStyle = waypoint.dotColor || waypoint.segmentColor || styles.dotColor;\n        ctx.strokeStyle = isSelected ? '#4a90e2' : 'white';\n        ctx.lineWidth = isSelected ? 3 : 2;\n        \n        // Draw different marker types\n        if (markerStyle === 'square') {\n          // Square marker\n          ctx.beginPath();\n          ctx.rect(wpCanvas.x - size, wpCanvas.y - size, size * 2, size * 2);\n          ctx.fill();\n          ctx.stroke();\n        } else if (markerStyle === 'flag') {\n          // Flag marker\n          ctx.beginPath();\n          // Pole\n          ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          ctx.lineTo(wpCanvas.x, wpCanvas.y + size);\n          // Flag\n          ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          ctx.lineTo(wpCanvas.x + size * 1.5, wpCanvas.y - size * 1.3);\n          ctx.lineTo(wpCanvas.x + size * 1.2, wpCanvas.y - size);\n          ctx.lineTo(wpCanvas.x, wpCanvas.y - size * 0.7);\n          ctx.closePath();\n          ctx.fill();\n          ctx.stroke();\n        } else {\n          // Default to dot\n          ctx.beginPath();\n          ctx.arc(wpCanvas.x, wpCanvas.y, size, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n        }\n        \n        // Draw labels for major waypoints\n        this.renderLabel(ctx, waypoint, wpCanvas.x, wpCanvas.y, size, waypoints, styles.animationEngine, displayWidth, displayHeight);\n      }\n    });\n  }\n  \n  /**\n   * Render waypoint labels\n   */\n  renderLabel(ctx, waypoint, x, y, dotSize, waypoints, animationEngine, displayWidth, displayHeight) {\n    // Skip if no label text or mode is 'none'\n    if (!waypoint.label || waypoint.labelMode === 'none') return;\n    \n    // Find the true waypoint position in path coordinates\n    const wpIndex = waypoints.indexOf(waypoint);\n    const totalPoints = this.waypointPositions.length;\n    \n    // Get exact path position for this waypoint\n    let waypointPointIndex = 0;\n    if (wpIndex < waypoints.length - 1) {\n      waypointPointIndex = (wpIndex / (waypoints.length - 1)) * totalPoints;\n    } else {\n      waypointPointIndex = totalPoints;\n    }\n    \n    // Current animation position in path coordinates\n    const exactCurrentPoint = totalPoints * animationEngine.getProgress();\n    \n    // Calculate animation timing parameters\n    const fadeTimeInPoints = totalPoints * 0.02; // 1% of animation = 0.5 seconds\n    let opacity = 0; // Start with zero opacity\n    \n    // Handle different label modes\n    switch (waypoint.labelMode) {\n      case 'on': \n        opacity = 1.0;\n        break;\n        \n      case 'fade':\n        if (exactCurrentPoint < waypointPointIndex) return;\n        const elapsed = exactCurrentPoint - waypointPointIndex;\n        \n        if (elapsed <= fadeTimeInPoints / 2) {\n          opacity = Math.min(1.0, elapsed / (fadeTimeInPoints / 2));\n          opacity = Math.pow(opacity, 0.5);\n        }\n        else if (elapsed <= fadeTimeInPoints * 3) {\n          opacity = 1.0;\n        }\n        else if (elapsed <= fadeTimeInPoints * 4) {\n          opacity = 1.0 - Math.min(1.0, (elapsed - fadeTimeInPoints * 3) / fadeTimeInPoints);\n        }\n        else {\n          return;\n        }\n        break;\n        \n      case 'persist':\n        const timeBeforeWaypoint = waypointPointIndex - exactCurrentPoint;\n        \n        if (timeBeforeWaypoint > fadeTimeInPoints) return;\n        \n        if (timeBeforeWaypoint > 0) {\n          const fadeProgress = 1.0 - (timeBeforeWaypoint / fadeTimeInPoints);\n          opacity = Math.pow(fadeProgress, 0.5);\n        }\n        else {\n          opacity = 1.0;\n        }\n        break;\n        \n      default:\n        return;\n    }\n    \n    // Save context for restoring later\n    ctx.save();\n    \n    // Apply calculated opacity\n    ctx.globalAlpha = Math.max(0.15, opacity);\n    \n    // Label style\n    ctx.font = 'bold 16px Arial';\n    \n    const blueAmount = opacity < 1.0 ? Math.max(0, 1 - opacity) * 60 : 0;\n    ctx.fillStyle = `rgb(${255-blueAmount}, ${255-blueAmount}, 255)`;\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 3;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    \n    // Add shadow for better visibility\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n    ctx.shadowBlur = 5;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    \n    // Calculate label position based on position setting\n    const padding = RENDERING.LABEL_OFFSET_X;\n    const position = waypoint.labelPosition || 'auto';\n    let labelX = x;\n    let labelY = y;\n    \n    // Adjust position based on setting\n    switch (position) {\n      case 'top':\n        labelY = y - dotSize - padding;\n        break;\n      case 'right':\n        labelX = x + dotSize + padding;\n        ctx.textAlign = 'left';\n        break;\n      case 'bottom':\n        labelY = y + dotSize + padding;\n        break;\n      case 'left':\n        labelX = x - dotSize - padding;\n        ctx.textAlign = 'right';\n        break;\n      case 'auto':\n      default:\n        const cw = displayWidth;\n        const ch = displayHeight;\n        \n        labelY = y - dotSize - padding;\n        \n        if (labelY < 30) {\n          labelY = y + dotSize + padding;\n        }\n        \n        if (x < 100) {\n          labelX = x + dotSize + padding;\n          ctx.textAlign = 'left';\n        } else if (x > cw - 100) {\n          labelX = x - dotSize - padding;\n          ctx.textAlign = 'right';\n        }\n        break;\n    }\n    \n    // Draw text with outline for readability\n    ctx.strokeText(waypoint.label, labelX, labelY);\n    ctx.fillText(waypoint.label, labelX, labelY);\n    \n    // Restore context to clear shadow and alpha\n    ctx.restore();\n  }\n  \n  /**\n   * Apply line style for path rendering\n   */\n  applyLineStyle(ctx, style) {\n    switch (style) {\n      case 'dotted':\n        ctx.setLineDash([2, 6]);\n        break;\n      case 'dashed':\n        ctx.setLineDash([10, 5]);\n        break;\n      case 'squiggle':\n        // Approximated with dashed pattern - true squiggle would need complex path manipulation\n        ctx.setLineDash([5, 3, 2, 3]);\n        break;\n      case 'solid':\n      default:\n        ctx.setLineDash([]);\n        break;\n    }\n  }\n}\n", "/**\n * Simple event bus for decoupled communication between components\n * Implements publish-subscribe pattern\n */\nexport class EventBus {\n  constructor() {\n    this.events = new Map();\n  }\n  \n  /**\n   * Subscribe to an event\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    if (!this.events.has(eventName)) {\n      this.events.set(eventName, []);\n    }\n    \n    const listeners = this.events.get(eventName);\n    listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => this.off(eventName, callback);\n  }\n  \n  /**\n   * Subscribe to an event (alias for on)\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(eventName, callback) {\n    return this.on(eventName, callback);\n  }\n  \n  /**\n   * Unsubscribe from an event\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to remove\n   */\n  off(eventName, callback) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    const index = listeners.indexOf(callback);\n    \n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    \n    // Clean up empty listener arrays\n    if (listeners.length === 0) {\n      this.events.delete(eventName);\n    }\n  }\n  \n  /**\n   * Unsubscribe from an event (alias for off)\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to remove\n   */\n  unsubscribe(eventName, callback) {\n    this.off(eventName, callback);\n  }\n  \n  /**\n   * Subscribe to an event that only fires once\n   * @param {string} eventName - Name of the event\n   * @param {Function} callback - Function to call when event is emitted\n   * @returns {Function} Unsubscribe function\n   */\n  once(eventName, callback) {\n    const wrapper = (...args) => {\n      callback(...args);\n      this.off(eventName, wrapper);\n    };\n    \n    return this.on(eventName, wrapper);\n  }\n  \n  /**\n   * Emit an event\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   */\n  emit(eventName, ...args) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    // Create a copy to avoid issues if listeners modify the array\n    const listenersCopy = [...listeners];\n    \n    listenersCopy.forEach(listener => {\n      try {\n        listener(...args);\n      } catch (error) {\n        console.error(`Error in event listener for ${eventName}:`, error);\n      }\n    });\n  }\n  \n  /**\n   * Emit an event (alias for emit)\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   */\n  publish(eventName, ...args) {\n    this.emit(eventName, ...args);\n  }\n  \n  /**\n   * Emit an event asynchronously\n   * @param {string} eventName - Name of the event\n   * @param {...any} args - Arguments to pass to listeners\n   * @returns {Promise} Promise that resolves when all listeners have been called\n   */\n  async emitAsync(eventName, ...args) {\n    if (!this.events.has(eventName)) return;\n    \n    const listeners = this.events.get(eventName);\n    const listenersCopy = [...listeners];\n    \n    const promises = listenersCopy.map(listener => {\n      return Promise.resolve().then(() => listener(...args));\n    });\n    \n    await Promise.all(promises);\n  }\n  \n  /**\n   * Remove all listeners for an event\n   * @param {string} eventName - Name of the event\n   */\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n  }\n  \n  /**\n   * Get the number of listeners for an event\n   * @param {string} eventName - Name of the event\n   * @returns {number} Number of listeners\n   */\n  listenerCount(eventName) {\n    if (!this.events.has(eventName)) return 0;\n    return this.events.get(eventName).length;\n  }\n  \n  /**\n   * Get all event names\n   * @returns {Array} Array of event names\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  \n  /**\n   * Clear all events and listeners\n   */\n  clear() {\n    this.events.clear();\n  }\n  \n  /**\n   * Destroy the event bus\n   */\n  destroy() {\n    this.clear();\n  }\n}\n", "import { RENDERING, ANIMATION } from '../config/constants.js';\n\n/**\n * Model representing a waypoint on the route\n * Encapsulates waypoint properties and provides methods for manipulation\n */\nexport class Waypoint {\n  constructor(options = {}) {\n    // Position (normalized image coordinates 0-1)\n    this.imgX = options.imgX || 0;\n    this.imgY = options.imgY || 0;\n    \n    // Type\n    this.isMajor = options.isMajor !== undefined ? options.isMajor : true;\n    \n    // Property change tracking for performance optimization\n    this._dirtyProps = new Set();\n    \n    // Visual properties\n    this.segmentColor = options.segmentColor || RENDERING.DEFAULT_PATH_COLOR;\n    this.segmentWidth = options.segmentWidth || RENDERING.DEFAULT_PATH_THICKNESS;\n    this.segmentStyle = options.segmentStyle || 'solid'; // solid, dashed, dotted\n    this.segmentTension = options.segmentTension || 0.5;\n    \n    // Path shape for segments starting from this waypoint\n    this.pathShape = options.pathShape || 'line'; // line, squiggle, randomised\n    \n    // Marker properties\n    this.markerStyle = options.markerStyle || 'dot'; // dot, square, flag, none\n    this.dotColor = options.dotColor || RENDERING.DEFAULT_PATH_COLOR;\n    this.dotSize = options.dotSize || (this.isMajor ? RENDERING.DEFAULT_DOT_SIZE : RENDERING.MINOR_DOT_SIZE);\n    \n    // Beacon effect\n    this.beaconStyle = options.beaconStyle || 'none'; // none, pulse, ripple\n    this.beaconColor = options.beaconColor || RENDERING.DEFAULT_PATH_COLOR;\n    \n    // Label\n    this.label = options.label || '';\n    this.labelMode = options.labelMode || 'none'; // none, on, fade, persist\n    this.labelPosition = options.labelPosition || 'auto'; // auto, top, right, bottom, left\n    \n    // Animation pause\n    this.pauseMode = options.pauseMode || 'none'; // none, timed\n    this.pauseTime = options.pauseTime || ANIMATION.DEFAULT_WAIT_TIME;\n    \n    // Path head style for when animation reaches this waypoint\n    this.pathHeadStyle = options.pathHeadStyle || 'arrow'; // dot, arrow, custom, none\n    this.pathHeadColor = options.pathHeadColor || '#111111';\n    this.pathHeadSize = options.pathHeadSize || RENDERING.PATH_HEAD_SIZE;\n    this.pathHeadImage = options.pathHeadImage || null;\n    \n    // Custom image (for custom marker)\n    this.customImage = options.customImage || null;\n    \n    // Metadata\n    this.id = options.id || this.generateId();\n    this.created = options.created || Date.now();\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Generate unique ID for waypoint\n   * @private\n   * @returns {string} Unique identifier\n   */\n  generateId() {\n    return `wp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  /**\n   * Update waypoint properties\n   * Tracks which properties changed for smart event emission\n   * @param {Object} updates - Properties to update\n   */\n  update(updates) {\n    Object.keys(updates).forEach(key => {\n      if (key in this && key !== 'id' && key !== 'created') {\n        // Track changes for smart event emissions\n        if (this[key] !== updates[key]) {\n          this[key] = updates[key];\n          this._dirtyProps.add(key);\n        }\n      }\n    });\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Set position\n   * @param {number} x - X coordinate (normalized 0-1)\n   * @param {number} y - Y coordinate (normalized 0-1)\n   */\n  setPosition(x, y) {\n    this.imgX = Math.max(0, Math.min(1, x));\n    this.imgY = Math.max(0, Math.min(1, y));\n    this.modified = Date.now();\n  }\n  \n  /**\n   * Toggle between major and minor waypoint\n   */\n  toggleType() {\n    this.isMajor = !this.isMajor;\n    \n    // Adjust properties based on type\n    if (!this.isMajor) {\n      // Minor waypoints have simpler properties\n      this.labelMode = 'none';\n      this.beaconStyle = 'none';\n      this.pauseMode = 'none';\n      this.dotSize = RENDERING.MINOR_DOT_SIZE;\n    } else {\n      this.dotSize = RENDERING.DEFAULT_DOT_SIZE;\n    }\n    \n    this.modified = Date.now();\n  }\n  \n  /**\n   * Check if waypoint should pause animation\n   * @returns {boolean} True if waypoint has pause time\n   */\n  shouldPause() {\n    return this.isMajor && \n           this.pauseMode === 'timed' && \n           this.pauseTime > 0;\n  }\n  \n  /**\n   * Get pause duration in milliseconds\n   * @returns {number} Pause duration\n   */\n  getPauseDuration() {\n    return this.shouldPause() ? this.pauseTime : 0;\n  }\n  \n  /**\n   * Check if waypoint has a label\n   * @returns {boolean} True if waypoint has a label to display\n   */\n  hasLabel() {\n    return this.label && this.label.trim().length > 0 && this.labelMode !== 'none';\n  }\n  \n  /**\n   * Check if waypoint has beacon effect\n   * @returns {boolean} True if waypoint has beacon effect\n   */\n  hasBeacon() {\n    return this.beaconStyle !== 'none';\n  }\n  \n  /**\n   * Check if waypoint is visible\n   * @returns {boolean} True if waypoint marker is visible\n   */\n  isVisible() {\n    return this.markerStyle !== 'none';\n  }\n  \n  /**\n   * Copy properties from another waypoint (for inheritance)\n   * Useful when creating new waypoints that should inherit style from previous\n   * @param {Waypoint} source - Waypoint to copy properties from\n   * @param {Array<string>} exclude - Properties to exclude from copying\n   * @returns {Waypoint} This waypoint (for chaining)\n   */\n  copyPropertiesFrom(source, exclude = ['id', 'imgX', 'imgY', 'created', 'modified', 'label']) {\n    // Properties to copy (style and path properties)\n    const copyProps = [\n      'segmentColor', 'segmentWidth', 'segmentStyle', 'segmentTension',\n      'pathShape', 'markerStyle', 'dotColor', 'dotSize',\n      'beaconStyle', 'beaconColor', 'labelMode', 'labelPosition',\n      'pauseMode', 'pauseTime', 'pathHeadStyle', 'pathHeadColor',\n      'pathHeadSize', 'pathHeadImage', 'customImage'\n    ];\n    \n    copyProps.forEach(prop => {\n      if (!exclude.includes(prop) && prop in source) {\n        this[prop] = source[prop];\n      }\n    });\n    \n    // Adjust for waypoint type differences\n    if (!this.isMajor && source.isMajor) {\n      // Minor waypoints don't have labels, beacons, or pauses\n      this.labelMode = 'none';\n      this.beaconStyle = 'none';\n      this.pauseMode = 'none';\n    }\n    \n    this.modified = Date.now();\n    return this; // Chainable\n  }\n  \n  /**\n   * Get list of properties that have changed since last clear\n   * @returns {Array<string>} Array of property names that changed\n   */\n  getDirtyProps() {\n    return Array.from(this._dirtyProps);\n  }\n  \n  /**\n   * Clear the dirty properties tracker\n   */\n  clearDirtyProps() {\n    this._dirtyProps.clear();\n  }\n  \n  /**\n   * Check if recent changes are style-only (no path recalculation needed)\n   * @returns {boolean} True if only style properties changed\n   */\n  isStyleChange() {\n    const styleProps = ['dotColor', 'dotSize', 'markerStyle', 'beaconColor', 'beaconStyle', 'label', 'labelMode', 'labelPosition'];\n    return this._dirtyProps.size > 0 &&\n           Array.from(this._dirtyProps).every(p => styleProps.includes(p));\n  }\n  \n  /**\n   * Check if recent changes affect path generation\n   * @returns {boolean} True if path properties changed\n   */\n  isPathChange() {\n    const pathProps = ['segmentColor', 'segmentWidth', 'segmentStyle', 'pathShape', 'segmentTension'];\n    return Array.from(this._dirtyProps).some(p => pathProps.includes(p));\n  }\n  \n  /**\n   * Check if position changed\n   * @returns {boolean} True if position changed\n   */\n  isPositionChange() {\n    return this._dirtyProps.has('imgX') || this._dirtyProps.has('imgY');\n  }\n  \n  /**\n   * Clone the waypoint\n   * @returns {Waypoint} New waypoint with same properties\n   */\n  clone() {\n    return new Waypoint(this.toJSON());\n  }\n  \n  /**\n   * Convert to plain object for serialization\n   * @returns {Object} Plain object representation\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      imgX: this.imgX,\n      imgY: this.imgY,\n      isMajor: this.isMajor,\n      segmentColor: this.segmentColor,\n      segmentWidth: this.segmentWidth,\n      segmentStyle: this.segmentStyle,\n      segmentTension: this.segmentTension,\n      pathShape: this.pathShape,\n      markerStyle: this.markerStyle,\n      dotColor: this.dotColor,\n      dotSize: this.dotSize,\n      beaconStyle: this.beaconStyle,\n      beaconColor: this.beaconColor,\n      label: this.label,\n      labelMode: this.labelMode,\n      labelPosition: this.labelPosition,\n      pauseMode: this.pauseMode,\n      pauseTime: this.pauseTime,\n      pathHeadStyle: this.pathHeadStyle,\n      pathHeadColor: this.pathHeadColor,\n      pathHeadSize: this.pathHeadSize,\n      pathHeadImage: this.pathHeadImage,\n      customImage: this.customImage,\n      created: this.created,\n      modified: this.modified\n    };\n  }\n  \n  /**\n   * Create waypoint from plain object\n   * @param {Object} data - Plain object with waypoint data\n   * @returns {Waypoint} New waypoint instance\n   */\n  static fromJSON(data) {\n    return new Waypoint(data);\n  }\n  \n  /**\n   * Create default major waypoint\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @returns {Waypoint} New major waypoint\n   */\n  static createMajor(x, y) {\n    return new Waypoint({\n      imgX: x,\n      imgY: y,\n      isMajor: true\n    });\n  }\n  \n  /**\n   * Create default minor waypoint\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @returns {Waypoint} New minor waypoint\n   */\n  static createMinor(x, y) {\n    return new Waypoint({\n      imgX: x,\n      imgY: y,\n      isMajor: false,\n      labelMode: 'none',\n      beaconStyle: 'none',\n      pauseMode: 'none',\n      dotSize: RENDERING.MINOR_DOT_SIZE\n    });\n  }\n  \n  /**\n   * Validate waypoint data\n   * @param {Object} data - Data to validate\n   * @returns {boolean} True if data is valid\n   */\n  static validate(data) {\n    if (!data || typeof data !== 'object') return false;\n    \n    // Required properties\n    if (typeof data.imgX !== 'number' || data.imgX < 0 || data.imgX > 1) return false;\n    if (typeof data.imgY !== 'number' || data.imgY < 0 || data.imgY > 1) return false;\n    \n    // Optional properties with valid values\n    if (data.markerStyle && !['dot', 'square', 'flag', 'none'].includes(data.markerStyle)) return false;\n    if (data.segmentStyle && !['solid', 'dashed', 'dotted'].includes(data.segmentStyle)) return false;\n    if (data.pathShape && !['line', 'squiggle', 'randomised'].includes(data.pathShape)) return false;\n    if (data.beaconStyle && !['none', 'pulse', 'ripple'].includes(data.beaconStyle)) return false;\n    if (data.labelMode && !['none', 'on', 'fade', 'persist'].includes(data.labelMode)) return false;\n    if (data.pauseMode && !['none', 'timed'].includes(data.pauseMode)) return false;\n    \n    return true;\n  }\n}\n", "/**\n * UIController - Manages all UI interactions and updates\n * Handles waypoint list, editor controls, tabs, and animation controls\n */\n\nimport { RENDERING, ANIMATION } from '../config/constants.js';\n\nexport class UIController {\n  constructor(elements, eventBus) {\n    this.elements = elements;\n    this.eventBus = eventBus;\n    this.selectedWaypoint = null;\n    \n    // Bind methods\n    this.updateWaypointList = this.updateWaypointList.bind(this);\n    this.updateWaypointEditor = this.updateWaypointEditor.bind(this);\n    this.syncAnimationControls = this.syncAnimationControls.bind(this);\n    \n    this.setupEventListeners();\n  }\n  \n  /**\n   * Set up all UI event listeners\n   */\n  setupEventListeners() {\n    console.log('\uD83D\uDD27 [UIController] Setting up event listeners at:', performance.now().toFixed(2), 'ms');\n    // Tab switching\n    this.elements.tabBtns?.forEach(btn => {\n      btn.addEventListener('click', (e) => this.handleTabSwitch(e));\n    });\n    \n    // Background controls\n    this.elements.bgUploadBtn?.addEventListener('click', () => {\n      this.elements.bgUpload.click();\n    });\n    \n    this.elements.bgUpload?.addEventListener('change', (e) => {\n      const file = e.target.files[0];\n      if (file) {\n        this.eventBus.emit('background:upload', file);\n      }\n    });\n    \n    this.elements.bgOverlay?.addEventListener('input', (e) => {\n      const value = parseInt(e.target.value);\n      this.elements.bgOverlayValue.textContent = value;\n      this.eventBus.emit('background:overlay-change', value);\n    });\n    \n    this.elements.bgFitToggle?.addEventListener('click', () => {\n      const currentMode = this.elements.bgFitToggle.dataset.mode;\n      const newMode = currentMode === 'fit' ? 'fill' : 'fit';\n      this.elements.bgFitToggle.dataset.mode = newMode;\n      this.elements.bgFitToggle.textContent = newMode === 'fit' ? 'Fit' : 'Fill';\n      this.eventBus.emit('background:mode-change', newMode);\n    });\n    \n    // Animation controls\n    this.elements.playBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:play');\n    });\n    \n    this.elements.pauseBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:pause');\n    });\n    \n    this.elements.skipStartBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:skip-start');\n    });\n    \n    this.elements.skipEndBtn?.addEventListener('click', () => {\n      this.eventBus.emit('ui:animation:skip-end');\n    });\n    \n    this.elements.timelineSlider?.addEventListener('input', (e) => {\n      const progress = e.target.value / ANIMATION.TIMELINE_RESOLUTION;\n      this.eventBus.emit('ui:animation:seek', progress);\n    });\n    \n    /**\n     * Animation speed slider with feedback loop prevention\n     * Uses multiple checks to distinguish between user input and programmatic updates\n     * to avoid circular event chains when slider value is set by code\n     */\n    let isUpdatingSlider = false;\n    \n    this.elements.animationSpeed?.addEventListener('input', (e) => {\n      const currentValue = parseInt(e.target.value);\n      const timestamp = performance.now().toFixed(2);\n      \n      // Comprehensive event logging\n      console.log(`\n\uD83D\uDCE1 [${timestamp}ms] SLIDER INPUT EVENT:`, {\n        value: currentValue,\n        isTrusted: e.isTrusted,\n        isUpdating: isUpdatingSlider,\n        hasFocus: document.activeElement === e.target,\n        eventType: e.type,\n        target: e.target.id\n      });\n      \n      // Check if this is a programmatic change\n      if (isUpdatingSlider) {\n        console.log('\uD83D\uDEE1\uFE0F [UIController] Blocked programmatic input event, value:', currentValue);\n        console.trace('Blocked event stack trace');\n        return;\n      }\n      \n      const speed = currentValue;\n      console.log('\uD83C\uDF9A\uFE0F [UIController] User moved slider to:', speed);\n      console.trace('User input stack trace');\n      this.eventBus.emit('animation:speed-change', speed);\n    });\n    \n    /**\n     * Listen for programmatic slider updates from other parts of the app\n     * Temporarily sets flag to prevent the input event from firing\n     * Rounds speed to nearest step value (5) to prevent snap-back\n     * @param {number} speed - The speed value to set on the slider\n     */\n    this.eventBus.on('ui:slider:update-speed', (speed) => {\n      const timestamp = performance.now().toFixed(2);\n      // Round to nearest step value (5) to prevent slider snap-back\n      const step = 5;\n      const roundedSpeed = Math.round(speed / step) * step;\n      console.log(`\n\uD83D\uDCB5 [${timestamp}ms] PROGRAMMATIC UPDATE:`, {\n        requested: speed,\n        rounded: roundedSpeed,\n        currentSliderValue: this.elements.animationSpeed.value\n      });\n      console.trace('Update origin');\n      \n      // Set protection and update slider\n      isUpdatingSlider = true;\n      this.elements.animationSpeed.value = roundedSpeed;\n      console.log(`\u2705 [${performance.now().toFixed(2)}ms] Protection ENABLED`);\n      \n      // Clear protection after brief delay to ensure queued events are blocked\n      setTimeout(() => { \n        const t = performance.now().toFixed(2);\n        console.log(`\u2705 [${t}ms] Re-enabling slider input detection`);\n        isUpdatingSlider = false;\n      }, 50);\n    });\n    \n    // Clear button\n    this.elements.clearBtn?.addEventListener('click', () => {\n      if (confirm('Clear all waypoints?')) {\n        this.eventBus.emit('waypoints:clear-all');\n      }\n    });\n    \n    // Help button\n    this.elements.helpBtn?.addEventListener('click', () => {\n      this.showHelp();\n    });\n    \n    // Waypoint editor controls\n    this.setupWaypointEditorControls();\n  }\n  \n  /**\n   * Setup waypoint editor controls\n   */\n  setupWaypointEditorControls() {\n    // Marker style\n    this.elements.markerStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'markerStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Dot color\n    this.elements.dotColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'dotColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Dot size\n    this.elements.dotSize?.addEventListener('input', (e) => {\n      const size = parseInt(e.target.value);\n      this.elements.dotSizeValue.textContent = size;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'dotSize',\n          value: size\n        });\n      }\n    });\n    \n    // Segment properties\n    this.elements.segmentColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.segmentWidth?.addEventListener('input', (e) => {\n      const width = parseInt(e.target.value);\n      this.elements.segmentWidthValue.textContent = width;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentWidth',\n          value: width\n        });\n      }\n    });\n    \n    this.elements.segmentStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'segmentStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Path shape\n    this.elements.pathShape?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:path-property-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'pathShape',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Beacon style\n    this.elements.editorBeaconStyle?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'beaconStyle',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.editorBeaconColor?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'beaconColor',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Label controls\n    this.elements.waypointLabel?.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'label',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.labelMode?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'labelMode',\n          value: e.target.value\n        });\n      }\n    });\n    \n    this.elements.labelPosition?.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'labelPosition',\n          value: e.target.value\n        });\n      }\n    });\n    \n    // Pause time\n    this.elements.waypointPauseTime?.addEventListener('input', (e) => {\n      const time = parseFloat(e.target.value);\n      this.elements.waypointPauseTimeValue.textContent = `${time}s`;\n      if (this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:style-changed', {\n          waypoint: this.selectedWaypoint,\n          property: 'pauseTime',\n          value: time * 1000 // Convert to ms\n        });\n      }\n    });\n    \n    // Path head controls\n    this.elements.pathHeadStyle?.addEventListener('change', (e) => {\n      this.eventBus.emit('pathhead:style-changed', e.target.value);\n    });\n    \n    this.elements.pathHeadColor?.addEventListener('input', (e) => {\n      this.eventBus.emit('pathhead:color-changed', e.target.value);\n    });\n    \n    this.elements.pathHeadSize?.addEventListener('input', (e) => {\n      const size = parseInt(e.target.value);\n      this.elements.pathHeadSizeValue.textContent = size;\n      this.eventBus.emit('pathhead:size-changed', size);\n    });\n  }\n  \n  /**\n   * Handle tab switching\n   */\n  handleTabSwitch(event) {\n    const tabBtn = event.target;\n    const tabName = tabBtn.dataset.tab;\n    \n    // Update button states\n    this.elements.tabBtns.forEach(btn => btn.classList.remove('active'));\n    tabBtn.classList.add('active');\n    \n    // Show corresponding tab content\n    document.querySelectorAll('.tab-content').forEach(content => {\n      content.classList.remove('active');\n    });\n    \n    const tabContent = document.getElementById(`${tabName}-tab`);\n    if (tabContent) {\n      tabContent.classList.add('active');\n    }\n  }\n  \n  /**\n   * Update waypoint list UI\n   */\n  updateWaypointList(waypoints) {\n    if (!this.elements.waypointList) return;\n    \n    this.elements.waypointList.innerHTML = '';\n    \n    // Only show major waypoints in the list\n    const majorWaypoints = waypoints.filter(wp => wp.isMajor);\n    \n    majorWaypoints.forEach((waypoint, index) => {\n      const item = document.createElement('div');\n      item.className = 'waypoint-item';\n      item.draggable = true; // Enable drag and drop\n      if (waypoint === this.selectedWaypoint) {\n        item.classList.add('selected');\n      }\n      \n      // Drag handle\n      const handle = document.createElement('span');\n      handle.className = 'waypoint-item-handle';\n      handle.textContent = '\u2630';\n      \n      // Label\n      const label = document.createElement('span');\n      label.className = 'waypoint-item-label';\n      label.textContent = waypoint.label || `Waypoint ${index + 1}`;\n      \n      // Delete button (simple \u00D7 character for cleaner look)\n      const delBtn = document.createElement('button');\n      delBtn.className = 'waypoint-item-delete';\n      delBtn.textContent = '\u00D7';\n      delBtn.title = 'Delete waypoint';\n      \n      item.appendChild(handle);\n      item.appendChild(label);\n      item.appendChild(delBtn);\n      \n      // Click anywhere on item to select (original behavior)\n      const selectWaypoint = (e) => {\n        e.stopPropagation();\n        this.eventBus.emit('waypoint:selected', waypoint);\n      };\n      \n      label.addEventListener('click', selectWaypoint);\n      handle.addEventListener('click', selectWaypoint);\n      item.addEventListener('click', selectWaypoint);\n      \n      // Delete button\n      delBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        if (confirm('Delete this waypoint?')) {\n          this.eventBus.emit('waypoint:deleted', waypoint);\n        }\n      });\n      \n      // Drag and drop handlers\n      item.addEventListener('dragstart', (e) => {\n        e.dataTransfer.effectAllowed = 'move';\n        e.dataTransfer.setData('text/plain', index.toString());\n        item.classList.add('dragging');\n      });\n      \n      item.addEventListener('dragend', (e) => {\n        item.classList.remove('dragging');\n      });\n      \n      item.addEventListener('dragover', (e) => {\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n        \n        const dragging = this.elements.waypointList.querySelector('.dragging');\n        if (dragging && dragging !== item) {\n          const rect = item.getBoundingClientRect();\n          const midpoint = rect.top + rect.height / 2;\n          \n          if (e.clientY < midpoint) {\n            item.parentNode.insertBefore(dragging, item);\n          } else {\n            item.parentNode.insertBefore(dragging, item.nextSibling);\n          }\n        }\n      });\n      \n      item.addEventListener('drop', (e) => {\n        e.preventDefault();\n        // Emit reorder event with new order\n        const items = Array.from(this.elements.waypointList.children);\n        const newOrder = items.map(el => {\n          const idx = Array.from(el.parentElement.children).indexOf(el);\n          return majorWaypoints[parseInt(el.dataset.originalIndex || idx)];\n        });\n        this.eventBus.emit('waypoints:reordered', newOrder);\n      });\n      \n      // Store original index for reordering\n      item.dataset.originalIndex = index;\n      \n      this.elements.waypointList.appendChild(item);\n    });\n  }\n  \n  /**\n   * Update waypoint editor with selected waypoint data\n   */\n  updateWaypointEditor(waypoint) {\n    this.selectedWaypoint = waypoint;\n    \n    if (!waypoint) {\n      // Hide editor, show placeholder\n      if (this.elements.waypointEditor) {\n        this.elements.waypointEditor.style.display = 'none';\n      }\n      if (this.elements.waypointEditorPlaceholder) {\n        this.elements.waypointEditorPlaceholder.style.display = 'flex';\n      }\n      return;\n    }\n    \n    // Show editor, hide placeholder\n    if (this.elements.waypointEditor) {\n      this.elements.waypointEditor.style.display = 'block';\n    }\n    if (this.elements.waypointEditorPlaceholder) {\n      this.elements.waypointEditorPlaceholder.style.display = 'none';\n    }\n    \n    // Update controls with waypoint values\n    if (this.elements.markerStyle) {\n      this.elements.markerStyle.value = waypoint.markerStyle || 'dot';\n    }\n    \n    if (this.elements.dotColor) {\n      this.elements.dotColor.value = waypoint.dotColor || '#FF6B6B';\n    }\n    \n    if (this.elements.dotSize) {\n      this.elements.dotSize.value = waypoint.dotSize || 8;\n      this.elements.dotSizeValue.textContent = waypoint.dotSize || 8;\n    }\n    \n    if (this.elements.segmentColor) {\n      this.elements.segmentColor.value = waypoint.segmentColor || '#FF6B6B';\n    }\n    \n    if (this.elements.segmentWidth) {\n      this.elements.segmentWidth.value = waypoint.segmentWidth || 3;\n      this.elements.segmentWidthValue.textContent = waypoint.segmentWidth || 3;\n    }\n    \n    if (this.elements.segmentStyle) {\n      this.elements.segmentStyle.value = waypoint.segmentStyle || 'solid';\n    }\n    \n    if (this.elements.pathShape) {\n      this.elements.pathShape.value = waypoint.pathShape || 'line';\n    }\n    \n    if (this.elements.editorBeaconStyle) {\n      this.elements.editorBeaconStyle.value = waypoint.beaconStyle || 'pulse';\n    }\n    \n    if (this.elements.editorBeaconColor) {\n      this.elements.editorBeaconColor.value = waypoint.beaconColor || '#FF6B6B';\n    }\n    \n    if (this.elements.waypointLabel) {\n      this.elements.waypointLabel.value = waypoint.label || '';\n    }\n    \n    if (this.elements.labelMode) {\n      this.elements.labelMode.value = waypoint.labelMode || 'none';\n    }\n    \n    if (this.elements.labelPosition) {\n      this.elements.labelPosition.value = waypoint.labelPosition || 'auto';\n    }\n    \n    if (this.elements.waypointPauseTime) {\n      const pauseSeconds = (waypoint.pauseTime || 1500) / 1000;\n      this.elements.waypointPauseTime.value = pauseSeconds;\n      this.elements.waypointPauseTimeValue.textContent = `${pauseSeconds}s`;\n    }\n    \n    // Update pause control visibility\n    const pauseControl = this.elements.pauseTimeControl;\n    if (pauseControl) {\n      pauseControl.style.display = waypoint.isMajor ? 'block' : 'none';\n    }\n  }\n  \n  /**\n   * Sync animation controls with animation state\n   */\n  syncAnimationControls(state) {\n    // Toggle play/pause button visibility\n    if (state.isPlaying) {\n      if (this.elements.playBtn) this.elements.playBtn.style.display = 'none';\n      if (this.elements.pauseBtn) this.elements.pauseBtn.style.display = 'inline-block';\n    } else {\n      if (this.elements.playBtn) this.elements.playBtn.style.display = 'inline-block';\n      if (this.elements.pauseBtn) this.elements.pauseBtn.style.display = 'none';\n    }\n    \n    // Update timeline\n    if (this.elements.timelineSlider && !state.isDraggingTimeline) {\n      this.elements.timelineSlider.value = Math.round(state.progress * ANIMATION.TIMELINE_RESOLUTION);\n    }\n    \n    // Update time display\n    this.updateTimeDisplay(state.currentTime, state.duration);\n  }\n  \n  /**\n   * Update time display\n   */\n  updateTimeDisplay(currentTime, duration) {\n    const formatTime = (ms) => {\n      const totalSeconds = Math.floor(ms / 1000);\n      const minutes = Math.floor(totalSeconds / 60);\n      const seconds = totalSeconds % 60;\n      return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    };\n    \n    if (this.elements.currentTime) {\n      this.elements.currentTime.textContent = formatTime(currentTime);\n    }\n    if (this.elements.totalTime) {\n      this.elements.totalTime.textContent = formatTime(duration);\n    }\n  }\n  \n  /**\n   * Show help/splash screen\n   */\n  showHelp() {\n    if (this.elements.splash) {\n      this.elements.splash.style.display = 'flex';\n    }\n  }\n  \n  /**\n   * Hide help/splash screen\n   */\n  hideHelp() {\n    if (this.elements.splash) {\n      this.elements.splash.style.display = 'none';\n    }\n  }\n  \n  /**\n   * Make an announcement for screen readers\n   */\n  announce(message) {\n    if (this.elements.announcer) {\n      this.elements.announcer.textContent = message;\n    }\n  }\n}\n", "/**\n * InteractionHandler - Manages mouse, keyboard, and touch interactions\n * Handles canvas clicks, dragging, keyboard shortcuts, and drag & drop\n */\n\nimport { INTERACTION } from '../config/constants.js';\n\nexport class InteractionHandler {\n  constructor(canvas, eventBus) {\n    this.canvas = canvas;\n    this.eventBus = eventBus;\n    \n    // Drag state\n    this.isDragging = false;\n    this.hasDragged = false;\n    this.dragOffset = { x: 0, y: 0 };\n    this.selectedWaypoint = null;\n    \n    // Bind methods\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleCanvasClick = this.handleCanvasClick.bind(this);\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleDragOver = this.handleDragOver.bind(this);\n    this.handleDrop = this.handleDrop.bind(this);\n    \n    this.setupEventListeners();\n  }\n  \n  /**\n   * Set up all interaction event listeners\n   */\n  setupEventListeners() {\n    // Mouse events\n    this.canvas.addEventListener('mousedown', this.handleMouseDown);\n    this.canvas.addEventListener('mousemove', this.handleMouseMove);\n    this.canvas.addEventListener('mouseup', this.handleMouseUp);\n    this.canvas.addEventListener('click', this.handleCanvasClick);\n    \n    // Touch events (for mobile support)\n    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });\n    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });\n    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });\n    \n    // Keyboard events\n    document.addEventListener('keydown', this.handleKeyDown);\n    \n    // Drag and drop for images\n    this.canvas.addEventListener('dragover', this.handleDragOver);\n    this.canvas.addEventListener('drop', this.handleDrop);\n    \n    // Context menu (right-click)\n    this.canvas.addEventListener('contextmenu', (e) => {\n      e.preventDefault();\n      this.handleContextMenu(e);\n    });\n  }\n  \n  /**\n   * Handle mouse down event\n   */\n  handleMouseDown(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on a waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        this.selectedWaypoint = waypoint;\n        this.isDragging = true;\n        this.hasDragged = false;\n        \n        // Calculate drag offset\n        this.eventBus.emit('coordinate:image-to-canvas', \n          { imgX: waypoint.imgX, imgY: waypoint.imgY }, \n          (canvasPos) => {\n            this.dragOffset.x = x - canvasPos.x;\n            this.dragOffset.y = y - canvasPos.y;\n          }\n        );\n        \n        // Add dragging class to canvas\n        this.canvas.classList.add('dragging');\n        \n        // Select the waypoint\n        this.eventBus.emit('waypoint:selected', waypoint);\n      }\n    });\n  }\n  \n  /**\n   * Handle mouse move event\n   */\n  handleMouseMove(event) {\n    if (this.isDragging && this.selectedWaypoint) {\n      const rect = this.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      \n      // Track that we actually moved\n      this.hasDragged = true;\n      \n      // Calculate new position accounting for offset\n      const newX = x - this.dragOffset.x;\n      const newY = y - this.dragOffset.y;\n      \n      // Convert to image coordinates\n      this.eventBus.emit('coordinate:canvas-to-image',\n        { canvasX: newX, canvasY: newY },\n        (imgPos) => {\n          // Emit position change event\n          this.eventBus.emit('waypoint:position-changed', {\n            waypoint: this.selectedWaypoint,\n            imgX: imgPos.x,\n            imgY: imgPos.y,\n            isDragging: true\n          });\n        }\n      );\n    }\n  }\n  \n  /**\n   * Handle mouse up event\n   */\n  handleMouseUp(event) {\n    if (this.isDragging) {\n      this.isDragging = false;\n      this.canvas.classList.remove('dragging');\n      \n      // If we actually dragged, save the position\n      if (this.hasDragged) {\n        this.eventBus.emit('waypoint:drag-ended', this.selectedWaypoint);\n      }\n      \n      this.selectedWaypoint = null;\n      this.hasDragged = false;\n    }\n  }\n  \n  /**\n   * Handle canvas click event\n   */\n  handleCanvasClick(event) {\n    // Don't add waypoint if we actually dragged\n    if (this.hasDragged) {\n      this.hasDragged = false;\n      return;\n    }\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        // Select existing waypoint\n        this.eventBus.emit('waypoint:selected', waypoint);\n      } else {\n        // Add new waypoint\n        const isMajor = !event.shiftKey; // Shift+click for minor waypoint\n        \n        // Convert to image coordinates\n        this.eventBus.emit('coordinate:canvas-to-image',\n          { canvasX: x, canvasY: y },\n          (imgPos) => {\n            this.eventBus.emit('waypoint:add', {\n              imgX: imgPos.x,\n              imgY: imgPos.y,\n              isMajor: isMajor\n            });\n          }\n        );\n      }\n    });\n  }\n  \n  /**\n   * Handle keyboard events\n   */\n  handleKeyDown(event) {\n    // Don't interfere with input fields\n    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {\n      return;\n    }\n    \n    const key = event.key.toLowerCase();\n    const shift = event.shiftKey;\n    const ctrl = event.ctrlKey || event.metaKey;\n    \n    // Animation controls\n    if (key === ' ') {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:toggle');\n    } else if (key === 'arrowleft' && !shift) {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:skip-start');\n    } else if (key === 'arrowright' && !shift) {\n      event.preventDefault();\n      this.eventBus.emit('ui:animation:skip-end');\n    }\n    \n    // Playback speed controls (J/K/L keys)\n    else if (key === 'j') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-decrease');\n    } else if (key === 'k') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-reset');\n    } else if (key === 'l') {\n      event.preventDefault();\n      this.eventBus.emit('animation:speed-increase');\n    }\n    \n    // Waypoint movement (arrow keys with shift)\n    else if (shift && this.selectedWaypoint) {\n      const moveAmount = ctrl ? 10 : 1; // Ctrl for larger movements\n      let dx = 0, dy = 0;\n      \n      switch (key) {\n        case 'arrowup':\n          dy = -moveAmount;\n          break;\n        case 'arrowdown':\n          dy = moveAmount;\n          break;\n        case 'arrowleft':\n          dx = -moveAmount;\n          break;\n        case 'arrowright':\n          dx = moveAmount;\n          break;\n        default:\n          return;\n      }\n      \n      if (dx !== 0 || dy !== 0) {\n        event.preventDefault();\n        this.eventBus.emit('waypoint:move-by-pixels', {\n          waypoint: this.selectedWaypoint,\n          dx: dx,\n          dy: dy\n        });\n      }\n    }\n    \n    // Delete selected waypoint\n    else if ((key === 'delete' || key === 'backspace') && this.selectedWaypoint) {\n      event.preventDefault();\n      this.eventBus.emit('waypoint:delete-selected');\n    }\n    \n    // Select next/previous waypoint\n    else if (key === 'tab') {\n      event.preventDefault();\n      const direction = shift ? 'previous' : 'next';\n      this.eventBus.emit('waypoint:select-adjacent', direction);\n    }\n    \n    // Toggle waypoint type\n    else if (key === 't' && this.selectedWaypoint) {\n      event.preventDefault();\n      this.eventBus.emit('waypoint:toggle-type', this.selectedWaypoint);\n    }\n    \n    // Undo/Redo (Ctrl+Z, Ctrl+Shift+Z)\n    else if (ctrl && key === 'z') {\n      event.preventDefault();\n      if (shift) {\n        this.eventBus.emit('history:redo');\n      } else {\n        this.eventBus.emit('history:undo');\n      }\n    }\n    \n    // Save (Ctrl+S)\n    else if (ctrl && key === 's') {\n      event.preventDefault();\n      this.eventBus.emit('file:save');\n    }\n    \n    // Help (? or H, but not Cmd+H or Ctrl+H)\n    else if ((key === '?' || key === 'h') && !ctrl) {\n      event.preventDefault();\n      this.eventBus.emit('help:toggle');\n    }\n  }\n  \n  /**\n   * Handle touch start (mobile)\n   */\n  handleTouchStart(event) {\n    if (event.touches.length === 1) {\n      const touch = event.touches[0];\n      const rect = this.canvas.getBoundingClientRect();\n      const x = touch.clientX - rect.left;\n      const y = touch.clientY - rect.top;\n      \n      // Simulate mouse down\n      this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n  }\n  \n  /**\n   * Handle touch move (mobile)\n   */\n  handleTouchMove(event) {\n    if (event.touches.length === 1 && this.isDragging) {\n      event.preventDefault();\n      const touch = event.touches[0];\n      \n      // Simulate mouse move\n      this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });\n    }\n  }\n  \n  /**\n   * Handle touch end (mobile)\n   */\n  handleTouchEnd(event) {\n    if (event.changedTouches.length === 1) {\n      const touch = event.changedTouches[0];\n      \n      // Simulate mouse up\n      this.handleMouseUp({ clientX: touch.clientX, clientY: touch.clientY });\n      \n      // If no drag occurred, treat as click\n      if (!this.hasDragged) {\n        this.handleCanvasClick({ \n          clientX: touch.clientX, \n          clientY: touch.clientY,\n          shiftKey: false \n        });\n      }\n    }\n  }\n  \n  /**\n   * Handle drag over event (for image drop)\n   */\n  handleDragOver(event) {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'copy';\n    this.canvas.classList.add('drag-over');\n  }\n  \n  /**\n   * Handle drop event (for image drop)\n   */\n  handleDrop(event) {\n    event.preventDefault();\n    this.canvas.classList.remove('drag-over');\n    \n    const files = event.dataTransfer.files;\n    if (files.length > 0) {\n      const file = files[0];\n      if (file.type.startsWith('image/')) {\n        this.eventBus.emit('background:upload', file);\n      }\n    }\n  }\n  \n  /**\n   * Handle context menu (right-click)\n   */\n  handleContextMenu(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if right-clicking on a waypoint\n    this.eventBus.emit('waypoint:check-at-position', { x, y }, (waypoint) => {\n      if (waypoint) {\n        // Show waypoint context menu\n        this.eventBus.emit('waypoint:show-context-menu', {\n          waypoint: waypoint,\n          x: event.clientX,\n          y: event.clientY\n        });\n      } else {\n        // Show canvas context menu\n        this.eventBus.emit('canvas:show-context-menu', {\n          x: event.clientX,\n          y: event.clientY,\n          canvasX: x,\n          canvasY: y\n        });\n      }\n    });\n  }\n  \n  /**\n   * Set selected waypoint (for external updates)\n   */\n  setSelectedWaypoint(waypoint) {\n    this.selectedWaypoint = waypoint;\n  }\n  \n  /**\n   * Clean up event listeners\n   */\n  destroy() {\n    this.canvas.removeEventListener('mousedown', this.handleMouseDown);\n    this.canvas.removeEventListener('mousemove', this.handleMouseMove);\n    this.canvas.removeEventListener('mouseup', this.handleMouseUp);\n    this.canvas.removeEventListener('click', this.handleCanvasClick);\n    document.removeEventListener('keydown', this.handleKeyDown);\n    this.canvas.removeEventListener('dragover', this.handleDragOver);\n    this.canvas.removeEventListener('drop', this.handleDrop);\n  }\n}\n", "// Import modular utilities\nimport { CatmullRom } from './utils/CatmullRom.js';\nimport { Easing } from './utils/Easing.js';\nimport { RENDERING, ANIMATION, INTERACTION, PATH } from './config/constants.js';\nimport { StorageService } from './services/StorageService.js';\nimport { CoordinateTransform } from './services/CoordinateTransform.js';\nimport { PathCalculatorWithWorker } from './services/PathCalculatorWithWorker.js';\nimport { AnimationEngine } from './services/AnimationEngine.js';\nimport { RenderingService } from './services/RenderingService.js';\nimport { EventBus } from './core/EventBus.js';\nimport { Waypoint } from './models/Waypoint.js';\nimport { UIController } from './controllers/UIController.js';\nimport { InteractionHandler } from './handlers/InteractionHandler.js';\n\n// Main application class for Route Plotter v3\nclass RoutePlotter {\n  constructor() {\n    // Services\n    this.storageService = new StorageService();\n    this.coordinateTransform = new CoordinateTransform();\n    this.pathCalculator = new PathCalculatorWithWorker(); // Use Web Worker version\n    this.renderingService = new RenderingService();\n    this.eventBus = new EventBus(); // Event-driven architecture for decoupled communication\n    this.animationEngine = new AnimationEngine(this.eventBus); // Animation loop management\n    \n    // Render optimization - batch multiple render requests into single frame\n    this.renderQueued = false;\n    \n    // Batch mode for loading operations (prevents redundant calculations)\n    this._batchMode = false;\n    \n    // Performance optimizations for Phase 7\n    this._lastDisplayedSecond = -1; // Throttle time display updates\n    this._majorWaypointsCache = null; // Cache major waypoint positions\n    this._durationUpdateTimeout = null; // Debounce duration calculations\n    \n    // DOM Elements\n    this.canvas = document.getElementById('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    \n    // Waypoints and path data\n    this.waypoints = []; // Will hold Waypoint model instances\n    this.waypointsById = new Map(); // O(1) lookup by waypoint ID\n    this.pathPoints = [];\n    this.selectedWaypoint = null;\n    this.isDragging = false;\n    this.hasDragged = false; // Track if mouse actually moved during drag\n    this.dragOffset = { x: 0, y: 0 };\n    \n    // Animation state now managed by AnimationEngine service\n    // Access via: this.animationEngine.state\n    \n    // Style settings\n    this.styles = {\n      pathColor: '#FF6B6B',\n      pathThickness: 3,\n      pathStyle: 'solid', // solid, dashed, dotted\n      pathShape: 'line', // line, squiggle, randomised\n      markerStyle: 'dot', // dot, square, flag, none\n      dotColor: '#FF6B6B',\n      dotSize: RENDERING.DEFAULT_DOT_SIZE,\n      beaconStyle: 'pulse', // none, pulse, ripple\n      beaconColor: '#FF6B6B',\n      labelMode: 'none', // none, on, fade, persist\n      labelPosition: 'auto', // auto, top, right, bottom, left\n      pathHead: {\n        style: 'arrow', // dot, arrow, custom, none\n        color: '#111111',\n        size: 8,\n        image: null, // For custom image\n        rotation: 0 // Automatically calculated based on path direction\n      }\n    };\n    \n    // Beacon animation state\n    this.beaconAnimation = {\n      pulsePhase: 0,\n      ripples: []\n    };\n    \n    // Background layer state\n    this.background = {\n      image: null,\n      overlay: 0,        // -100 (black) .. 0 (none) .. 100 (white)\n      fit: 'fit'         // 'fit' | 'fill'\n    };\n    \n    // Offscreen canvas for vector layer compositing\n    this.vectorCanvas = null;\n    \n    // Label management\n    this.labels = {\n      active: [],       // Currently visible labels\n      fadeTime: RENDERING.LABEL_FADE_TIME    // Fade duration in ms for 'fade' mode\n    };\n    \n    // UI Elements\n    this.elements = {\n      canvas: document.getElementById('canvas'),\n      waypoints: document.getElementById('waypoints-tab'),\n      settings: document.getElementById('settings-tab'),\n      tabBtns: document.querySelectorAll('.tab-btn'),\n      waypointList: document.getElementById('waypoint-list'),\n      bgUploadBtn: document.getElementById('bg-upload-btn'),\n      bgUpload: document.getElementById('bg-upload'),\n      bgOverlay: document.getElementById('bg-overlay'),\n      bgOverlayValue: document.getElementById('bg-overlay-value'),\n      bgFitToggle: document.getElementById('bg-fit-toggle'),\n      playBtn: document.getElementById('play-btn'),\n      pauseBtn: document.getElementById('pause-btn'),\n      skipStartBtn: document.getElementById('skip-start-btn'),\n      skipEndBtn: document.getElementById('skip-end-btn'),\n      timelineSlider: document.getElementById('timeline-slider'),\n      currentTime: document.getElementById('current-time'),\n      totalTime: document.getElementById('total-time'),\n      // animationMode: document.getElementById('animation-mode'), // Removed from UI\n      animationSpeed: document.getElementById('animation-speed'),\n      animationSpeedValue: document.getElementById('animation-speed-value'),\n      // animationDuration: document.getElementById('animation-duration'), // Removed from UI\n      // animationDurationValue: document.getElementById('animation-duration-value'), // Removed from UI\n      speedControl: document.getElementById('speed-control'),\n      // durationControl: document.getElementById('duration-control'), // Removed from UI\n      waypointEditor: document.getElementById('waypoint-editor'),\n      waypointEditorPlaceholder: document.getElementById('waypoint-editor-placeholder'),\n      waypointPauseTime: document.getElementById('waypoint-pause-time'),\n      waypointPauseTimeValue: document.getElementById('waypoint-pause-time-value'),\n      pauseTimeControl: document.getElementById('pause-time-control'),\n      splash: document.getElementById('splash'),\n      splashClose: document.getElementById('splash-close'),\n      splashDontShow: document.getElementById('splash-dont-show'),\n      segmentColor: document.getElementById('segment-color'),\n      segmentWidth: document.getElementById('segment-width'),\n      segmentWidthValue: document.getElementById('segment-width-value'),\n      segmentStyle: document.getElementById('segment-style'),\n      dotColor: document.getElementById('dot-color'),\n      dotSize: document.getElementById('dot-size'),\n      dotSizeValue: document.getElementById('dot-size-value'),\n      markerStyle: document.getElementById('marker-style'),\n      pathShape: document.getElementById('path-shape'),\n      editorBeaconStyle: document.getElementById('editor-beacon-style'),\n      editorBeaconColor: document.getElementById('editor-beacon-color'),\n      waypointLabel: document.getElementById('waypoint-label'),\n      labelMode: document.getElementById('label-mode'),\n      labelPosition: document.getElementById('label-position'),\n      helpBtn: document.getElementById('help-btn'),\n      clearBtn: document.getElementById('clear-btn'),\n      announcer: document.getElementById('announcer'),\n      // Path head elements\n      pathHeadStyle: document.getElementById('path-head-style'),\n      pathHeadColor: document.getElementById('path-head-color'),\n      pathHeadSize: document.getElementById('path-head-size'),\n      pathHeadSizeValue: document.getElementById('path-head-size-value'),\n      customHeadControls: document.getElementById('custom-head-controls'),\n      headUploadBtn: document.getElementById('head-upload-btn'),\n      headUpload: document.getElementById('head-upload'),\n      headPreview: document.getElementById('head-preview'),\n      headFilename: document.getElementById('head-filename'),\n      headPreviewImg: document.getElementById('head-preview-img')\n    };\n    \n    this.init();\n  }\n  \n  init() {\n    // Set up canvas size\n    this.resizeCanvas();\n    window.addEventListener('resize', () => {\n      this.resizeCanvas();\n      // Re-render after resize to rescale markers and waypoints\n      this.render();\n    });\n    \n    // Initialize marker style controls\n    this.elements.markerStyle.value = this.styles.markerStyle;\n    \n    // Initialize path shape control\n    this.elements.pathShape.value = this.styles.pathShape;\n    \n    // Initialize path head control values\n    this.elements.pathHeadStyle.value = this.styles.pathHead.style;\n    this.elements.pathHeadColor.value = this.styles.pathHead.color;\n    this.elements.pathHeadSize.value = this.styles.pathHead.size;\n    this.elements.pathHeadSizeValue.textContent = this.styles.pathHead.size;\n    \n    // Show/hide custom image controls based on initial style\n    this.elements.customHeadControls.style.display = \n      this.styles.pathHead.style === 'custom' ? 'block' : 'none';\n    \n    // Initialize animation speed display\n    const defaultDuration = this.animationEngine.state.duration / 1000;\n    this.elements.animationSpeedValue.textContent = defaultDuration + 's';\n    // Slider value will be set via event after UIController is initialized\n    \n    // Slider is now properly synchronized after resets\n    \n    // Set up event listeners\n    this.setupEventListeners();\n    \n    // Set up EventBus listeners for decoupled component communication\n    this.setupEventBusListeners();\n    \n    // Initialize UI Controller and Interaction Handler\n    this.uiController = new UIController(this.elements, this.eventBus);\n    this.interactionHandler = new InteractionHandler(this.canvas, this.eventBus);\n    \n    // Now that UIController is ready, set the initial slider value\n    const defaultSpeed = this.animationEngine.state.speed || ANIMATION.DEFAULT_SPEED;\n    const timestamp = performance.now().toFixed(2);\n    console.log(`\uD83D\uDE80 [${timestamp}ms] [init] Setting initial slider speed:`, defaultSpeed);\n    this.eventBus.emit('ui:slider:update-speed', defaultSpeed);\n    \n    // Set up controller event connections\n    this.setupControllerEventConnections();\n    \n    // Show splash on first load\n    if (this.storageService.shouldShowSplash()) {\n      this.showSplash();\n    }\n    \n    // Load autosave if present\n    this.loadAutosave();\n    \n    // Load default image if no background image is present (for dev testing)\n    if (!this.background.image) {\n      this.loadDefaultImage();\n    }\n    \n    // Set up AnimationEngine waypoint checking callback\n    this.animationEngine.setWaypointCheckCallback((progress) => {\n      const majorWaypoints = this.getMajorWaypointPositions();\n      if (majorWaypoints.length > 0) {\n        this.checkForWaypointWait(progress, majorWaypoints);\n      }\n    });\n    \n    // Set up AnimationEngine event listeners\n    this.setupAnimationEngineListeners();\n    \n    // Set default animation state: at end position, not playing\n    this.animationEngine.seekToProgress(1.0);\n    this.animationEngine.pause();\n    \n    // Initial render\n    this.render();\n    \n    // Start animation loop (runs continuously for rendering)\n    this.startRenderLoop();\n    \n    console.log('Route Plotter v3 initialized');\n  }\n  \n  resizeCanvas() {\n    const rect = this.canvas.getBoundingClientRect();\n    \n    // Controls panel is 80px tall and overlays the bottom of the canvas\n    // We need to subtract this from the usable height\n    const controlsHeight = RENDERING.CONTROLS_HEIGHT;\n    \n    // Use high DPI for better quality (aim for ~4K resolution)\n    const dpr = window.devicePixelRatio || 1;\n    const scale = Math.min(dpr * 2, 3); // Cap at 3x for performance\n    \n    // Set canvas pixel dimensions (high resolution)\n    this.canvas.width = rect.width * scale;\n    this.canvas.height = rect.height * scale;\n    \n    // Store scale for rendering\n    this.canvasScale = scale;\n    \n    // Scale context to match (this happens after canvas resize, so it's reset)\n    this.ctx.scale(scale, scale);\n    \n    // Disable image smoothing for crisp rendering\n    this.ctx.imageSmoothingEnabled = false;\n    \n    // Store the display dimensions for rendering calculations (CSS pixels)\n    // Account for the controls panel overlay\n    this.displayWidth = rect.width;\n    this.displayHeight = rect.height - controlsHeight;\n    \n    // Update coordinate transform service with new canvas dimensions\n    this.coordinateTransform.setCanvasDimensions(this.displayWidth, this.displayHeight);\n    \n    console.log('Canvas resized to:', rect.width, 'x', rect.height, 'at', scale + 'x scale', '(usable height:', this.displayHeight + ')');\n    \n    // Re-render after resize\n    this.render();\n  }\n  \n  setupEventListeners() {\n    // Sidebar tabs\n    document.querySelectorAll('.tab-btn').forEach(btn => {\n      btn.addEventListener('click', (e) => {\n        const tabName = e.target.dataset.tab;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));\n        e.target.classList.add('active');\n        \n        // Update tab content\n        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));\n        document.getElementById(`${tabName}-tab`).classList.add('active');\n      });\n    });\n    \n    // ===== SPLASH SCREEN EVENT LISTENERS =====\n    // Must be OUTSIDE commented blocks!\n    console.log('\uD83D\uDD27 [Splash] Setting up event listeners:', {\n      splash: !!this.elements.splash,\n      splashClose: !!this.elements.splashClose,\n      splashDontShow: !!this.elements.splashDontShow\n    });\n    \n    if (this.elements.splashClose) {\n      this.elements.splashClose.addEventListener('click', (e) => {\n        console.log('\uD83C\uDFAF [Splash] Close button clicked');\n        e.stopPropagation();\n        this.hideSplash();\n      });\n    } else {\n      console.error('\u274C [Splash] Close button element not found!');\n    }\n    \n    if (this.elements.splash) {\n      this.elements.splash.addEventListener('click', (e) => {\n        console.log('\uD83C\uDFAF [Splash] Background clicked, target:', e.target.id || e.target.className);\n        if (e.target === this.elements.splash) {\n          console.log('\u2705 [Splash] Closing splash (background click)');\n          this.hideSplash();\n        } else {\n          console.log('\u274C [Splash] Not closing (clicked on content)');\n        }\n      });\n    } else {\n      console.error('\u274C [Splash] Splash element not found!');\n    }\n    \n    /* Canvas events now handled by InteractionHandler\n    this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));\n    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n    this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));\n    this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));\n    // Drag & drop background image\n    this.canvas.addEventListener('dragover', (e) => { e.preventDefault(); });\n    this.canvas.addEventListener('drop', (e) => {\n      e.preventDefault();\n      const file = e.dataTransfer?.files?.[0];\n      if (file && file.type.startsWith('image/')) {\n        this.loadImageFile(file).then((img) => {\n          this.background.image = img;\n          this.updateImageTransform(img);\n          // Recalculate path with proper image bounds\n          if (this.waypoints.length >= 2) {\n            this.calculatePath();\n          }\n          this.render();\n          this.autoSave();\n          this.announce('Background image loaded');\n        });\n      }\n    });\n    */\n    \n    /* Header and transport controls now handled by UIController\n    this.elements.helpBtn.addEventListener('click', () => this.showSplash());\n    this.elements.clearBtn.addEventListener('click', () => this.clearAll());\n    \n    // Transport controls\n    this.elements.playBtn.addEventListener('click', () => this.play());\n    this.elements.pauseBtn.addEventListener('click', () => this.pause());\n    this.elements.skipStartBtn.addEventListener('click', () => this.skipToStart());\n    this.elements.skipEndBtn.addEventListener('click', () => this.skipToEnd());\n    \n    // Timeline slider\n    this.elements.timelineSlider.addEventListener('input', (e) => {\n      // Seeking clears any waiting state automatically in AnimationEngine\n      // Update progress and time based on slider position via AnimationEngine\n      const progress = e.target.value / ANIMATION.TIMELINE_RESOLUTION;\n      this.animationEngine.seekToProgress(progress);\n    });\n    \n    // Style controls\n    \n    // Waypoint editor controls\n    // Segment color affects path rendering (requires recalculation)\n    this.elements.segmentColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentColor = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Segment width affects path rendering (requires recalculation)\n    this.elements.segmentWidth.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentWidth = parseFloat(e.target.value);\n        this.elements.segmentWidthValue.textContent = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Segment style affects path rendering (requires recalculation)\n    this.elements.segmentStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.segmentStyle = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Path shape control (line, squiggle, randomised) - affects path generation\n    this.elements.pathShape.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.pathShape = e.target.value;\n        this.eventBus.emit('waypoint:path-property-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Marker style control (dot, square, flag, none) - visual only\n    this.elements.markerStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.markerStyle = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Dot color and size controls - visual only, no path recalculation\n    this.elements.dotColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.dotColor = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Per-waypoint beacon edits (only apply to major waypoints) - visual only\n    this.elements.editorBeaconStyle.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.beaconStyle = e.target.value;\n        if (this.selectedWaypoint.beaconStyle !== 'ripple') {\n          this.beaconAnimation.ripples = [];\n        }\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Beacon color - visual only\n    this.elements.editorBeaconColor.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.beaconColor = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Label controls (only enabled for major waypoints) - visual only\n    this.elements.waypointLabel.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.label = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Label display mode - visual only\n    this.elements.labelMode.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.labelMode = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    // Label position - visual only\n    this.elements.labelPosition.addEventListener('change', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        this.selectedWaypoint.labelPosition = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Path Head Style Controls\n    this.elements.pathHeadStyle.addEventListener('change', (e) => {\n      this.styles.pathHead.style = e.target.value;\n      \n      // Show/hide custom image controls based on style selection\n      this.elements.customHeadControls.style.display = \n        e.target.value === 'custom' ? 'block' : 'none';\n      \n      this.autoSave();\n    });\n    \n    this.elements.pathHeadColor.addEventListener('input', (e) => {\n      this.styles.pathHead.color = e.target.value;\n      this.autoSave();\n    });\n    \n    this.elements.pathHeadSize.addEventListener('input', (e) => {\n      this.styles.pathHead.size = parseInt(e.target.value);\n      this.elements.pathHeadSizeValue.textContent = e.target.value;\n      this.autoSave();\n    });\n    \n    // Custom Path Head Image Upload\n    this.elements.headUploadBtn.addEventListener('click', () => {\n      this.elements.headUpload.click();\n    });\n    \n    this.elements.headUpload.addEventListener('change', (e) => {\n      const file = e.target.files?.[0];\n      if (file) {\n        // Load the image\n        const reader = new FileReader();\n        reader.onload = (event) => {\n          const img = new Image();\n          img.onload = () => {\n            // Store the image in the styles\n            this.styles.pathHead.image = img;\n            \n            // Update preview\n            this.elements.headPreview.style.display = 'block';\n            this.elements.headFilename.textContent = file.name;\n            this.elements.headPreviewImg.src = event.target.result;\n            \n            this.autoSave();\n          };\n          img.src = event.target.result;\n        };\n        reader.readAsDataURL(file);\n      }\n    });\n    \n    // Dot size - visual only\n    this.elements.dotSize.addEventListener('input', (e) => {\n      if (this.selectedWaypoint) {\n        this.selectedWaypoint.dotSize = parseInt(e.target.value);\n        this.elements.dotSizeValue.textContent = e.target.value;\n        this.eventBus.emit('waypoint:style-changed', this.selectedWaypoint);\n      }\n    });\n    \n    // Always use constant-speed mode now (animation mode dropdown removed)\n    // Animation speed now handled by UIController -> EventBus -> animation:speed-change event\n    \n    // Waypoint pause time (in waypoint editor)\n    this.elements.waypointPauseTime.addEventListener('input', (e) => {\n      if (this.selectedWaypoint && this.selectedWaypoint.isMajor) {\n        // Update the selected waypoint's pause time (in milliseconds)\n        const pauseTimeSec = parseFloat(e.target.value);\n        this.selectedWaypoint.pauseTime = pauseTimeSec * 1000;\n        this.elements.waypointPauseTimeValue.textContent = pauseTimeSec + 's';\n        \n        // Automatically set pauseMode based on time value\n        this.selectedWaypoint.pauseMode = pauseTimeSec > 0 ? 'timed' : 'none';\n        \n        this.autoSave();\n      }\n    });\n    \n    // Background controls\n    this.elements.bgUploadBtn.addEventListener('click', () => this.elements.bgUpload.click());\n    this.elements.bgUpload.addEventListener('change', (e) => {\n      const file = e.target.files?.[0];\n      if (file) {\n        this.loadImageFile(file).then((img) => {\n          this.background.image = img;\n          this.updateImageTransform(img);\n          // Recalculate path with proper image bounds\n          if (this.waypoints.length >= 2) {\n            this.calculatePath();\n          }\n          this.render();\n          this.autoSave();\n          this.announce('Background image loaded');\n        });\n      }\n    });\n    this.elements.bgOverlay.addEventListener('input', (e) => {\n      this.background.overlay = parseInt(e.target.value);\n      this.elements.bgOverlayValue.textContent = e.target.value;\n      this.render();\n      this.autoSave();\n    });\n    // Toggle fit/fill button\n    this.elements.bgFitToggle.addEventListener('click', (e) => {\n      const currentMode = this.background.fit;\n      const newMode = currentMode === 'fit' ? 'fill' : 'fit';\n      this.background.fit = newMode;\n      \n      // Update coordinateTransform with new fit mode\n      if (this.background.image) {\n        this.updateImageTransform(this.background.image);\n      }\n      \n      // Update button text and data attribute\n      e.target.textContent = newMode === 'fit' ? 'Fit' : 'Fill';\n      e.target.dataset.mode = newMode;\n      \n      console.log('Fit mode changed to:', newMode);\n      // Recalculate path since waypoints need to be repositioned\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.render();\n      this.autoSave();\n    });\n    \n    /* Keyboard shortcuts now handled by InteractionHandler\n    document.addEventListener('keydown', (e) => {\n      const nudgeAmount = e.shiftKey ? 0.05 : 0.01; // 5% or 1%\n      const canvasWidth = this.canvas.width;\n      const canvasHeight = this.canvas.height;\n      \n      switch(e.code) {\n        case 'Space':\n          e.preventDefault();\n          if (this.animationEngine.state.isPlaying && !this.animationEngine.state.isPaused) {\n            this.pause();\n          } else {\n            this.play();\n          }\n          break;\n          \n        case 'KeyJ': // 0.5x speed\n          this.animationEngine.setPlaybackSpeed(0.5);\n          this.announce('Playback speed: 0.5x');\n          break;\n          \n        case 'KeyK': // 1x speed\n          this.animationEngine.setPlaybackSpeed(1);\n          this.announce('Playback speed: 1x');\n          break;\n          \n        case 'KeyL': // 2x speed\n          this.animationEngine.setPlaybackSpeed(2);\n          this.announce('Playback speed: 2x');\n          break;\n          \n        case 'ArrowLeft':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            // Convert current position to canvas, nudge, then back to image coords\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasX = canvasPos.x - nudgeAmount * canvasWidth;\n            const newImgPos = this.canvasToImage(newCanvasX, canvasPos.y);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event for consistent updates\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowRight':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasX = canvasPos.x + nudgeAmount * canvasWidth;\n            const newImgPos = this.canvasToImage(newCanvasX, canvasPos.y);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowUp':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasY = canvasPos.y - nudgeAmount * canvasHeight;\n            const newImgPos = this.canvasToImage(canvasPos.x, newCanvasY);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'ArrowDown':\n          if (this.selectedWaypoint) {\n            e.preventDefault();\n            const canvasPos = this.imageToCanvas(this.selectedWaypoint.imgX, this.selectedWaypoint.imgY);\n            const newCanvasY = canvasPos.y + nudgeAmount * canvasHeight;\n            const newImgPos = this.canvasToImage(canvasPos.x, newCanvasY);\n            this.selectedWaypoint.imgX = newImgPos.x;\n            this.selectedWaypoint.imgY = newImgPos.y;\n            // Emit position changed event\n            this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n          }\n          break;\n          \n        case 'Escape':\n          if (this.isDragging) {\n            this.isDragging = false;\n            this.canvas.classList.remove('dragging');\n          }\n          this.selectedWaypoint = null;\n          this.updateWaypointList();\n          this.updateWaypointEditor();\n          break;\n      }\n    });\n    */\n  }\n  \n  /**\n   * Queue a render operation to be executed on next animation frame\n   * Prevents multiple renders in same frame for better performance\n   * Example: Changing 3 waypoint properties = 1 render instead of 3\n   */\n  queueRender() {\n    if (!this.renderQueued) {\n      this.renderQueued = true;\n      requestAnimationFrame(() => {\n        this.render();\n        this.renderQueued = false;\n      });\n    }\n  }\n  \n  /**\n   * Begin batch mode - prevents redundant calculations during bulk operations\n   * Use when adding/loading multiple waypoints at once\n   */\n  beginBatch() {\n    this._batchMode = true;\n  }\n  \n  /**\n   * End batch mode and trigger single update\n   * Calculates path once for all batched changes\n   */\n  endBatch() {\n    this._batchMode = false;\n    // Trigger single update for all batched changes\n    if (this.waypoints.length >= 2) {\n      this.calculatePath();\n    }\n    this.updateWaypointList();\n    this.autoSave();\n    this.queueRender();\n  }\n  \n  /**\n   * Get waypoint by ID with O(1) lookup\n   * @param {string} id - Waypoint ID\n   * @returns {Waypoint|undefined} Waypoint instance or undefined\n   */\n  getWaypointById(id) {\n    return this.waypointsById.get(id);\n  }\n  \n  /**\n   * Add waypoint to ID lookup map\n   * @private\n   * @param {Waypoint} waypoint - Waypoint to add\n   */\n  _addWaypointToMap(waypoint) {\n    this.waypointsById.set(waypoint.id, waypoint);\n  }\n  \n  /**\n   * Remove waypoint from ID lookup map\n   * @private\n   * @param {Waypoint} waypoint - Waypoint to remove\n   */\n  _removeWaypointFromMap(waypoint) {\n    this.waypointsById.delete(waypoint.id);\n  }\n  \n  /**\n   * Set up EventBus listeners for decoupled component communication\n   * Uses event-driven architecture to reduce tight coupling between methods\n   * Events are categorized by change type for optimal performance:\n   * - position-changed: Requires path recalculation (expensive)\n   * - style-changed: Only visual update needed (cheap)\n   * - path-property-changed: Affects path generation (medium cost)\n   */\n  setupEventBusListeners() {\n    // ========== WAYPOINT LIFECYCLE EVENTS ==========\n    \n    /**\n     * waypoint:added - New waypoint created\n     * Triggers: Full update pipeline (path, list, save, render)\n     * Skipped during batch mode for performance\n     */\n    this.eventBus.on('waypoint:added', (waypoint) => {\n      // Validate waypoint instance\n      if (!(waypoint instanceof Waypoint)) {\n        console.error('Invalid waypoint: not a Waypoint instance', waypoint);\n        return;\n      }\n      \n      // Add to ID lookup map for O(1) access\n      this._addWaypointToMap(waypoint);\n      \n      // Invalidate major waypoints cache\n      this._majorWaypointsCache = null;\n      \n      // Skip individual updates during batch operations\n      if (this._batchMode) return;\n      \n      if (this.waypoints.length >= 2) {\n        this.calculatePath(); // Only calculate if we have enough waypoints for a path\n      }\n      this.updateWaypointList();\n      this.autoSave();\n      this.queueRender(); // Batched render\n    });\n    \n    /**\n     * waypoint:deleted - Waypoint removed\n     * Triggers: Full update pipeline\n     */\n    this.eventBus.on('waypoint:deleted', (index) => {\n      // Invalidate major waypoints cache\n      this._majorWaypointsCache = null;\n      \n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      } else {\n        this.pathPoints = []; // Clear path if too few waypoints\n      }\n      this.updateWaypointList();\n      this.updateWaypointEditor();\n      this.autoSave();\n      this.queueRender();\n    });\n    \n    /**\n     * waypoint:selected - Waypoint selected in UI\n     * Triggers: Only UI update\n     */\n    this.eventBus.on('waypoint:selected', (waypoint) => {\n      this.updateWaypointEditor();\n      this.queueRender(); // Highlight selection\n    });\n    \n    // ========== WAYPOINT PROPERTY CHANGE EVENTS ==========\n    \n    /**\n     * waypoint:position-changed - Waypoint moved/dragged\n     * MOST EXPENSIVE: Requires full path recalculation\n     * Note: During drag, path is calculated immediately for smooth feedback\n     * Event is only emitted on mouseup to trigger auto-save once\n     */\n    this.eventBus.on('waypoint:position-changed', (waypoint) => {\n      // Validate position bounds and clamp if needed\n      if (waypoint.imgX < 0 || waypoint.imgX > 1 || \n          waypoint.imgY < 0 || waypoint.imgY > 1) {\n        console.warn('Waypoint position out of bounds, clamping:', waypoint.id);\n        waypoint.setPosition(waypoint.imgX, waypoint.imgY); // Uses Math.max/min internally\n      }\n      \n      this.calculatePath(); // Recalculate path with new position\n      this.updateWaypointList();\n      this.autoSave(); // Debounced in StorageService\n      this.queueRender();\n    });\n    \n    /**\n     * waypoint:style-changed - Visual properties changed\n     * LEAST EXPENSIVE: Only re-render, no path calculation needed\n     * Examples: dot color, dot size, marker style, beacon color, label\n     */\n    this.eventBus.on('waypoint:style-changed', (waypoint) => {\n      this.queueRender(); // Visual update only\n      this.autoSave();\n    });\n    \n    /**\n     * waypoint:path-property-changed - Properties affecting path generation\n     * MEDIUM EXPENSE: Requires path recalculation\n     * Examples: segment color, segment width, segment style, path shape\n     */\n    this.eventBus.on('waypoint:path-property-changed', (waypoint) => {\n      this.calculatePath(); // Path appearance changed\n      this.autoSave();\n      this.queueRender();\n    });\n  }\n  \n  /**\n   * Set up AnimationEngine event listeners\n   * AnimationEngine emits events through EventBus with 'animation:' prefix\n   * Provides event-driven updates for animation state changes\n   * Performance optimization: React to engine events instead of polling\n   */\n  setupAnimationEngineListeners() {\n    // Animation playback events - listen via EventBus\n    this.eventBus.on('animation:play', () => {\n      // Toggle button visibility: hide Play, show Pause\n      this.elements.playBtn.style.display = 'none';\n      this.elements.pauseBtn.style.display = 'inline-block';\n      this.announce('Playing animation');\n    });\n    \n    this.eventBus.on('animation:pause', () => {\n      // Toggle button visibility: show Play, hide Pause\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation paused');\n    });\n    \n    this.eventBus.on('animation:complete', () => {\n      // Show Play button when complete\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation complete');\n    });\n    \n    this.eventBus.on('animation:reset', () => {\n      const timestamp = performance.now().toFixed(2);\n      // Show Play button when reset\n      this.elements.playBtn.style.display = 'inline-block';\n      this.elements.pauseBtn.style.display = 'none';\n      this.announce('Animation reset');\n      \n      // CRITICAL FIX: Update slider to match preserved speed after reset\n      const preservedSpeed = this.animationEngine.state.speed;\n      console.log(`\uD83D\uDD27 [${timestamp}ms] [animation:reset] Syncing slider to preserved speed:`, preservedSpeed);\n      console.trace('Reset origin');\n      \n      // CRITICAL FIX #2: Recalculate duration based on preserved speed and path length\n      if (this.pathPoints && this.pathPoints.length > 0) {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const totalDuration = (totalLength / preservedSpeed) * 1000;\n        console.log(`\uD83D\uDCCF [${timestamp}ms] [animation:reset] Recalculating duration - length:`, totalLength.toFixed(1), 'speed:', preservedSpeed, 'duration:', (totalDuration/1000).toFixed(1) + 's');\n        this.animationEngine.setDuration(totalDuration);\n        \n        const durationSec = Math.round(totalDuration / 100) / 10; // Round to 1 decimal\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      \n      // Use event to avoid feedback loop\n      this.eventBus.emit('ui:slider:update-speed', preservedSpeed);\n    });\n    \n    // Waypoint wait events\n    this.eventBus.on('animation:waypointWaitEnd', (waypointIndex) => {\n      console.log('Wait complete at waypoint', waypointIndex);\n      this.announce('Continuing animation');\n    });\n  }\n  \n  /**\n   * Set up event connections for UI Controller and Interaction Handler\n   */\n  setupControllerEventConnections() {\n    // Background events from UIController\n    this.eventBus.on('background:upload', (file) => {\n      this.loadImageFile(file).then(img => {\n        this.background.image = img;\n        this.updateImageTransform(img);\n        if (this.waypoints.length >= 2) {\n          this.calculatePath();\n        }\n        this.render();\n        this.autoSave();\n      });\n    });\n    \n    this.eventBus.on('background:overlay-change', (value) => {\n      this.background.overlay = value;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('background:mode-change', (mode) => {\n      this.background.fit = mode;\n      this.coordinateTransform.fitMode = mode;\n      this.updateImageTransform(this.background.image);\n      this.render();\n      this.autoSave();\n    });\n    \n    // Animation control events from UIController\n    // NOTE: These are command events from UI, NOT the state events emitted by AnimationEngine\n    // AnimationEngine emits 'play', 'pause', etc. internally - we listen to those in setupAnimationEngineListeners()\n    // These listeners are for UI button clicks, keyboard shortcuts, etc.\n    this.eventBus.on('ui:animation:play', () => {\n      console.log('\u25B6\uFE0F  [UI Event] ui:animation:play - progress:', this.animationEngine.getProgress());\n      // If animation is at 100%, restart from beginning\n      if (this.animationEngine.getProgress() >= 1.0) {\n        console.log('\uD83D\uDD04 [UI Event] Progress at 100%, calling reset()');\n        this.animationEngine.reset();\n      }\n      this.animationEngine.play();\n    });\n    this.eventBus.on('ui:animation:pause', () => this.animationEngine.pause());\n    this.eventBus.on('ui:animation:skip-start', () => {\n      console.log('\u23EA [UI Event] ui:animation:skip-start - calling reset()');\n      this.animationEngine.reset();\n    });\n    this.eventBus.on('ui:animation:skip-end', () => this.animationEngine.seekToProgress(1.0));\n    this.eventBus.on('ui:animation:seek', (progress) => this.animationEngine.seekToProgress(progress));\n    this.eventBus.on('animation:speed-change', (speed) => {\n      const timestamp = performance.now().toFixed(2);\n      console.log(`\uD83C\uDFAF [${timestamp}ms] [Event] animation:speed-change - new speed:`, speed, 'px/s');\n      console.trace('Speed change origin');\n      \n      this.animationEngine.setSpeed(speed);\n      \n      // Calculate and display total duration based on path length\n      if (this.pathPoints && this.pathPoints.length > 0) {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const totalDuration = (totalLength / speed) * 1000;\n        console.log('\uD83D\uDCCF [Event] Recalculating duration - length:', totalLength.toFixed(1), 'speed:', speed, 'duration:', (totalDuration/1000).toFixed(1) + 's');\n        this.animationEngine.setDuration(totalDuration);\n        \n        const durationSec = Math.round(totalDuration / 100) / 10; // Round to 1 decimal\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      } else {\n        // No path yet, show estimate\n        const estimatedDuration = 10000 / speed * this.animationEngine.state.speed;\n        const durationSec = Math.round(estimatedDuration / 100) / 10;\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      \n      this.updateTimeDisplay();\n      this.autoSave();\n    });\n    this.eventBus.on('ui:animation:toggle', () => {\n      if (this.animationEngine.state.isPlaying) {\n        this.animationEngine.pause();\n      } else {\n        this.animationEngine.play();\n      }\n    });\n    \n    // Playback speed events from InteractionHandler\n    this.eventBus.on('animation:speed-decrease', () => {\n      const current = this.animationEngine.state.playbackSpeed;\n      this.animationEngine.setPlaybackSpeed(Math.max(0.1, current - 0.1));\n    });\n    \n    this.eventBus.on('animation:speed-reset', () => {\n      this.animationEngine.setPlaybackSpeed(1.0);\n    });\n    \n    this.eventBus.on('animation:speed-increase', () => {\n      const current = this.animationEngine.state.playbackSpeed;\n      this.animationEngine.setPlaybackSpeed(Math.min(10, current + 0.1));\n    });\n    \n    // Waypoint events from InteractionHandler\n    this.eventBus.on('waypoint:add', (data) => {\n      const waypoint = data.isMajor ? \n        Waypoint.createMajor(data.imgX, data.imgY) : \n        Waypoint.createMinor(data.imgX, data.imgY);\n      \n      // Copy properties from last waypoint if exists\n      if (this.waypoints.length > 0) {\n        const lastWaypoint = this.waypoints[this.waypoints.length - 1];\n        waypoint.copyPropertiesFrom(lastWaypoint);\n      }\n      \n      this.waypoints.push(waypoint);\n      this._addWaypointToMap(waypoint);\n      this.eventBus.emit('waypoint:added', waypoint);\n    });\n    \n    this.eventBus.on('waypoint:position-changed', (data) => {\n      const { waypoint, imgX, imgY, isDragging } = data;\n      waypoint.imgX = imgX;\n      waypoint.imgY = imgY;\n      \n      if (!isDragging) {\n        this.autoSave();\n      }\n      \n      this.eventBus.emit('waypoint:position-updated', waypoint);\n    });\n    \n    this.eventBus.on('waypoint:selected', (waypoint) => {\n      this.selectedWaypoint = waypoint;\n      this.interactionHandler?.setSelectedWaypoint(waypoint);\n      this.uiController?.updateWaypointEditor(waypoint);\n      this.updateWaypointList();\n    });\n    \n    this.eventBus.on('waypoint:deleted', (waypoint) => {\n      this.deleteWaypoint(waypoint);\n    });\n    \n    this.eventBus.on('waypoint:delete-selected', () => {\n      if (this.selectedWaypoint) {\n        this.deleteWaypoint(this.selectedWaypoint);\n        this.selectedWaypoint = null;\n      }\n    });\n    \n    this.eventBus.on('waypoints:clear-all', () => {\n      this.clearAll();\n    });\n    \n    // Waypoint reordering from UIController drag-and-drop\n    this.eventBus.on('waypoints:reordered', (newOrder) => {\n      // Find all major waypoints and update their order\n      const allWaypoints = [...this.waypoints];\n      const minorWaypoints = allWaypoints.filter(wp => !wp.isMajor);\n      \n      // Rebuild waypoints array with new major order, keeping minors in place\n      this.waypoints = [];\n      let majorIndex = 0;\n      \n      allWaypoints.forEach(wp => {\n        if (wp.isMajor) {\n          this.waypoints.push(newOrder[majorIndex]);\n          majorIndex++;\n        } else {\n          this.waypoints.push(wp);\n        }\n      });\n      \n      // Recalculate path and update\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.updateWaypointList();\n      this.autoSave();\n      this.render();\n    });\n    \n    // Coordinate conversion callbacks\n    this.eventBus.on('coordinate:canvas-to-image', (data, callback) => {\n      const result = this.canvasToImage(data.canvasX, data.canvasY);\n      if (callback) callback(result);\n    });\n    \n    this.eventBus.on('coordinate:image-to-canvas', (data, callback) => {\n      const result = this.imageToCanvas(data.imgX, data.imgY);\n      if (callback) callback(result);\n    });\n    \n    this.eventBus.on('waypoint:check-at-position', (pos, callback) => {\n      const waypoint = this.findWaypointAt(pos.x, pos.y);\n      if (callback) callback(waypoint);\n    });\n    \n    // Help events\n    this.eventBus.on('help:toggle', () => {\n      if (this.elements.splash.style.display === 'none' || \n          this.elements.splash.style.display === '') {\n        this.showSplash();\n      } else {\n        this.hideSplash();\n      }\n    });\n    \n    // Path head style events\n    this.eventBus.on('pathhead:style-changed', (style) => {\n      this.styles.pathHead.style = style;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('pathhead:color-changed', (color) => {\n      this.styles.pathHead.color = color;\n      this.render();\n      this.autoSave();\n    });\n    \n    this.eventBus.on('pathhead:size-changed', (size) => {\n      this.styles.pathHead.size = size;\n      this.render();\n      this.autoSave();\n    });\n  }\n  \n  /* Mouse handlers now managed by InteractionHandler\n  handleMouseDown(event) {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint\n    const clickedWaypoint = this.findWaypointAt(x, y);\n    \n    if (clickedWaypoint) {\n      this.selectedWaypoint = clickedWaypoint;\n      this.isDragging = true;\n      this.hasDragged = false; // Reset drag flag\n      // Store canvas offset for smooth dragging\n      const wpCanvas = this.imageToCanvas(clickedWaypoint.imgX, clickedWaypoint.imgY);\n      this.dragOffset.x = x - wpCanvas.x;\n      this.dragOffset.y = y - wpCanvas.y;\n      this.canvas.classList.add('dragging');\n      \n      // Emit selection event (updates editor UI)\n      this.eventBus.emit('waypoint:selected', clickedWaypoint);\n      this.updateWaypointList(); // Update list to show selection\n      event.preventDefault();\n    }\n  }\n  \n  handleMouseMove(event) {\n    if (this.isDragging && this.selectedWaypoint) {\n      const rect = this.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      \n      // Convert canvas position to image coordinates\n      const canvasX = x - this.dragOffset.x;\n      const canvasY = y - this.dragOffset.y;\n      const imgPos = this.canvasToImage(canvasX, canvasY);\n      this.selectedWaypoint.imgX = imgPos.x;\n      this.selectedWaypoint.imgY = imgPos.y;\n      this.hasDragged = true; // Mark that actual dragging occurred\n      \n      // Update path immediately for smooth visual feedback during drag\n      this.calculatePath();\n      // Batch render calls to prevent excessive rendering (60fps \u2192 ~2-3fps)\n      this.queueRender();\n    }\n  }\n  \n  handleMouseUp(event) {\n    if (this.isDragging) {\n      this.isDragging = false;\n      this.canvas.classList.remove('dragging');\n      \n      // Emit position changed event if waypoint was actually moved\n      // This triggers single auto-save instead of 60+ during drag\n      if (this.hasDragged && this.selectedWaypoint) {\n        this.eventBus.emit('waypoint:position-changed', this.selectedWaypoint);\n        this.hasDragged = false;\n        this.announce('Waypoint moved');\n      }\n      \n      this.updateWaypointList();\n    }\n  }\n  \n  handleCanvasClick(event) {\n    // Don't add waypoint if we actually dragged\n    if (this.hasDragged) {\n      this.hasDragged = false; // Reset for next time\n      return;\n    }\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Check if clicking on existing waypoint for selection\n    const clickedWaypoint = this.findWaypointAt(x, y);\n    if (clickedWaypoint) {\n      this.selectedWaypoint = clickedWaypoint;\n      this.updateWaypointList();\n      this.updateWaypointEditor();\n      return;\n    }\n    \n    // Determine if major or minor waypoint (Shift+Click for minor)\n    const isMajor = !event.shiftKey;\n    \n    // Convert canvas coordinates to normalized image coordinates\n    const imgPos = this.canvasToImage(x, y);\n    \n    // Create waypoint using factory method\n    // Waypoint model handles default properties and validation\n    const waypoint = isMajor\n      ? Waypoint.createMajor(imgPos.x, imgPos.y)\n      : Waypoint.createMinor(imgPos.x, imgPos.y);\n    \n    // Set default label for major waypoints\n    if (isMajor) {\n      waypoint.label = `Waypoint ${this.waypoints.length + 1}`;\n    }\n    \n    // Inherit properties from previous waypoint if exists\n    // This ensures consistent styling across the route\n    if (this.waypoints.length > 0) {\n      const previousWaypoint = this.waypoints[this.waypoints.length - 1];\n      waypoint.copyPropertiesFrom(previousWaypoint);\n    }\n    \n    // Add waypoint to array\n    this.waypoints.push(waypoint);\n    \n    // Emit waypoint added event (triggers path calculation, save, render)\n    // Decoupled approach prevents tight coupling to specific update sequence\n    this.eventBus.emit('waypoint:added', waypoint);\n    \n    this.announce(`${isMajor ? 'Major' : 'Minor'} waypoint added`);\n    console.log(`Added ${isMajor ? 'major' : 'minor'} waypoint at (${x.toFixed(0)}, ${y.toFixed(0)})`);\n  }\n  */ // End of mouse/keyboard handlers now managed by InteractionHandler\n  \n  findWaypointAt(x, y) {\n    const threshold = INTERACTION.WAYPOINT_HIT_RADIUS; // pixels\n    return this.waypoints.find(wp => {\n      // Convert waypoint from image coords to canvas coords for comparison\n      const wpCanvas = this.imageToCanvas(wp.imgX, wp.imgY);\n      const dist = Math.sqrt(Math.pow(wpCanvas.x - x, 2) + Math.pow(wpCanvas.y - y, 2));\n      return dist <= threshold;\n    });\n  }\n  \n  updateWaypointList() {\n    // Delegate to UIController\n    if (this.uiController) {\n      this.uiController.updateWaypointList(this.waypoints);\n      return;\n    }\n    \n    // Fallback if UIController not initialized\n    this.elements.waypointList.innerHTML = '';\n    const majorWaypoints = this.waypoints.filter(wp => wp.isMajor);\n    \n    majorWaypoints.forEach((waypoint, index) => {\n      const item = document.createElement('div');\n      item.className = 'waypoint-item';\n      if (waypoint === this.selectedWaypoint) {\n        item.classList.add('selected');\n      }\n      \n      // Header row\n      const handle = document.createElement('span');\n      handle.className = 'waypoint-item-handle';\n      handle.textContent = '\u2630';\n      const label = document.createElement('span');\n      label.className = 'waypoint-item-label';\n      label.textContent = `Waypoint ${index + 1}`;\n      const delBtn = document.createElement('button');\n      delBtn.className = 'waypoint-item-delete';\n      delBtn.textContent = '\u00D7';\n      \n      item.appendChild(handle);\n      item.appendChild(label);\n      item.appendChild(delBtn);\n      \n      // Selection by clicking header bits\n      const selectWaypoint = (e) => {\n        e.stopPropagation();\n        this.selectedWaypoint = waypoint;\n        this.updateWaypointList();\n        this.updateWaypointEditor();\n      };\n      label.addEventListener('click', selectWaypoint);\n      handle.addEventListener('click', selectWaypoint);\n      item.addEventListener('click', selectWaypoint);\n      \n      // Delete button\n      delBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.deleteWaypoint(waypoint);\n      });\n      \n      this.elements.waypointList.appendChild(item);\n    });\n  }\n  \n  updateWaypointEditor() {\n    if (this.selectedWaypoint) {\n      // Show editor and hide placeholder\n      this.elements.waypointEditor.style.display = 'block';\n      this.elements.waypointEditorPlaceholder.style.display = 'none';\n      \n      // Path properties\n      this.elements.segmentColor.value = this.selectedWaypoint.segmentColor;\n      this.elements.segmentWidth.value = this.selectedWaypoint.segmentWidth;\n      this.elements.segmentWidthValue.textContent = this.selectedWaypoint.segmentWidth;\n      this.elements.segmentStyle.value = this.selectedWaypoint.segmentStyle || 'solid';\n      this.elements.pathShape.value = this.selectedWaypoint.pathShape || 'line';\n      \n      // Marker properties\n      this.elements.markerStyle.value = this.selectedWaypoint.markerStyle || 'dot';\n      this.elements.dotColor.value = this.selectedWaypoint.dotColor || this.selectedWaypoint.segmentColor || this.styles.dotColor;\n      this.elements.dotSize.value = this.selectedWaypoint.dotSize || this.styles.dotSize;\n      this.elements.dotSizeValue.textContent = this.elements.dotSize.value;\n      \n      // Path head properties\n      this.elements.pathHeadStyle.value = this.selectedWaypoint.pathHeadStyle || this.styles.pathHead.style;\n      this.elements.pathHeadColor.value = this.selectedWaypoint.pathHeadColor || this.styles.pathHead.color;\n      this.elements.pathHeadSize.value = this.selectedWaypoint.pathHeadSize || this.styles.pathHead.size;\n      this.elements.pathHeadSizeValue.textContent = this.elements.pathHeadSize.value;\n      this.elements.customHeadControls.style.display = \n        (this.selectedWaypoint.pathHeadStyle || this.styles.pathHead.style) === 'custom' ? 'block' : 'none';\n      // Beacon editor fields\n      if (this.selectedWaypoint.isMajor) {\n        // Enable dot & beacon controls for major\n        this.elements.dotColor.disabled = false;\n        this.elements.dotSize.disabled = false;\n        this.elements.editorBeaconStyle.disabled = false;\n        this.elements.editorBeaconColor.disabled = false;\n        this.elements.editorBeaconStyle.value = this.selectedWaypoint.beaconStyle || this.styles.beaconStyle;\n        this.elements.editorBeaconColor.value = this.selectedWaypoint.beaconColor || this.styles.beaconColor;\n        \n        // Label controls\n        this.elements.waypointLabel.disabled = false;\n        this.elements.labelMode.disabled = false;\n        this.elements.labelPosition.disabled = false;\n        this.elements.waypointLabel.value = this.selectedWaypoint.label || '';\n        this.elements.labelMode.value = this.selectedWaypoint.labelMode || 'none';\n        this.elements.labelPosition.value = this.selectedWaypoint.labelPosition || 'auto';\n        \n        // Enable pause controls for major waypoints\n        this.elements.waypointPauseTime.disabled = false;\n        const pauseTimeSec = (this.selectedWaypoint.pauseTime || 0) / 1000;\n        this.elements.waypointPauseTime.value = pauseTimeSec;\n        this.elements.waypointPauseTimeValue.textContent = pauseTimeSec + 's';\n        this.elements.pauseTimeControl.style.display = 'flex';\n      } else {\n        // Minor waypoint - disable features that don't apply\n        this.elements.dotColor.disabled = true;\n        this.elements.dotSize.disabled = true;\n        this.elements.editorBeaconStyle.disabled = true;\n        this.elements.editorBeaconColor.disabled = true;\n        this.elements.editorBeaconStyle.value = 'none';\n        this.elements.editorBeaconColor.value = this.styles.beaconColor;\n        \n        // Disable label controls for minor waypoints\n        this.elements.waypointLabel.disabled = true;\n        this.elements.labelMode.disabled = true;\n        this.elements.labelPosition.disabled = true;\n        this.elements.waypointLabel.value = '';\n        this.elements.labelMode.value = 'none';\n        this.elements.labelPosition.value = 'auto';\n        \n        // Disable pause controls for minor waypoints\n        this.elements.waypointPauseTime.disabled = true;\n        this.elements.waypointPauseTime.value = 0;\n        this.elements.waypointPauseTimeValue.textContent = '0s';\n        this.elements.pauseTimeControl.style.display = 'none';\n      }\n    } else {\n      // Hide editor and show placeholder\n      this.elements.waypointEditor.style.display = 'none';\n      this.elements.waypointEditorPlaceholder.style.display = 'flex';\n    }\n  }\n  \n  deleteWaypoint(waypoint) {\n    const index = this.waypoints.indexOf(waypoint);\n    if (index > -1) {\n      // Remove from array\n      this.waypoints.splice(index, 1);\n      \n      // Remove from ID lookup map\n      this._removeWaypointFromMap(waypoint);\n      \n      // Clear selection if this waypoint was selected\n      if (this.selectedWaypoint === waypoint) {\n        this.selectedWaypoint = null;\n      }\n      \n      // Emit waypoint deleted event (triggers path recalc, UI update, save)\n      // Event-driven approach ensures consistent update sequence\n      this.eventBus.emit('waypoint:deleted', index);\n      \n      this.announce('Waypoint deleted');\n    }\n  }\n  \n  /**\n   * Update coordinateTransform service when image changes\n   * @param {HTMLImageElement} img - The loaded image\n   */\n  updateImageTransform(img) {\n    if (!img) {\n      // No image - coordinateTransform will use normalized coordinates\n      return;\n    }\n    \n    const width = img.naturalWidth || img.width;\n    const height = img.naturalHeight || img.height;\n    this.coordinateTransform.setImageDimensions(width, height, this.background.fit);\n  }\n  \n  /**\n   * Convert canvas coordinates to normalized image coordinates (0-1)\n   * Delegates to CoordinateTransform service\n   */\n  canvasToImage(canvasX, canvasY) {\n    return this.coordinateTransform.canvasToImage(canvasX, canvasY);\n  }\n  \n  /**\n   * Convert normalized image coordinates (0-1) to canvas coordinates\n   * Delegates to CoordinateTransform service\n   */\n  imageToCanvas(imageX, imageY) {\n    return this.coordinateTransform.imageToCanvas(imageX, imageY);\n  }\n  \n  async calculatePath() {\n    this.pathPoints = [];\n    \n    if (this.waypoints.length < 2) {\n      return;\n    }\n    \n    // Convert waypoint image coordinates to canvas coordinates\n    // This ensures the path is rendered correctly on the canvas\n    const canvasWaypoints = this.waypoints.map(wp => {\n      const canvasPos = this.imageToCanvas(wp.imgX, wp.imgY);\n      return {\n        ...wp,\n        x: canvasPos.x,\n        y: canvasPos.y\n      };\n    });\n    \n    try {\n      // Try to use async Web Worker calculation\n      this.pathPoints = await this.pathCalculator.calculatePathAsync(canvasWaypoints);\n    } catch (error) {\n      console.warn('Async path calculation failed, falling back to sync:', error);\n      // Fall back to synchronous calculation\n      this.pathPoints = this.pathCalculator.calculatePath(canvasWaypoints);\n    }\n    \n    // Performance optimization: Debounce duration calculation\n    // Prevents redundant calculations during multi-waypoint operations\n    if (this._durationUpdateTimeout) {\n      clearTimeout(this._durationUpdateTimeout);\n    }\n    \n    this._durationUpdateTimeout = setTimeout(() => {\n      // Calculate duration based on animation mode\n      if (this.animationEngine.state.mode === 'constant-speed') {\n        const totalLength = this.pathCalculator.calculatePathLength(this.pathPoints);\n        const currentSpeed = this.animationEngine.state.speed;\n        const totalDuration = (totalLength / currentSpeed) * 1000; // Convert to ms\n        \n        console.log('\uD83D\uDEE4\uFE0F  [calculatePath] Updating duration - speed:', currentSpeed, 'px/s, length:', totalLength.toFixed(1), 'px, duration:', (totalDuration/1000).toFixed(1) + 's');\n        \n        this.animationEngine.setDuration(totalDuration);\n        \n        // Update duration display immediately to show correct time\n        const durationSec = Math.round(totalDuration / 100) / 10;\n        this.elements.animationSpeedValue.textContent = durationSec + 's';\n      }\n      // For constant-time mode, duration is already set by the slider\n      \n      // Update total time display\n      this.updateTimeDisplay();\n    }, 50); // Wait 50ms for batch changes\n  }\n  \n  /**\n   * Get positions of major waypoints as normalized progress values (0-1)\n   * Performance optimization: Results are cached and only recalculated when waypoints change\n   * Reduces ~99% of waypoint position calculations (was every frame \u2192 once per change)\n   */\n  getMajorWaypointPositions() {\n    if (this.waypoints.length < 2) return [];\n    \n    // Return cached result if available (99% of calls hit cache)\n    if (this._majorWaypointsCache) {\n      return this._majorWaypointsCache;\n    }\n    \n    // Calculate fresh (only when waypoints change)\n    const majorWaypoints = [];\n    let totalSegments = this.waypoints.length - 1;\n    \n    for (let i = 0; i < this.waypoints.length; i++) {\n      if (this.waypoints[i].isMajor) {\n        // Calculate position as progress (0-1) along the path\n        const progress = i / totalSegments;\n        majorWaypoints.push({ \n          index: i, \n          progress: progress,\n          waypoint: this.waypoints[i]\n        });\n      }\n    }\n    \n    // Cache the result for subsequent calls\n    this._majorWaypointsCache = majorWaypoints;\n    return majorWaypoints;\n  }\n  \n  // Apply smooth easing to entire animation with EXACT waypoint positioning\n  // Gives professional smooth start/stop while preserving waypoint pause precision\n  applyEasing(rawProgress, majorWaypoints) {\n    // Check if we should be EXACTLY at a waypoint with pause\n    for (const wp of majorWaypoints) {\n      // If we're very close to the waypoint's progress and it has a pause setting\n      if (wp.waypoint && \n          wp.waypoint.pauseMode === 'timed' && \n          Math.abs(rawProgress - wp.progress) < 0.001) {\n        // Force exact position at waypoint - no easing\n        return wp.progress;\n      }\n    }\n    \n    // Apply smooth cubic ease-in-out for professional animation feel\n    return Easing.cubicInOut(rawProgress);\n  }\n  \n  // Find which segment of the path we're currently in based on progress\n  findSegmentIndexForProgress(progress) {\n    if (this.waypoints.length < 2) return -1;\n    \n    const totalSegments = this.waypoints.length - 1;\n    // Clamp progress between 0 and 1\n    const clampedProgress = Math.max(0, Math.min(1, progress));\n    \n    // Convert progress to segment index\n    const segmentPosition = clampedProgress * totalSegments;\n    const segmentIndex = Math.floor(segmentPosition);\n    \n    return Math.min(segmentIndex, totalSegments - 1);\n  }\n  \n  /**\n   * Check if we need to wait at any waypoint\n   * Performance optimization: Only checks waypoints within proximity threshold (~80% reduction)\n   */\n  checkForWaypointWait(rawProgress, majorWaypoints) {\n    // Skip if already waiting at a waypoint or not playing\n    if (this.animationEngine.state.isWaitingAtWaypoint || this.animationEngine.state.isPaused) return;\n    \n    // Performance optimization: Only check waypoints within 1% of current progress\n    // Reduces waypoint checking by ~80% (10 waypoints \u2192 ~1-2 checked)\n    const proximityThreshold = 0.01;\n    const nearbyWaypoints = majorWaypoints.filter(wp => \n      Math.abs(rawProgress - wp.progress) < proximityThreshold\n    );\n    \n    // No waypoints nearby - early return (most common case)\n    if (nearbyWaypoints.length === 0) return;\n    \n    // Find which waypoint we're currently at (or between)\n    const segmentIndex = this.findSegmentIndexForProgress(rawProgress);\n    if (segmentIndex < 0) return;\n    \n    // Only log major waypoint info on the first frame (when near the beginning)\n    if (rawProgress < 0.01) {\n      console.log('All major waypoints:', majorWaypoints.map(wp => ({\n        index: wp.index,\n        progress: wp.progress, \n        pauseMode: wp.waypoint && wp.waypoint.pauseMode\n      })));\n    }\n    \n    // First, find the next waypoint we'll encounter\n    let nextWaypoint = null;\n    let minPositiveDistance = Infinity;\n    \n    // Only iterate through nearby waypoints (performance optimization)\n    for (const wp of nearbyWaypoints) {\n      // Skip waypoints we've already waited at\n      if (wp.index === this.animationEngine.state.pauseWaypointIndex) continue;\n      \n      // Extra careful check for pauseMode property and pause time\n      const pauseMode = wp.waypoint && wp.waypoint.pauseMode;\n      const pauseTime = wp.waypoint && wp.waypoint.pauseTime;\n      \n      // Skip if no wait time or pause mode isn't timed\n      if (!wp.waypoint || pauseMode !== 'timed' || !pauseTime || pauseTime <= 0) {\n        continue;\n      }\n      \n      // Calculate exact position values for this waypoint\n      const exactWaypointProgress = wp.index / (this.waypoints.length - 1);\n      \n      // Calculate precise distance from current position to waypoint\n      // We want the closest waypoint ahead of us (positive distance)\n      const distanceToWaypoint = exactWaypointProgress - rawProgress;\n      \n      // Only consider waypoints ahead of us (positive distance) or very close\n      // Use a small negative threshold to catch waypoints we just passed by a tiny bit\n      if (distanceToWaypoint > -0.005 && distanceToWaypoint < minPositiveDistance) {\n        minPositiveDistance = distanceToWaypoint;\n        nextWaypoint = wp;\n      }\n    }\n    \n    // If no valid waypoint found, return\n    if (!nextWaypoint) return;\n    \n    // Calculate exact waypoint position\n    const exactWaypointProgress = nextWaypoint.index / (this.waypoints.length - 1);\n    \n    // More flexible threshold to catch waypoints\n    // This prevents skipping over waypoints during fast animations\n    // 0.005 is 0.5% of the total path length - small enough to be precise but not miss\n    const atOrJustPassedWaypoint = \n      Math.abs(rawProgress - exactWaypointProgress) < 0.005 && \n      rawProgress >= exactWaypointProgress - 0.005;\n    \n    if (atOrJustPassedWaypoint) {\n      console.log(`WAITING at waypoint ${nextWaypoint.index} (progress ${nextWaypoint.progress.toFixed(3)})`, nextWaypoint.waypoint);\n      \n      // Use AnimationEngine to handle waypoint waiting\n      // This centralizes wait logic in the animation service\n      this.animationEngine.startWaypointWait(\n        nextWaypoint.index,\n        nextWaypoint.waypoint.pauseTime\n      );\n          \n      // Announce wait period with duration\n      const waitDuration = nextWaypoint.waypoint.pauseTime / 1000;\n      this.announce(`Waiting at waypoint ${nextWaypoint.index + 1} for ${waitDuration} seconds`);\n    }\n  }\n  \n  // Kept for potential future use\n  continueAnimation() {\n    // Click-to-continue functionality removed\n  }\n  \n  // Easing functions moved to utils/Easing.js for better modularity and performance\n  // Corner slowing and curvature calculation moved to services/PathCalculator.js\n  \n  /**\n   * Play the animation\n   * Delegates to AnimationEngine for state management\n   */\n  play() {\n    if (this.waypoints.length < 2) return;\n    \n    // If animation is finished (at 100%), reset to beginning\n    if (this.animationEngine.state.progress >= 1.0) {\n      this.animationEngine.reset();\n    }\n    \n    // Delegate to AnimationEngine\n    this.animationEngine.play();\n    \n    // UI update handled by AnimationEngine event listeners\n  }\n  \n  /**\n   * Pause the animation\n   * Delegates to AnimationEngine for state management\n   */\n  pause() {\n    // Delegate to AnimationEngine\n    this.animationEngine.pause();\n    \n    // UI update handled by AnimationEngine event listeners\n  }\n  \n  /**\n   * Skip to start of animation\n   * Delegates to AnimationEngine for state management\n   */\n  skipToStart() {\n    this.animationEngine.reset();\n    this.announce('Skipped to start');\n  }\n  \n  /**\n   * Skip to end of animation\n   * Delegates to AnimationEngine for state management\n   */\n  skipToEnd() {\n    this.animationEngine.seekToProgress(1.0);\n    this.announce('Skipped to end');\n  }\n  \n  clearAll() {\n    this.waypoints = []; // Clear Waypoint instances\n    this.waypointsById.clear(); // Clear ID lookup map\n    this.pathPoints = [];\n    this.selectedWaypoint = null;\n    \n    // Reset animation state via AnimationEngine\n    this.animationEngine.reset();\n    this.animationEngine.setDuration(0);\n    \n    this.pause();\n    this.updateTimeDisplay();\n    this.updateWaypointList();\n    console.log('Cleared all waypoints and path');\n  }\n  \n  showSplash() {\n    console.log('\uD83D\uDCD6 [Splash] Showing splash screen');\n    this.elements.splash.style.display = 'flex';\n  }\n  \n  hideSplash() {\n    console.log('\uD83D\uDEAB [Splash] Hiding splash screen');\n    this.elements.splash.style.display = 'none';\n    \n    if (this.elements.splashDontShow.checked) {\n      console.log('\u2705 [Splash] Marking as \"don\\'t show again\"');\n      this.storageService.markSplashShown();\n    }\n  }\n\n  // ----- Accessibility and persistence helpers -----\n  announce(message, priority = 'polite') {\n    const el = document.getElementById('announcer');\n    if (!el) return;\n    el.setAttribute('aria-live', priority);\n    el.textContent = message;\n    // Clear after a short delay so repeated messages are announced\n    setTimeout(() => { el.textContent = ''; }, 2000);\n  }\n\n  autoSave() {\n    try {\n      // Create a clean copy of styles without the pathHead image object\n      const stylesCopy = { ...this.styles };\n      if (stylesCopy.pathHead && stylesCopy.pathHead.image) {\n        stylesCopy.pathHead = { ...stylesCopy.pathHead, image: null };\n      }\n      \n      const data = {\n        coordVersion: 6, // Version tracking for coordinate system changes\n        waypoints: this.waypoints.map(wp => wp.toJSON()), // Serialize Waypoint instances\n        styles: stylesCopy,\n        animationState: {\n          mode: this.animationEngine.state.mode,\n          speed: this.animationEngine.state.speed,\n          duration: this.animationEngine.state.duration,\n          playbackSpeed: this.animationEngine.state.playbackSpeed\n        },\n        background: {\n          overlay: this.background.overlay,\n          fit: this.background.fit\n        }\n      };\n      \n      // Use StorageService with debounced auto-save\n      this.storageService.autoSave(data);\n    } catch (e) {\n      console.error('Error saving state:', e);\n    }\n  }\n  \n  loadAutosave() {\n    console.log('\uD83D\uDCE5 [loadAutosave] Loading saved state...');\n    try {\n      const data = this.storageService.loadAutoSave();\n      if (!data) return;\n      \n      // Check version - if old version, clear and start fresh\n      const COORD_SYSTEM_VERSION = 6; // v6: Changed pause settings from global to per-waypoint\n      if (!data.coordVersion || data.coordVersion < COORD_SYSTEM_VERSION) {\n        console.log('Old data version detected (v' + (data.coordVersion || 1) + '), clearing saved data for v' + COORD_SYSTEM_VERSION);\n        this.storageService.clearAutoSave();\n        return;\n      }\n      \n      // Hydrate waypoints from plain objects to Waypoint instances\n      if (data.waypoints && Array.isArray(data.waypoints)) {\n        // Use batch mode to prevent redundant calculations during loading\n        this.beginBatch();\n        \n        // Convert plain objects to Waypoint instances with validation\n        this.waypoints = data.waypoints\n          .map(wpData => {\n            // Validate waypoint data before hydration\n            if (!Waypoint.validate(wpData)) {\n              console.warn('Invalid waypoint data, skipping:', wpData);\n              return null;\n            }\n            return Waypoint.fromJSON(wpData);\n          })\n          .filter(wp => wp !== null); // Remove invalid waypoints\n        \n        // Populate ID lookup map\n        this.waypoints.forEach(wp => this._addWaypointToMap(wp));\n        \n        // End batch mode - triggers single path calculation\n        this.endBatch();\n        \n        console.log('Loaded waypoints:', this.waypoints.length);\n      }\n      if (data.styles) {\n        this.styles = { ...this.styles, ...data.styles };\n      }\n      \n      // IMPORTANT: Load animation state BEFORE calculating path\n      // This ensures path calculation uses the correct saved speed\n      if (data.animationState) {\n        const savedState = data.animationState;\n        \n        // Restore animation state to AnimationEngine\n        this.animationEngine.setMode(savedState.mode || 'constant-speed');\n        this.animationEngine.setSpeed(savedState.speed || ANIMATION.DEFAULT_SPEED);\n        this.animationEngine.setPlaybackSpeed(savedState.playbackSpeed || 1);\n        // Don't restore duration yet - will be recalculated from path length + speed\n        \n        // Update UI to match loaded values\n        if (this.elements.animationSpeed) {\n          const loadedSpeed = savedState.speed || ANIMATION.DEFAULT_SPEED;\n          console.log('\uD83C\uDFAF [loadAutosave] Setting slider to:', loadedSpeed, '(from savedState.speed:', savedState.speed, ')');\n          // Use event to avoid feedback loop\n          this.eventBus.emit('ui:slider:update-speed', loadedSpeed);\n          // Duration display will be updated after path calculation\n        }\n        \n        // Always show speed control\n        if (this.elements.speedControl) {\n          this.elements.speedControl.style.display = 'flex';\n        }\n      }\n      \n      if (data.background) {\n        this.background.overlay = data.background.overlay ?? this.background.overlay;\n        this.background.fit = data.background.fit ?? this.background.fit;\n        \n        // Update toggle button to match loaded state\n        if (this.elements.bgFitToggle) {\n          this.elements.bgFitToggle.textContent = this.background.fit === 'fit' ? 'Fit' : 'Fill';\n          this.elements.bgFitToggle.dataset.mode = this.background.fit;\n        }\n        // Reflect overlay in UI if controls exist\n        if (this.elements.bgOverlay) {\n          this.elements.bgOverlay.value = String(this.background.overlay);\n          this.elements.bgOverlayValue.textContent = String(this.background.overlay);\n        }\n      }\n      \n      // Calculate path with loaded speed - this will recalculate correct duration\n      this.calculatePath();\n      this.updateWaypointList();\n      \n      // Set animation to end position by default (not playing)\n      this.animationEngine.seekToProgress(1.0);\n      this.animationEngine.pause();\n      \n      this.announce('Previous session restored');\n    } catch (e) {\n      console.warn('No autosave found or failed to load');\n    }\n  }\n  \n  /**\n   * Start the render loop using AnimationEngine\n   * Performance optimizations:\n   * - Conditional rendering: Only renders when state changes (~90% CPU reduction when paused)\n   * - Throttled time display: Updates only when seconds change (~98% fewer DOM updates)\n   * - Delegates animation logic to AnimationEngine service\n   */\n  startRenderLoop() {\n    // Track state changes for conditional rendering\n    let lastProgress = -1;\n    let lastWaitingState = false;\n    \n    // Start AnimationEngine with update callback\n    this.animationEngine.start((state) => {\n      // Performance optimization: Only render when animation state changes\n      const progressChanged = Math.abs(state.progress - lastProgress) > 0.0001;\n      const waitingChanged = state.isWaitingAtWaypoint !== lastWaitingState;\n      const shouldRender = state.isPlaying || progressChanged || waitingChanged;\n      \n      if (shouldRender) {\n        // Sync UI with animation state (minimal updates)\n        this.syncUIWithAnimationState(state);\n        \n        // Render canvas\n        this.render();\n        \n        // Update tracking for next frame\n        lastProgress = state.progress;\n        lastWaitingState = state.isWaitingAtWaypoint;\n      }\n    });\n  }\n  \n  /**\n   * Synchronize UI elements with AnimationEngine state\n   * Performance optimization: Throttles time display updates to once per second\n   */\n  syncUIWithAnimationState(state) {\n    // Update timeline slider (needs high precision)\n    const timelineProgress = state.currentTime / state.duration;\n    this.elements.timelineSlider.value = timelineProgress * ANIMATION.TIMELINE_RESOLUTION;\n    \n    // Update time display only when seconds change (98% fewer DOM updates)\n    const currentSeconds = Math.floor(state.currentTime / 1000);\n    if (currentSeconds !== this._lastDisplayedSecond) {\n      this.updateTimeDisplay(state.currentTime, state.duration);\n      this._lastDisplayedSecond = currentSeconds;\n    }\n  }\n  \n  /**\n   * Update time display with current and total time\n   * @param {number} currentTime - Current time in milliseconds (optional, uses engine state if not provided)\n   * @param {number} duration - Total duration in milliseconds (optional, uses engine state if not provided)\n   */\n  updateTimeDisplay(currentTime = null, duration = null) {\n    const formatTime = (ms) => {\n      const seconds = Math.floor(ms / 1000);\n      const minutes = Math.floor(seconds / 60);\n      const secs = seconds % 60;\n      return `${minutes}:${secs.toString().padStart(2, '0')}`;\n    };\n    \n    // Use provided values or fall back to AnimationEngine state\n    const current = currentTime !== null ? currentTime : this.animationEngine.state.currentTime;\n    const total = duration !== null ? duration : this.animationEngine.state.duration;\n    \n    this.elements.currentTime.textContent = formatTime(current);\n    this.elements.totalTime.textContent = formatTime(total);\n  }\n  \n  render() {\n    const { ctx } = this;\n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    // Safety check - ensure canvas has valid dimensions\n    if (cw <= 0 || ch <= 0) {\n      console.warn('Cannot render to canvas with invalid dimensions:', { width: cw, height: ch });\n      return; // Skip rendering\n    }\n    \n    // Clear\n    ctx.clearRect(0, 0, cw, ch);\n    \n    // 1) Base image\n    this.renderBackground(ctx);\n    // 2) Contrast overlay\n    this.renderOverlay(ctx);\n    \n    // 3-6) Vector + head + UI handles on offscreen canvas\n    const vCanvas = this.getVectorCanvas();\n    \n    // Safety check for vector canvas\n    if (vCanvas.width <= 0 || vCanvas.height <= 0) {\n      console.warn('Vector canvas has invalid dimensions:', { width: vCanvas.width, height: vCanvas.height });\n      return; // Skip drawing vector layer\n    }\n    \n    const vctx = vCanvas.getContext('2d');\n    vctx.clearRect(0, 0, vCanvas.width, vCanvas.height);\n    this.renderVectorLayerTo(vctx);\n    \n    // Safety check before drawing vector layer\n    if (vCanvas.width > 0 && vCanvas.height > 0) {\n      // Blit vector layer to main\n      ctx.drawImage(vCanvas, 0, 0);\n    }\n  }\n\n  // ----- Layer helpers -----\n  getVectorCanvas() {\n    if (!this.vectorCanvas) {\n      this.vectorCanvas = document.createElement('canvas');\n    }\n    \n    // Get canvas dimensions with safety checks\n    const cw = this.displayWidth || this.canvas.width || 100; // Fallback to minimum size\n    const ch = this.displayHeight || this.canvas.height || 100;\n    \n    // Ensure we have valid dimensions > 0\n    const safeWidth = Math.max(1, cw);\n    const safeHeight = Math.max(1, ch);\n    \n    // Only update if dimensions changed\n    if (this.vectorCanvas.width !== safeWidth || this.vectorCanvas.height !== safeHeight) {\n      console.log('Resizing vector canvas to:', safeWidth, 'x', safeHeight);\n      this.vectorCanvas.width = safeWidth;\n      this.vectorCanvas.height = safeHeight;\n      \n      // Disable smoothing on vector canvas too\n      const vctx = this.vectorCanvas.getContext('2d');\n      if (vctx) {\n        vctx.imageSmoothingEnabled = false;\n      }\n    }\n    \n    return this.vectorCanvas;\n  }\n  \n  \n  renderBackground(ctx) {\n    if (!this.background.image) return;\n    \n    const img = this.background.image;\n    const iw = img.naturalWidth || img.width;\n    const ih = img.naturalHeight || img.height;\n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    if (this.background.fit === 'fit') {\n      // Fit: scale image to fit entirely within canvas (may have letterboxing)\n      const scale = Math.min(cw / iw, ch / ih);\n      const dw = Math.round(iw * scale);\n      const dh = Math.round(ih * scale);\n      const dx = Math.floor((cw - dw) / 2);\n      const dy = Math.floor((ch - dh) / 2);\n      // Draw entire source image scaled to fit\n      ctx.drawImage(img, 0, 0, iw, ih, dx, dy, dw, dh);\n    } else {\n      // Fill: enlarge so smaller dimension fills the canvas, center and crop\n      const scale = Math.max(cw / iw, ch / ih);\n      // Calculate which portion of source to show\n      const sw = cw / scale;  // source width to show\n      const sh = ch / scale;  // source height to show\n      const sx = (iw - sw) / 2;  // center horizontally\n      const sy = (ih - sh) / 2;  // center vertically\n      // Draw cropped portion of source image to fill entire canvas\n      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);\n    }\n  }\n  \n  renderOverlay(ctx) {\n    const v = this.background.overlay;\n    if (v === 0) return;\n    \n    const cw = this.displayWidth || this.canvas.width;\n    const ch = this.displayHeight || this.canvas.height;\n    \n    ctx.save();\n    ctx.globalAlpha = Math.min(Math.abs(v) / 100, 0.6);\n    ctx.fillStyle = v < 0 ? '#000' : '#fff';\n    ctx.fillRect(0, 0, cw, ch);\n    ctx.restore();\n  }\n\n  renderVectorLayerTo(targetCtx) {\n    const orig = this.ctx; this.ctx = targetCtx;\n    // 4) Vector layer (paths, labels, waypoints)\n    if (this.pathPoints.length > 0 && this.waypoints.length > 1) {\n      const totalPoints = this.pathPoints.length;\n      // Get current animation progress from AnimationEngine\n      const progress = this.animationEngine.getProgress();\n      const pointsToRender = Math.floor(totalPoints * progress);\n      const segments = this.waypoints.length - 1;\n      const pointsPerSegment = Math.floor(totalPoints / segments);\n      const controllerForSegment = new Array(segments);\n      \n      // Store exact waypoint positions in path points for later use in labels\n      this.waypointPositions = [];\n      this.waypoints.forEach((wp, index) => {\n        if (index < this.waypoints.length - 1) {\n          const exactPointIndex = (index / segments) * totalPoints;\n          this.waypointPositions.push({\n            waypointIndex: index,\n            pointIndex: exactPointIndex\n          });\n        }\n      });\n      \n      let lastMajorIdx = -1;\n      for (let s = 0; s < segments; s++) {\n        if (this.waypoints[s].isMajor) lastMajorIdx = s;\n        controllerForSegment[s] = lastMajorIdx;\n      }\n      for (let i = 1; i < pointsToRender; i++) {\n        const segmentIndex = Math.min(Math.floor(i / pointsPerSegment), segments - 1);\n        const controllerIdx = controllerForSegment[segmentIndex];\n        const controller = controllerIdx >= 0 ? this.waypoints[controllerIdx] : {\n          segmentColor: this.styles.pathColor,\n          segmentWidth: this.styles.pathThickness,\n          segmentStyle: 'solid',\n          pathShape: 'line'\n        };\n        this.ctx.strokeStyle = controller.segmentColor;\n        this.ctx.lineWidth = controller.segmentWidth;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        this.applyLineStyle(controller.segmentStyle);\n        this.ctx.beginPath();\n        \n        const pathShape = controller.pathShape || 'line';\n        const p1 = this.pathPoints[i - 1];\n        const p2 = this.pathPoints[i];\n        \n        if (pathShape === 'squiggle') {\n          // Create a wavy path using control points\n          const midX = (p1.x + p2.x) / 2;\n          const midY = (p1.y + p2.y) / 2;\n          const perpX = -(p2.y - p1.y) * 0.15; // Perpendicular offset\n          const perpY = (p2.x - p1.x) * 0.15;\n          \n          this.ctx.moveTo(p1.x, p1.y);\n          const wave = Math.sin(i * 0.5) * 0.5;\n          this.ctx.quadraticCurveTo(\n            midX + perpX * wave, \n            midY + perpY * wave,\n            p2.x, p2.y\n          );\n        } else if (pathShape === 'randomised') {\n          // Add random jitter to the path\n          const jitterAmount = 3;\n          const jitteredP1 = {\n            x: p1.x + (Math.random() - 0.5) * jitterAmount,\n            y: p1.y + (Math.random() - 0.5) * jitterAmount\n          };\n          const jitteredP2 = {\n            x: p2.x + (Math.random() - 0.5) * jitterAmount,\n            y: p2.y + (Math.random() - 0.5) * jitterAmount\n          };\n          this.ctx.moveTo(jitteredP1.x, jitteredP1.y);\n          this.ctx.lineTo(jitteredP2.x, jitteredP2.y);\n        } else {\n          // Default line\n          this.ctx.moveTo(p1.x, p1.y);\n          this.ctx.lineTo(p2.x, p2.y);\n        }\n        \n        this.ctx.stroke();\n      }\n      this.ctx.setLineDash([]);\n      \n      // 5) Path head layer\n      if (pointsToRender > 1) {\n        // Get the path head position\n        const headIndex = Math.min(pointsToRender - 1, this.pathPoints.length - 1);\n        const head = this.pathPoints[headIndex];\n        \n        // Calculate direction for rotation (based on previous point)\n        let rotation = 0;\n        if (headIndex > 0) {\n          const prevPoint = this.pathPoints[headIndex - 1];\n          rotation = Math.atan2(head.y - prevPoint.y, head.x - prevPoint.x);\n        }\n        \n        // Store calculated rotation\n        this.styles.pathHead.rotation = rotation;\n        \n        // Draw path head based on style\n        this.drawPathHead(head.x, head.y, rotation);\n      }\n    }\n    \n    // Beacons\n    if (this.pathPoints.length > 0) {\n      // Get current progress from AnimationEngine\n      const currentProgress = this.animationEngine.getProgress();\n      const totalPoints = this.pathPoints.length;\n      \n      // Use exact progress comparison instead of point index for more precision\n      this.waypoints.forEach((waypoint, wpIndex) => {\n        if (waypoint.isMajor) {\n          // Calculate normalized progress for this waypoint\n          const exactWaypointProgress = wpIndex / (this.waypoints.length - 1);\n          \n          // Show beacon EXACTLY when we reach a waypoint (not after)\n          // Use a small threshold to ensure reliable triggering\n          const atWaypoint = Math.abs(currentProgress - exactWaypointProgress) < 0.001;\n          \n          // Show beacon exactly when paused at this waypoint\n          const isPausedHere = this.animationEngine.state.isPaused && \n                              this.animationEngine.state.pauseWaypointIndex === wpIndex;\n          \n          // Show beacon when either exactly at waypoint or paused at it\n          if (atWaypoint || isPausedHere) {\n            // Convert waypoint to canvas coords for drawing beacon\n            const wpCanvas = this.imageToCanvas(waypoint.imgX, waypoint.imgY);\n            this.drawBeacon({ ...waypoint, x: wpCanvas.x, y: wpCanvas.y });\n          }\n        }\n      });\n    }\n    \n    // 6) UI handles (visible markers)\n    this.waypoints.forEach(waypoint => {\n      if (waypoint.isMajor) {\n        // Convert waypoint from image coords to canvas coords\n        const wpCanvas = this.imageToCanvas(waypoint.imgX, waypoint.imgY);\n        const isSelected = waypoint === this.selectedWaypoint;\n        const markerSize = waypoint.dotSize || this.styles.dotSize;\n        const size = isSelected ? markerSize * 1.3 : markerSize;\n        const markerStyle = waypoint.markerStyle || this.styles.markerStyle;\n        \n        // Skip rendering if marker style is 'none'\n        if (markerStyle === 'none') {\n          this.renderLabel(waypoint, wpCanvas.x, wpCanvas.y, 0);\n          return;\n        }\n        \n        this.ctx.fillStyle = waypoint.dotColor || waypoint.segmentColor || this.styles.dotColor;\n        this.ctx.strokeStyle = isSelected ? '#4a90e2' : 'white';\n        this.ctx.lineWidth = isSelected ? 3 : 2;\n        \n        // Draw different marker types\n        if (markerStyle === 'square') {\n          // Square marker\n          this.ctx.beginPath();\n          this.ctx.rect(wpCanvas.x - size, wpCanvas.y - size, size * 2, size * 2);\n          this.ctx.fill();\n          this.ctx.stroke();\n        } else if (markerStyle === 'flag') {\n          // Flag marker\n          this.ctx.beginPath();\n          // Pole\n          this.ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          this.ctx.lineTo(wpCanvas.x, wpCanvas.y + size);\n          // Flag\n          this.ctx.moveTo(wpCanvas.x, wpCanvas.y - size * 2);\n          this.ctx.lineTo(wpCanvas.x + size * 1.5, wpCanvas.y - size * 1.3);\n          this.ctx.lineTo(wpCanvas.x + size * 1.2, wpCanvas.y - size);\n          this.ctx.lineTo(wpCanvas.x, wpCanvas.y - size * 0.7);\n          this.ctx.closePath();\n          this.ctx.fill();\n          this.ctx.stroke();\n        } else {\n          // Default to dot\n          this.ctx.beginPath();\n          this.ctx.arc(wpCanvas.x, wpCanvas.y, size, 0, Math.PI * 2);\n          this.ctx.fill();\n          this.ctx.stroke();\n        }\n        \n        // Draw labels for major waypoints\n        this.renderLabel(waypoint, wpCanvas.x, wpCanvas.y, size);\n      }\n    });\n    this.ctx = orig;\n  }\n  \n  // Label rendering with positioning and show/hide behavior\n  renderLabel(waypoint, x, y, dotSize) {\n    // Skip if no label text or mode is 'none'\n    if (!waypoint.label || waypoint.labelMode === 'none') return;\n    \n    // Find the true waypoint position in path coordinates\n    const wpIndex = this.waypoints.indexOf(waypoint);\n    const totalPoints = this.pathPoints.length;\n    \n    // Get exact path position for this waypoint\n    let waypointPointIndex = 0;\n    if (wpIndex < this.waypoints.length - 1) {\n      waypointPointIndex = (wpIndex / (this.waypoints.length - 1)) * totalPoints;\n    } else {\n      waypointPointIndex = totalPoints;\n    }\n    \n    // Current animation position in path coordinates\n    const exactCurrentPoint = totalPoints * this.animationEngine.getProgress();\n    \n    // Calculate animation timing parameters\n    // Increased fade time for more noticeable transition\n    const fadeTimeInPoints = totalPoints * 0.02; // 1% of animation = 0.5 seconds\n    let opacity = 0; // Start with zero opacity\n    \n    // Handle different label modes\n    switch (waypoint.labelMode) {\n      case 'on': \n        // Always visible with full opacity\n        opacity = 1.0;\n        break;\n        \n      case 'fade':\n        // Only show label when waypoint is reached\n        if (exactCurrentPoint < waypointPointIndex) return;\n        \n        // Calculate time since waypoint was reached\n        const elapsed = exactCurrentPoint - waypointPointIndex;\n        \n        // Fade in quickly (over 0.25 seconds)\n        if (elapsed <= fadeTimeInPoints / 2) {\n          opacity = Math.min(1.0, elapsed / (fadeTimeInPoints / 2));\n          opacity = Math.pow(opacity, 0.5); // Use square root for faster initial appearance\n        }\n        // Hold during the future waypoint pause time (to be implemented)\n        else if (elapsed <= fadeTimeInPoints * 3) {\n          opacity = 1.0;\n        }\n        // Fade out over 0.5 seconds\n        else if (elapsed <= fadeTimeInPoints * 4) {\n          opacity = 1.0 - Math.min(1.0, (elapsed - fadeTimeInPoints * 3) / fadeTimeInPoints);\n        }\n        // Don't show after fade out\n        else {\n          return;\n        }\n        break;\n        \n      case 'persist':\n        // Start fading in exactly 0.5 seconds before waypoint\n        const timeBeforeWaypoint = waypointPointIndex - exactCurrentPoint;\n        \n        // If we haven't reached the fade-in period yet\n        if (timeBeforeWaypoint > fadeTimeInPoints) return;\n        \n        // If we're in the fade-in period before reaching waypoint\n        if (timeBeforeWaypoint > 0) {\n          // Accelerated fade-in (starts faster)\n          const fadeProgress = 1.0 - (timeBeforeWaypoint / fadeTimeInPoints);\n          opacity = Math.pow(fadeProgress, 0.5); // Square root for quicker initial appearance\n        }\n        // After reaching waypoint, full opacity\n        else {\n          opacity = 1.0;\n        }\n        break;\n        \n      default:\n        return; // Unknown mode\n    }\n    \n    // Debug output to console\n    // if (wpIndex === 0) console.log(`Label ${wpIndex}: opacity=${opacity.toFixed(2)}`);\n    \n    // Save context for restoring later\n    this.ctx.save();\n    \n    // Apply calculated opacity with a higher minimum to make fade-in more noticeable\n    this.ctx.globalAlpha = Math.max(0.15, opacity);\n    \n    // Label style\n    this.ctx.font = 'bold 16px Arial';\n    \n    // Visual effect depends on opacity during fade\n    // Subtle blue highlight during fade-in, white at full opacity\n    const blueAmount = opacity < 1.0 ? Math.max(0, 1 - opacity) * 60 : 0;\n    this.ctx.fillStyle = `rgb(${255-blueAmount}, ${255-blueAmount}, 255)`;\n    this.ctx.strokeStyle = '#000';\n    this.ctx.lineWidth = 3;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    \n    // Add shadow for better visibility\n    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.shadowBlur = 5;\n    this.ctx.shadowOffsetX = 2;\n    this.ctx.shadowOffsetY = 2;\n    \n    // Calculate label position based on position setting\n    const padding = RENDERING.LABEL_OFFSET_X; // Distance from dot edge to label\n    const position = waypoint.labelPosition || 'auto';\n    let labelX = x;\n    let labelY = y;\n    \n    // Adjust position based on setting\n    switch (position) {\n      case 'top':\n        labelY = y - dotSize - padding;\n        break;\n      case 'right':\n        labelX = x + dotSize + padding;\n        this.ctx.textAlign = 'left';\n        break;\n      case 'bottom':\n        labelY = y + dotSize + padding;\n        break;\n      case 'left':\n        labelX = x - dotSize - padding;\n        this.ctx.textAlign = 'right';\n        break;\n      case 'auto':\n      default:\n        // Auto position to avoid going off-screen\n        const cw = this.displayWidth || this.canvas.width;\n        const ch = this.displayHeight || this.canvas.height;\n        \n        // Default to top position\n        labelY = y - dotSize - padding;\n        \n        // Check if too close to top edge\n        if (labelY < 30) {\n          labelY = y + dotSize + padding; // Switch to bottom\n        }\n        \n        // Check if too close to sides\n        if (x < 100) {\n          labelX = x + dotSize + padding;\n          this.ctx.textAlign = 'left';\n        } else if (x > cw - 100) {\n          labelX = x - dotSize - padding;\n          this.ctx.textAlign = 'right';\n        }\n        break;\n    }\n    \n    // Draw text with outline for readability\n    this.ctx.strokeText(waypoint.label, labelX, labelY);\n    this.ctx.fillText(waypoint.label, labelX, labelY);\n    \n    // Restore context to clear shadow and alpha\n    this.ctx.restore();\n  }\n\n  // ----- Assets -----\n  loadImageFile(file) {\n    return new Promise((resolve, reject) => {\n      const url = URL.createObjectURL(file);\n      const img = new Image();\n      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };\n      img.onerror = reject;\n      img.src = url;\n    });\n  }\n  \n  loadDefaultImage() {\n    const img = new Image();\n    img.onload = () => {\n      this.background.image = img;\n      this.updateImageTransform(img);\n      // Recalculate path with proper image bounds now that image is loaded\n      if (this.waypoints.length >= 2) {\n        this.calculatePath();\n      }\n      this.render();\n      console.log('Default image (UoN_map.png) loaded for dev testing');\n    };\n    img.onerror = (err) => {\n      console.warn('Could not load default image:', err);\n      // Continue rendering even without image\n      this.render();\n    };\n    img.src = './UoN_map.png';\n  }\n  \n  applyLineStyle(style) {\n    switch (style) {\n      case 'dotted':\n        this.ctx.setLineDash([2, 6]);\n        break;\n      case 'dashed':\n        this.ctx.setLineDash([10, 5]);\n        break;\n      case 'squiggle':\n        // Approximated with dashed pattern - true squiggle would need complex path manipulation\n        this.ctx.setLineDash([5, 3, 2, 3]);\n        break;\n      case 'solid':\n      default:\n        this.ctx.setLineDash([]);\n        break;\n    }\n  }\n  \n  // Draw the path head based on current style settings\n  drawPathHead(x, y, rotation) {\n    // Safety check for valid coordinates\n    if (!isFinite(x) || !isFinite(y)) {\n      console.warn('Invalid path head coordinates:', {x, y});\n      return;\n    }\n    \n    const pathHead = this.styles.pathHead;\n    const size = pathHead.size;\n    \n    this.ctx.save();\n    this.ctx.translate(x, y);\n    this.ctx.rotate(rotation);\n    \n    switch (pathHead.style) {\n      case 'dot':\n        // Simple dot (filled circle)\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        this.ctx.fill();\n        break;\n        \n      case 'arrow':\n        // Arrow shape\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        \n        // Draw arrow pointing right (rotation will handle direction)\n        this.ctx.moveTo(size, 0);            // Tip\n        this.ctx.lineTo(-size/2, size/2);    // Bottom corner\n        this.ctx.lineTo(-size/4, 0);         // Indentation\n        this.ctx.lineTo(-size/2, -size/2);   // Top corner\n        this.ctx.closePath();\n        this.ctx.fill();\n        break;\n        \n      case 'custom':\n        // Custom image\n        if (pathHead.image) {\n          const imgSize = size * 2; // Make image slightly larger for better visibility\n          // Draw the image centered and rotated\n          this.ctx.drawImage(\n            pathHead.image, \n            -imgSize/2, -imgSize/2,\n            imgSize, imgSize\n          );\n        } else {\n          // Fallback to dot if no image loaded\n          this.ctx.beginPath();\n          this.ctx.fillStyle = pathHead.color;\n          this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n          this.ctx.fill();\n        }\n        break;\n        \n      default:\n        // Default to dot\n        this.ctx.beginPath();\n        this.ctx.fillStyle = pathHead.color;\n        this.ctx.arc(0, 0, size / 2, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    \n    this.ctx.restore();\n  }\n\n  drawBeacon(point) {\n    const bStyle = point.beaconStyle || 'none';\n    const bColor = point.beaconColor || this.styles.beaconColor;\n    if (bStyle === 'none') return;\n    \n    // Safety check for valid coordinates\n    if (!isFinite(point.x) || !isFinite(point.y)) {\n      console.warn('Invalid beacon coordinates:', point);\n      return;\n    }\n    \n    if (bStyle === 'pulse') {\n      // Update pulse phase\n      this.beaconAnimation.pulsePhase = performance.now() * 0.003;\n      \n      // Pulsing dot\n      const pulse = 1 + Math.sin(this.beaconAnimation.pulsePhase) * 0.3;\n      const pulseSize = RENDERING.BEACON_PULSE_SIZE * pulse;\n      \n      // Outer glow\n      this.ctx.beginPath();\n      this.ctx.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);\n      this.ctx.fillStyle = bColor;\n      this.ctx.globalAlpha = RENDERING.BEACON_PULSE_OPACITY;\n      this.ctx.fill();\n      \n      // Update pulse animation state\n      this.beaconAnimation.pulsePhase = (this.beaconAnimation.pulsePhase + 0.1) % (Math.PI * 2);\n    } \n    else if (bStyle === 'ripple') {\n      // Ripple effect - expanding circles that fade out\n      const now = Date.now();\n      \n      // Add a new ripple every interval\n      if (!point.lastRipple || now - point.lastRipple > RENDERING.BEACON_RIPPLE_INTERVAL) {\n        this.beaconAnimation.ripples.push({\n          x: point.x, \n          y: point.y, \n          radius: 0,\n          opacity: 0.5,\n          startTime: now,\n          color: bColor\n        });\n        point.lastRipple = now;\n      }\n      \n      // Draw all active ripples\n      this.beaconAnimation.ripples = this.beaconAnimation.ripples.filter(ripple => {\n        const age = now - ripple.startTime;\n        if (age > RENDERING.BEACON_RIPPLE_DURATION) return false; // Remove old ripples\n        \n        // Calculate current radius with smooth fade-out\n        const radius = age / RENDERING.BEACON_RIPPLE_SPEED;\n        const fadeProgress = age / RENDERING.BEACON_RIPPLE_DURATION;\n        const opacity = 0.5 * (1 - Easing.cubicOut(fadeProgress));\n        \n        // Draw ripple\n        this.ctx.beginPath();\n        this.ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);\n        this.ctx.strokeStyle = ripple.color;\n        this.ctx.lineWidth = 2;\n        this.ctx.globalAlpha = opacity;\n        this.ctx.stroke();\n        \n        return true;\n      });\n      \n      // Draw center dot\n      this.ctx.beginPath();\n      this.ctx.fillStyle = bColor;\n      this.ctx.globalAlpha = 0.8;\n      this.ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);\n      this.ctx.fill();\n    }\n    \n    // Reset global alpha to prevent affecting subsequent draws\n    this.ctx.globalAlpha = 1.0;\n  }\n  \n  /**\n   * Clean up resources and event listeners\n   */\n  destroy() {\n    // Stop animation\n    this.animationEngine?.stop();\n    \n    // Clean up controllers\n    this.interactionHandler?.destroy();\n    this.pathCalculator?.destroy();\n    \n    // Remove all event listeners\n    this.eventBus?.removeAll();\n    \n    // Clear render queue\n    if (this.renderQueued) {\n      cancelAnimationFrame(this.renderQueued);\n      this.renderQueued = false;\n    }\n    \n    // Clear timeouts\n    if (this._durationUpdateTimeout) {\n      clearTimeout(this._durationUpdateTimeout);\n    }\n    \n    // Clear canvases\n    this.ctx?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    if (this.vectorCanvas) {\n      const vctx = this.vectorCanvas.getContext('2d');\n      vctx?.clearRect(0, 0, this.vectorCanvas.width, this.vectorCanvas.height);\n    }\n    \n    // Nullify references for garbage collection\n    this.waypoints = null;\n    this.pathPoints = null;\n    this.selectedWaypoint = null;\n    this.waypointsById = null;\n    this.background = null;\n    this.elements = null;\n    \n    console.log('Route Plotter destroyed');\n  }\n}\n\n// Initialize app when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  window.app = new RoutePlotter();\n});\n"],
  "mappings": "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",
  "names": ["CatmullRom", "_CatmullRom", "p0", "p1", "p2", "p3", "t", "tension", "t2", "t3", "v0x", "v0y", "v1x", "v1y", "dx", "dy", "waypoints", "pointsPerSegment", "path", "lastIndex", "step", "i", "j", "Easing", "t", "t1", "ANIMATION", "RENDERING", "PATH", "INTERACTION", "STORAGE", "StorageService", "key", "data", "serialized", "error", "defaultValue", "item", "state", "newSerialized", "STORAGE", "preferences", "jsonString", "estimate", "CoordinateTransform", "width", "height", "fitMode", "canvasAspect", "imageAspect", "scale", "x", "y", "w", "h", "sw", "sh", "sx", "sy", "canvasX", "canvasY", "t", "imageX", "imageY", "bounds", "PathCalculator", "waypoints", "options", "coords", "wp", "roughPath", "CatmullRom", "PATH", "evenPath", "rawPath", "targetSpacing", "curvatures", "distances", "totalDistance", "i", "dx", "dy", "physicalDist", "curvature", "velocityFactor", "adjustedDist", "numPoints", "targetDist", "segmentIdx", "segStart", "segLength", "t", "p1", "p2", "maxCurvature", "minSpeed", "normalizedCurvature", "easedCurvature", "Easing", "left", "right", "mid", "finalPath", "pathSeed", "point", "totalSegments", "segmentProgress", "controllerIdx", "controller", "pathShape", "pointSeed", "rng1", "rng2", "randX", "randY", "RENDERING", "__spreadProps", "__spreadValues", "cacheKey", "majorWaypoints", "totalWaypoints", "index", "progress", "segments", "rawIndex", "pathPoints", "totalLength", "localProgress", "path", "pathKey", "p0", "area", "d1", "d2", "avgDist", "v1x", "v1y", "v2x", "v2y", "len1", "len2", "n1x", "n1y", "n2x", "n2y", "crossProduct", "dotProduct", "angle", "avgLen", "len", "first", "last", "import_meta", "PathCalculatorWithWorker", "PathCalculator", "error", "event", "type", "data", "id", "request", "waypoints", "resolve", "reject", "wp", "AnimationState", "preservedSpeed", "ANIMATION", "progress", "time", "mode", "waypointIndex", "waitDuration", "progressSnapshot", "data", "AnimationEngine", "eventBus", "AnimationState", "onUpdate", "loop", "timestamp", "elapsed", "ANIMATION", "deltaTime", "time", "progress", "duration", "currentProgress", "speed", "roundedSpeed", "mode", "waypointIndex", "waitDuration", "progressSnapshot", "callback", "pathLength", "eventName", "data", "RenderingService", "ctx", "displayWidth", "displayHeight", "state", "cw", "ch", "vCanvas", "vctx", "safeWidth", "safeHeight", "background", "canvasWidth", "canvasHeight", "img", "iw", "ih", "scale", "dw", "dh", "dx", "dy", "sw", "sh", "sx", "sy", "overlayValue", "waypoints", "pathPoints", "styles", "animationEngine", "selectedWaypoint", "imageToCanvas", "totalPoints", "progress", "exactPosition", "pointsToRender", "fraction", "segments", "pointsPerSegment", "controllerForSegment", "wp", "index", "exactPointIndex", "lastMajorIdx", "s", "i", "segmentIndex", "controllerIdx", "controller", "pathShape", "p1", "p2", "midX", "midY", "perpX", "perpY", "wave", "jitteredP1", "jitteredP2", "partialEnd", "currentIndex", "nextIndex", "currentPoint", "nextPoint", "head", "rotation", "prevPoint", "x", "y", "pathHead", "size", "imgSize", "beaconAnimation", "currentProgress", "waypoint", "wpIndex", "exactWaypointProgress", "atWaypoint", "isPausedHere", "wpCanvas", "__spreadProps", "__spreadValues", "point", "bStyle", "bColor", "pulse", "pulseSize", "RENDERING", "now", "ripple", "age", "radius", "fadeProgress", "opacity", "Easing", "isSelected", "markerSize", "markerStyle", "dotSize", "waypointPointIndex", "exactCurrentPoint", "fadeTimeInPoints", "elapsed", "timeBeforeWaypoint", "blueAmount", "padding", "position", "labelX", "labelY", "style", "EventBus", "eventName", "callback", "listeners", "index", "wrapper", "args", "listener", "error", "promises", "Waypoint", "_Waypoint", "options", "RENDERING", "ANIMATION", "updates", "key", "x", "y", "source", "exclude", "prop", "styleProps", "p", "pathProps", "data", "UIController", "elements", "eventBus", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "_l", "_m", "btn", "e", "file", "value", "newMode", "progress", "ANIMATION", "isUpdatingSlider", "currentValue", "timestamp", "speed", "step", "roundedSpeed", "t", "_n", "_o", "_p", "size", "width", "time", "event", "tabBtn", "tabName", "content", "tabContent", "waypoints", "majorWaypoints", "wp", "waypoint", "index", "item", "handle", "label", "delBtn", "selectWaypoint", "dragging", "rect", "midpoint", "newOrder", "el", "idx", "pauseSeconds", "pauseControl", "state", "currentTime", "duration", "formatTime", "ms", "totalSeconds", "minutes", "seconds", "message", "InteractionHandler", "canvas", "eventBus", "event", "rect", "x", "y", "waypoint", "canvasPos", "newX", "newY", "imgPos", "isMajor", "key", "shift", "ctrl", "moveAmount", "dx", "dy", "direction", "touch", "files", "file", "RoutePlotter", "StorageService", "CoordinateTransform", "PathCalculatorWithWorker", "RenderingService", "EventBus", "AnimationEngine", "RENDERING", "defaultDuration", "UIController", "InteractionHandler", "defaultSpeed", "ANIMATION", "timestamp", "progress", "majorWaypoints", "rect", "controlsHeight", "dpr", "scale", "btn", "e", "tabName", "b", "content", "id", "waypoint", "Waypoint", "index", "preservedSpeed", "totalLength", "totalDuration", "durationSec", "waypointIndex", "file", "img", "value", "mode", "speed", "estimatedDuration", "current", "data", "lastWaypoint", "imgX", "imgY", "isDragging", "_a", "_b", "newOrder", "allWaypoints", "minorWaypoints", "wp", "majorIndex", "callback", "result", "pos", "style", "color", "size", "x", "y", "threshold", "INTERACTION", "wpCanvas", "item", "handle", "label", "delBtn", "selectWaypoint", "pauseTimeSec", "width", "height", "canvasX", "canvasY", "imageX", "imageY", "canvasWaypoints", "canvasPos", "__spreadProps", "__spreadValues", "error", "currentSpeed", "totalSegments", "i", "rawProgress", "Easing", "segmentPosition", "segmentIndex", "proximityThreshold", "nearbyWaypoints", "nextWaypoint", "minPositiveDistance", "pauseMode", "pauseTime", "distanceToWaypoint", "exactWaypointProgress", "waitDuration", "message", "priority", "el", "stylesCopy", "COORD_SYSTEM_VERSION", "wpData", "savedState", "loadedSpeed", "lastProgress", "lastWaitingState", "state", "progressChanged", "waitingChanged", "timelineProgress", "currentSeconds", "currentTime", "duration", "formatTime", "ms", "seconds", "minutes", "secs", "total", "ctx", "cw", "ch", "vCanvas", "vctx", "safeWidth", "safeHeight", "iw", "ih", "dw", "dh", "dx", "dy", "sw", "sh", "sx", "sy", "v", "targetCtx", "orig", "totalPoints", "pointsToRender", "segments", "pointsPerSegment", "controllerForSegment", "exactPointIndex", "lastMajorIdx", "s", "controllerIdx", "controller", "pathShape", "p1", "p2", "midX", "midY", "perpX", "perpY", "wave", "jitteredP1", "jitteredP2", "headIndex", "head", "rotation", "prevPoint", "currentProgress", "wpIndex", "atWaypoint", "isPausedHere", "isSelected", "markerSize", "markerStyle", "dotSize", "waypointPointIndex", "exactCurrentPoint", "fadeTimeInPoints", "opacity", "elapsed", "timeBeforeWaypoint", "fadeProgress", "blueAmount", "padding", "position", "labelX", "labelY", "resolve", "reject", "url", "err", "pathHead", "imgSize", "point", "bStyle", "bColor", "pulse", "pulseSize", "now", "ripple", "age", "radius", "_c", "_d", "_e"]
}
